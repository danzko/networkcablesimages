{"version":3,"file":"esri-leaflet-gp.js","sources":["../package.json","../src/Tasks/Geoprocessing.js","../src/Services/Geoprocessing.js"],"sourcesContent":["{\n  \"name\": \"esri-leaflet-gp\",\n  \"description\": \"A Leaflet plugin for interacting with ArcGIS geoprocessing services.\",\n  \"version\": \"2.0.1\",\n  \"author\": \"John Gravois <jgravois@esri.com> (http://johngravois.com)\",\n  \"browser\": \"dist/esri-leaflet-gp-debug.js\",\n  \"bugs\": {\n    \"url\": \"https://github.com/jgravois/esri-leaflet-gp/issues\"\n  },\n  \"contributors\": [\n    \"John Gravois <jgravois@esri.com> (http://johngravois.com)\",\n    \"Nicholas Furness <nfurness@esri.com> (http://nixta.github.io/)\",\n    \"Patrick Arlt <parlt@esri.com> (http://patrickarlt.com)\",\n    \"Rowan Winsemius\"\n  ],\n  \"dependencies\": {\n    \"leaflet\": \"^1.0.0-rc.3\",\n    \"esri-leaflet\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"chai\": \"2.3.0\",\n    \"gh-release\": \"^2.0.0\",\n    \"highlight.js\": \"^8.0.0\",\n    \"http-server\": \"^0.8.5\",\n    \"isparta\": \"^3.0.3\",\n    \"istanbul\": \"^0.4.2\",\n    \"karma\": \"^0.12.24\",\n    \"karma-chai-sinon\": \"^0.1.3\",\n    \"karma-coverage\": \"^0.5.3\",\n    \"karma-mocha\": \"^0.1.0\",\n    \"karma-mocha-reporter\": \"^0.2.5\",\n    \"karma-phantomjs-launcher\": \"^0.2.0\",\n    \"karma-sourcemap-loader\": \"^0.3.5\",\n    \"mkdirp\": \"^0.5.1\",\n    \"phantomjs\": \"^1.9.17\",\n    \"rollup\": \"^0.25.4\",\n    \"rollup-plugin-json\": \"^2.0.0\",\n    \"rollup-plugin-node-resolve\": \"^1.4.0\",\n    \"rollup-plugin-uglify\": \"^0.1.0\",\n    \"semistandard\": \"^7.0.5\",\n    \"sinon\": \"^1.11.1\",\n    \"sinon-chai\": \"2.7.0\",\n    \"snazzy\": \"^2.0.1\",\n    \"uglify-js\": \"^2.6.1\",\n    \"watch\": \"^0.17.1\"\n  },\n  \"homepage\": \"https://github.com/jgravois/esri-leaflet-gp\",\n  \"jsnext:main\": \"src/EsriLeafletGP.js\",\n  \"jspm\": {\n    \"registry\": \"npm\",\n    \"format\": \"es6\",\n    \"main\": \"src/EsriLeafletGP.js\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"main\": \"dist/esri-leaflet-gp-debug.js\",\n  \"readmeFilename\": \"README.md\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git@github.com:jgravois/esri-leaflet-gp.git\"\n  },\n  \"scripts\": {\n    \"prebuild\": \"mkdirp dist\",\n    \"build\": \"rollup -c profiles/debug.js & rollup -c profiles/production.js\",\n    \"lint\": \"semistandard src/**/*.js | snazzy\",\n    \"prepublish\": \"npm run build\",\n    \"pretest\": \"npm run build\",\n    \"test\": \"npm run lint && karma start\",\n    \"release\": \"./scripts/release.sh\",\n    \"start\": \"watch 'npm run build' src & http-server -p 5000 -c-1 -o\"\n  }\n}\n","/*\nto do:\nsetParam([])\n*/\n\nimport L from 'leaflet';\nimport { Task as BaseTask, Util } from 'esri-leaflet';\n\nexport var Task = BaseTask.extend({\n\n  includes: L.Mixin.Events,\n\n  // setters: {}, we don't use these because we don't know the ParamName OR value of custom GP services\n  params: {},\n  resultParams: {},\n\n  initialize: function (options) {\n    // don't replace parent initialize\n    BaseTask.prototype.initialize.call(this, options);\n\n    // if path isn't supplied in options, try and determine if its sync or async to set automatically\n    if (!this.options.path) {\n      // assume initially, that service is synchronous\n      this.options.async = false;\n      this.options.path = 'execute';\n\n      // the parameters below seem wonky to me, but work for both CORS and JSONP requests\n      this._service.metadata(function (error, results) {\n        if (!error) {\n          if (results.executionType === 'esriExecutionTypeSynchronous') {\n            this.options.async = false;\n            this.options.path = 'execute';\n          } else {\n            this.options.async = true;\n            this.options.path = 'submitJob';\n          }\n          this.fire('initialized');\n        } else {\n          // if check fails, hopefully its synchronous\n          this.options.async = false;\n          this.options.path = 'execute';\n          return;\n        }\n      }, this);\n    } else {\n      // if path is custom, hopefully its synchronous\n      if (this.options.async !== true && this.options.path !== 'submitJob') {\n        this.options.async = false;\n      }\n    }\n  },\n\n  // doc for various GPInput types can be found here\n  // http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/GP_Result/02r3000000q7000000/\n\n  // set booleans, numbers, strings\n  setParam: function (paramName, paramValue) {\n    if (typeof paramValue === 'boolean') {\n      this.params[paramName] = paramValue;\n      return;\n    } else if (typeof paramValue !== 'object') { // strings, numbers\n      this.params[paramName] = paramValue;\n      return;\n    } else {\n      // otherwise assume its latlng, marker, bounds or geojson\n      this._setGeometry(paramName, paramValue);\n    }\n  },\n\n  // not sure how best to handle passing more than one parameter at once\n  // setParams: function(inputArray) {\n  //   if (L.Util.isArray(inputArray)) {\n  //     for (var i = 0; i < inputArray.length; i++) {\n  //       this.setParam(inputArray[i]);\n  //     }\n  //   }\n  // },\n\n  // give developer opportunity to point out where the output is going to be available\n  setOutputParam: function (paramName) {\n    this.params.outputParam = paramName;\n  },\n\n  /* necessary because of the design requirement that resultParams be specified\n  for async elevation services in order to get Zs (unnecessarily confusing)*/\n  gpAsyncResultParam: function (paramName, paramValue) {\n    this.resultParams[paramName] = paramValue;\n  },\n\n  // we currently expect a single geometry or feature (ported from: Tasks.Query._setGeometry)\n  _setGeometry: function (paramName, geometry) {\n    var processedInput = {\n      'geometryType': '',\n      'features': []\n    };\n\n    // convert bounds to extent and finish\n    if (geometry instanceof L.LatLngBounds) {\n      // set geometry + type\n      processedInput.features.push({'geometry': L.esri.Util.boundsToExtent(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // convert L.Marker > L.LatLng\n    if (geometry.getLatLng) {\n      geometry = geometry.getLatLng();\n    }\n\n    // convert L.LatLng to a geojson point and continue;\n    if (geometry instanceof L.LatLng) {\n      geometry = {\n        type: 'Point',\n        coordinates: [geometry.lng, geometry.lat]\n      };\n    }\n\n    // handle L.GeoJSON, pull out the first geometry\n    if (geometry instanceof L.GeoJSON) {\n      // reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)\n      geometry = geometry.getLayers()[0].feature.geometry;\n      processedInput.features.push({'geometry': Util.geojsonToArcGIS(geometry)});\n      processedInput.geometryType = Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // Handle L.Polyline and L.Polygon\n    if (geometry.toGeoJSON) {\n      geometry = geometry.toGeoJSON();\n    }\n\n    // handle GeoJSON feature by pulling out the geometry\n    if (geometry.type === 'Feature') {\n      // get the geometry of the geojson feature\n      geometry = geometry.geometry;\n    }\n\n    // confirm that our GeoJSON is a point, line or polygon\n    if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon') {\n      processedInput.features.push({'geometry': Util.geojsonToArcGIS(geometry)});\n      processedInput.geometryType = Util.geojsonTypeToArcGIS(geometry.type);\n    } else {\n      if (console && console.warn) {\n        console.warn('invalid geometry passed as GP input. Should be an L.LatLng, L.LatLngBounds, L.Marker or GeoJSON Point Line or Polygon object');\n      }\n    }\n\n    this.params[paramName] = processedInput;\n    return;\n  },\n\n  run: function (callback, context) {\n    this._done = false;\n\n    if (this.options.async === true) {\n      /* eslint-disable */\n      this._service.request(this.options.path, this.params, function (error, response) {\n        this._currentJobId = response.jobId;\n        this.checkJob(this._currentJobId, callback, context);\n      }, this);\n      /* eslint-enable */\n    } else {\n      return this._service.request(this.options.path, this.params, function (error, response) {\n        callback.call(context, error, (response && this.processGPOutput(response)), response);\n      }, this);\n    }\n  },\n\n  checkJob: function (jobId, callback, context) {\n    var pollJob = function () {\n      /* eslint-disable */\n      this._service.request('jobs/' + jobId, {}, function polledJob (error, response) {\n        if (response.jobStatus === 'esriJobSucceeded') {\n          if (!this._done) {\n            this._done = true;\n            // to do:\n            // refactor to make an array of async requests for output\n            this._service.request('jobs/' + jobId + '/results/' + this.params.outputParam, this.resultParams, function processJobResult (error, response) {\n              callback.call(context, error, (response && this.processAsyncOutput(response)), response);\n            }, this);\n          }\n          window.clearInterval(counter);\n        } else if (response.jobStatus === 'esriJobFailed') {\n          callback.call(context, 'Job Failed', null);\n          window.clearInterval(counter);\n        }\n      }, this);\n      /* eslint-enable */\n    }.bind(this);\n\n    var counter = window.setInterval(pollJob, this._service.options.asyncInterval * 1000);\n  },\n\n  processGPOutput: function (response) {\n    var processedResponse = {};\n\n    // grab syncronous results\n    if (this.options.async === false) {\n      // loop through results and pass back, parsing esri json\n      for (var i = 0; i < response.results.length; i++) {\n        /* jshint ignore:start */\n        processedResponse[response.results[i].paramName];\n        /* jshint ignore:end */\n        if (response.results[i].dataType === 'GPFeatureRecordSetLayer') {\n          var featureCollection = Util.responseToFeatureCollection(response.results[i].value);\n          processedResponse[response.results[i].paramName] = featureCollection;\n        } else {\n          processedResponse[response.results[i].paramName] = response.results[i].value;\n        }\n      }\n    } else { // grab async results slightly differently\n      processedResponse.jobId = this._currentJobId;\n      // var responseValue = response.value;\n    }\n\n    // if output is a raster layer, we also need to stub out a MapService url using jobid\n    if (this.options.async === true && response.dataType === 'GPRasterDataLayer') {\n      var baseURL = this.options.url;\n      var n = baseURL.indexOf('GPServer');\n      var serviceURL = baseURL.slice(0, n) + 'MapServer/';\n      processedResponse.outputMapService = serviceURL + 'jobs/' + this._currentJobId;\n    }\n\n    return processedResponse;\n  },\n\n  processAsyncOutput: function (response) {\n    var processedResponse = {};\n    processedResponse.jobId = this._currentJobId;\n\n    // if output is a raster layer, we also need to stub out a MapService url using jobid\n    if (this.options.async === true && response.dataType === 'GPRasterDataLayer') {\n      var baseURL = this.options.url;\n      var n = baseURL.indexOf('GPServer');\n      var serviceURL = baseURL.slice(0, n) + 'MapServer/';\n      processedResponse.outputMapService = serviceURL + 'jobs/' + this._currentJobId;\n    }\n\n    // if output is GPFeatureRecordSetLayer, convert to GeoJSON\n    if (response.dataType === 'GPFeatureRecordSetLayer') {\n      var featureCollection = Util.responseToFeatureCollection(response.value);\n      processedResponse[response.paramName] = featureCollection;\n    } else {\n      processedResponse[response.paramName] = response.value;\n    }\n\n    return processedResponse;\n  }\n\n});\n\nexport function task (options) {\n  return new Task(options);\n}\n\nexport default task;\n","import { Service as BaseService } from 'esri-leaflet';\nimport { Task } from '../Tasks/Geoprocessing';\n\nexport var Service = BaseService.extend({\n  options: {\n    asyncInterval: 1\n  },\n\n  createTask: function () {\n    return new Task(this, this.options);\n  }\n\n});\n\nexport function service (options) {\n  return new Service(options);\n}\n\nexport default service;\n"],"names":["task","options","Task","service","Service","BaseTask","extend","includes","L","Mixin","Events","params","resultParams","initialize","prototype","call","this","path","async","_service","metadata","error","results","executionType","fire","setParam","paramName","paramValue","_setGeometry","setOutputParam","outputParam","gpAsyncResultParam","geometry","processedInput","geometryType","features","LatLngBounds","push","esri","Util","boundsToExtent","geojsonTypeToArcGIS","type","getLatLng","LatLng","coordinates","lng","lat","GeoJSON","getLayers","feature","geojsonToArcGIS","toGeoJSON","console","warn","run","callback","context","_done","request","response","processGPOutput","_currentJobId","jobId","checkJob","pollJob","jobStatus","processAsyncOutput","window","clearInterval","counter","bind","setInterval","asyncInterval","processedResponse","i","length","dataType","featureCollection","responseToFeatureCollection","value","baseURL","url","n","indexOf","serviceURL","slice","outputMapService","BaseService","createTask"],"mappings":"iUCyPO,SAASA,GAAMC,GACpB,MAAO,IAAIC,GAAKD,GC5OX,QAASE,GAASF,GACvB,MAAO,IAAIG,GAAQH,gDDPVC,EAAOG,OAASC,QAEzBC,SAAUC,EAAEC,MAAMC,OAGlBC,UACAC,gBAEAC,WAAY,SAAUZ,GAEpBI,OAASS,UAAUD,WAAWE,KAAKC,KAAMf,GAGpCe,KAAKf,QAAQgB,KAyBZD,KAAKf,QAAQiB,SAAU,GAA8B,cAAtBF,KAAKf,QAAQgB,OAC9CD,KAAKf,QAAQiB,OAAQ,IAxBvBF,KAAKf,QAAQiB,OAAQ,EACrBF,KAAKf,QAAQgB,KAAO,UAGpBD,KAAKG,SAASC,SAAS,SAAUC,EAAOC,GACtC,MAAKD,IAWHL,KAAKf,QAAQiB,OAAQ,OACrBF,KAAKf,QAAQgB,KAAO,aAXU,iCAA1BK,EAAQC,eACVP,KAAKf,QAAQiB,OAAQ,EACrBF,KAAKf,QAAQgB,KAAO,YAEpBD,KAAKf,QAAQiB,OAAQ,EACrBF,KAAKf,QAAQgB,KAAO,iBAEtBD,MAAKQ,KAAK,iBAOXR,QAaPS,SAAU,SAAUC,EAAWC,GAC7B,MAA0B,iBAAfA,QACTX,KAAKL,OAAOe,GAAaC,GAEM,gBAAfA,QAChBX,KAAKL,OAAOe,GAAaC,OAIzBX,MAAKY,aAAaF,EAAWC,IAcjCE,eAAgB,SAAUH,GACxBV,KAAKL,OAAOmB,YAAcJ,GAK5BK,mBAAoB,SAAUL,EAAWC,GACvCX,KAAKJ,aAAac,GAAaC,GAIjCC,aAAc,SAAUF,EAAWM,GACjC,GAAIC,IACFC,aAAgB,GAChBC,YAIEH,aAAoBxB,GAAE4B,eAExBH,EAAeE,SAASE,MAAML,SAAYxB,EAAE8B,KAAKC,KAAKC,eAAeR,KACrEC,EAAeC,aAAe1B,EAAE8B,KAAKC,KAAKE,oBAAoBT,EAASU,OAIrEV,EAASW,YACXX,EAAWA,EAASW,aAIlBX,YAAoBxB,GAAEoC,SACxBZ,GACEU,KAAM,QACNG,aAAcb,EAASc,IAAKd,EAASe,OAKrCf,YAAoBxB,GAAEwC,UAExBhB,EAAWA,EAASiB,YAAY,GAAGC,QAAQlB,SAC3CC,EAAeE,SAASE,MAAML,SAAYO,OAAKY,gBAAgBnB,KAC/DC,EAAeC,aAAeK,OAAKE,oBAAoBT,EAASU,OAI9DV,EAASoB,YACXpB,EAAWA,EAASoB,aAIA,YAAlBpB,EAASU,OAEXV,EAAWA,EAASA,UAIA,UAAlBA,EAASU,MAAsC,eAAlBV,EAASU,MAA2C,YAAlBV,EAASU,MAC1ET,EAAeE,SAASE,MAAML,SAAYO,OAAKY,gBAAgBnB,KAC/DC,EAAeC,aAAeK,OAAKE,oBAAoBT,EAASU,OAE5DW,SAAWA,QAAQC,MACrBD,QAAQC,KAAK,gIAIjBtC,KAAKL,OAAOe,GAAaO,GAI3BsB,IAAK,SAAUC,EAAUC,GAGvB,MAFAzC,MAAK0C,OAAQ,EAET1C,KAAKf,QAAQiB,SAAU,EAQlBF,KAAKG,SAASwC,QAAQ3C,KAAKf,QAAQgB,KAAMD,KAAKL,OAAQ,SAAUU,EAAOuC,GAC5EJ,EAASzC,KAAK0C,EAASpC,EAAQuC,GAAY5C,KAAK6C,gBAAgBD,GAAYA,IAC3E5C,UARHA,MAAKG,SAASwC,QAAQ3C,KAAKf,QAAQgB,KAAMD,KAAKL,OAAQ,SAAUU,EAAOuC,GACrE5C,KAAK8C,cAAgBF,EAASG,MAC9B/C,KAAKgD,SAAShD,KAAK8C,cAAeN,EAAUC,IAC3CzC,OASPgD,SAAU,SAAUD,EAAOP,EAAUC,GACnC,GAAIQ,GAAU,WAEZjD,KAAKG,SAASwC,QAAQ,QAAUI,KAAW,SAAoB1C,EAAOuC,GACzC,qBAAvBA,EAASM,WACNlD,KAAK0C,QACR1C,KAAK0C,OAAQ,EAGb1C,KAAKG,SAASwC,QAAQ,QAAUI,EAAQ,YAAc/C,KAAKL,OAAOmB,YAAad,KAAKJ,aAAc,SAA2BS,EAAOuC,GAClIJ,EAASzC,KAAK0C,EAASpC,EAAQuC,GAAY5C,KAAKmD,mBAAmBP,GAAYA,IAC9E5C,OAELoD,OAAOC,cAAcC,IACW,kBAAvBV,EAASM,YAClBV,EAASzC,KAAK0C,EAAS,aAAc,MACrCW,OAAOC,cAAcC,KAEtBtD,OAEHuD,KAAKvD,MAEHsD,EAAUF,OAAOI,YAAYP,EAA+C,IAAtCjD,KAAKG,SAASlB,QAAQwE,gBAGlEZ,gBAAiB,SAAUD,GACzB,GAAIc,KAGJ,IAAI1D,KAAKf,QAAQiB,SAAU,EAEzB,IAAK,GAAIyD,GAAI,EAAGA,EAAIf,EAAStC,QAAQsD,OAAQD,IAI3C,GAFAD,EAAkBd,EAAStC,QAAQqD,GAAGjD,WAED,4BAAjCkC,EAAStC,QAAQqD,GAAGE,SAAwC,CAC9D,GAAIC,GAAoBvC,OAAKwC,4BAA4BnB,EAAStC,QAAQqD,GAAGK,MAC7EN,GAAkBd,EAAStC,QAAQqD,GAAGjD,WAAaoD,MAEnDJ,GAAkBd,EAAStC,QAAQqD,GAAGjD,WAAakC,EAAStC,QAAQqD,GAAGK,UAI3EN,GAAkBX,MAAQ/C,KAAK8C,aAKjC,IAAI9C,KAAKf,QAAQiB,SAAU,GAA8B,sBAAtB0C,EAASiB,SAAkC,CAC5E,GAAII,GAAUjE,KAAKf,QAAQiF,IACvBC,EAAIF,EAAQG,QAAQ,YACpBC,EAAaJ,EAAQK,MAAM,EAAGH,GAAK,YACvCT,GAAkBa,iBAAmBF,EAAa,QAAUrE,KAAK8C,cAGnE,MAAOY,IAGTP,mBAAoB,SAAUP,GAC5B,GAAIc,KAIJ,IAHAA,EAAkBX,MAAQ/C,KAAK8C,cAG3B9C,KAAKf,QAAQiB,SAAU,GAA8B,sBAAtB0C,EAASiB,SAAkC,CAC5E,GAAII,GAAUjE,KAAKf,QAAQiF,IACvBC,EAAIF,EAAQG,QAAQ,YACpBC,EAAaJ,EAAQK,MAAM,EAAGH,GAAK,YACvCT,GAAkBa,iBAAmBF,EAAa,QAAUrE,KAAK8C,cAInE,GAA0B,4BAAtBF,EAASiB,SAAwC,CACnD,GAAIC,GAAoBvC,OAAKwC,4BAA4BnB,EAASoB,MAClEN,GAAkBd,EAASlC,WAAaoD,MAExCJ,GAAkBd,EAASlC,WAAakC,EAASoB,KAGnD,OAAON,MCjPAtE,EAAUoF,UAAYlF,QAC/BL,SACEwE,cAAe,GAGjBgB,WAAY,WACV,MAAO,IAAIvF,GAAKc,KAAMA,KAAKf"}