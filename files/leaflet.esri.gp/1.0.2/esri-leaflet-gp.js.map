{"version":3,"file":"esri-leaflet-gp.js","sources":["esri-leaflet-gp-src.js"],"names":["EsriLeafletGP","Tasks","Services","Controls","window","L","esri","GP","Esri","Geoprocessing","Service","extend","options","asyncInterval","createTask","this","geoprocessing","Task","includes","Mixin","Events","params","resultParams","initialize","prototype","call","path","async","_service","metadata","error","results","executionType","fire","setParam","paramName","paramValue","_setGeometry","setOutputParam","outputParam","gpAsyncResultParam","geometry","processedInput","geometryType","features","LatLngBounds","push","Util","boundsToExtent","geojsonTypeToArcGIS","type","getLatLng","LatLng","coordinates","lng","lat","GeoJSON","getLayers","feature","geojsonToArcGIS","toGeoJSON","console","warn","run","callback","context","_done","request","response","processGPOutput","_currentJobId","jobId","checkJob","pollJob","jobStatus","processAsyncOutput","clearInterval","counter","bind","setInterval","responseValue","processedResponse","i","length","dataType","featureCollection","responseToFeatureCollection","value","baseURL","url","n","indexOf","serviceURL","slice","outputMapService"],"mappings":"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","sourcesContent":["/*! esri-leaflet-gp - v1.0.2 - 2015-07-14\n*   Copyright (c) 2015 Environmental Systems Research Institute, Inc.\n*   Apache 2.0 License */\n\nvar EsriLeafletGP = {\n  Tasks: {},\n  Services: {},\n  Controls: {}\n};\n\n// attach to the L.esri global if we can\nif(typeof window !== 'undefined' && window.L && window.L.esri) {\n  window.L.esri.GP = EsriLeafletGP;\n}\n\n// We do not have an 'Esri' variable e.g loading this file directly from source define 'Esri'\nif(!Esri){\n  var Esri = window.L.esri;\n}\n\nEsriLeafletGP.Services.Geoprocessing = Esri.Services.Service.extend({\n  options: {\n    asyncInterval: 1\n  },\n\n  createTask: function(){\n    return new EsriLeafletGP.Tasks.Geoprocessing(this, this.options);\n  }\n});\n\nEsriLeafletGP.Services.geoprocessing = function(options) {\n  return new EsriLeafletGP.Services.Geoprocessing(options);\n};\n\n/*\nto do:\nsetParam([])\n*/\n\nEsriLeafletGP.Tasks.Geoprocessing = Esri.Tasks.Task.extend({\n\n  includes: L.Mixin.Events,\n\n  //setters: {}, we don't use these because we don't know the ParamName OR value of custom GP services\n  params: {},\n  resultParams: {},\n\n  initialize: function(options) {\n    //don't replace parent initialize\n    L.esri.Tasks.Task.prototype.initialize.call(this, options);\n\n    //if path isn't supplied in options, try and determine if its sync or async to set automatically\n    if (!this.options.path) {\n      //assume initially, that service is synchronous\n      this.options.async = false;\n      this.options.path = 'execute';\n\n      //the parameters below seem wonky to me, but work for both CORS and JSONP requests\n      this._service.metadata(function(error, results) {\n        if (!error) {\n          if (results.executionType === 'esriExecutionTypeSynchronous') {\n            this.options.async = false;\n            this.options.path = 'execute';\n          } else {\n            this.options.async = true;\n            this.options.path = 'submitJob';\n          }\n          this.fire('initialized');\n        } else {\n          //if check fails, hopefully its synchronous\n          this.options.async = false;\n          this.options.path = 'execute';\n          return;\n        }\n      }, this);\n    }\n    else {\n      //if path is custom, hopefully its synchronous\n      if (this.options.async !== true && this.options.path !=='submitJob') {\n        this.options.async = false;\n      }\n    }\n  },\n\n  //doc for various GPInput types can be found here\n  //http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/GP_Result/02r3000000q7000000/\n\n  //set booleans, numbers, strings\n  setParam: function(paramName, paramValue) {\n    if (typeof paramValue === 'boolean') {\n      this.params[paramName] = paramValue;\n      return;\n    }\n    //strings, numbers\n    else if (typeof paramValue !== 'object') {\n      this.params[paramName] = paramValue;\n      return;\n    }\n    else {\n      //otherwise assume its latlng, marker, bounds or geojson\n      this._setGeometry(paramName, paramValue);\n    }\n  },\n\n  // not sure how best to handle passing more than one parameter at once\n  // setParams: function(inputArray) {\n  //   if (L.Util.isArray(inputArray)) {\n  //     for (var i = 0; i < inputArray.length; i++) {\n  //       this.setParam(inputArray[i]);\n  //     }\n  //   }\n  // },\n\n  // give developer opportunity to point out where the output is going to be available\n  setOutputParam: function(paramName) {\n    this.params.outputParam = paramName;\n  },\n\n  /* necessary because of the design requirement that resultParams be specified\n  for async elevation services in order to get Zs (unnecessarily confusing)*/\n  gpAsyncResultParam: function(paramName, paramValue) {\n    this.resultParams[paramName] = paramValue;\n  },\n\n  // we currently expect a single geometry or feature (ported from: Tasks.Query._setGeometry)\n  _setGeometry: function(paramName, geometry) {\n    var processedInput = {\n      'geometryType': '',\n      'features': []\n    };\n\n    // convert bounds to extent and finish\n    if ( geometry instanceof L.LatLngBounds ) {\n      // set geometry + type\n      processedInput.features.push({'geometry': L.esri.Util.boundsToExtent(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // convert L.Marker > L.LatLng\n    if(geometry.getLatLng){\n      geometry = geometry.getLatLng();\n    }\n\n    // convert L.LatLng to a geojson point and continue;\n    if (geometry instanceof L.LatLng) {\n      geometry = {\n        type: 'Point',\n        coordinates: [geometry.lng, geometry.lat]\n      };\n    }\n\n    // handle L.GeoJSON, pull out the first geometry\n    if ( geometry instanceof L.GeoJSON ) {\n      //reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)\n      geometry = geometry.getLayers()[0].feature.geometry;\n      processedInput.features.push({'geometry': L.esri.Util.geojsonToArcGIS(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    // Handle L.Polyline and L.Polygon\n    if (geometry.toGeoJSON) {\n      geometry = geometry.toGeoJSON();\n    }\n\n    // handle GeoJSON feature by pulling out the geometry\n    if ( geometry.type === 'Feature' ) {\n      // get the geometry of the geojson feature\n      geometry = geometry.geometry;\n    }\n\n    // confirm that our GeoJSON is a point, line or polygon\n    if ( geometry.type === 'Point' ||  geometry.type === 'LineString' || geometry.type === 'Polygon') {\n      processedInput.features.push({'geometry': L.esri.Util.geojsonToArcGIS(geometry)});\n      processedInput.geometryType = L.esri.Util.geojsonTypeToArcGIS(geometry.type);\n    }\n\n    else {\n      if(console && console.warn) {\n        console.warn('invalid geometry passed as GP input. Should be an L.LatLng, L.LatLngBounds, L.Marker or GeoJSON Point Line or Polygon object');\n      }\n    }\n\n    this.params[paramName] = processedInput;\n    return;\n  },\n\n  run: function(callback, context) {\n    this._done = false;\n\n    if (this.options.async === true) {\n      this._service.request(this.options.path, this.params, function(error, response) {\n        this._currentJobId = response.jobId;\n        this.checkJob(this._currentJobId, callback, context);\n      }, this);\n    } else {\n      return this._service.request(this.options.path, this.params, function(error, response) {\n        callback.call(context, error, (response && this.processGPOutput(response)), response);\n      }, this);\n    }\n  },\n\n  checkJob: function(jobId, callback, context) {\n    var pollJob = function() {\n      this._service.request('jobs/' + jobId, {}, function polledJob(error, response) {\n        if (response.jobStatus === 'esriJobSucceeded') {\n          if (!this._done){\n            this._done = true;\n            // to do:\n            // refactor to make an array of async requests for output\n            this._service.request('jobs/' + jobId + '/results/' + this.params.outputParam, this.resultParams, function processJobResult(error, response) {\n              callback.call(context, error, (response && this.processAsyncOutput(response)), response);\n            }, this);\n          }\n          window.clearInterval(counter);\n        } else if (response.jobStatus === 'esriJobFailed') {\n          callback.call(context, 'Job Failed', null);\n          window.clearInterval(counter);\n        }\n      }, this);\n    }.bind(this);\n\n    var counter = window.setInterval(pollJob, this._service.options.asyncInterval*1000);\n\n  },\n\n  processGPOutput: function(response) {\n    var processedResponse = {};\n    var responseValue;\n\n  \t// grab syncronous results\n  \tif (this.options.async === false) {\n  \t  // loop through results and pass back, parsing esri json\n      for (var i=0;i<response.results.length;i++){\n        /* jshint ignore:start */\n        processedResponse[response.results[i].paramName];\n        /* jshint ignore:end */\n        if (response.results[i].dataType === 'GPFeatureRecordSetLayer') {\n          var featureCollection = L.esri.Util.responseToFeatureCollection(response.results[i].value);\n          processedResponse[response.results[i].paramName] = featureCollection;\n        }\n        else {\n          processedResponse[response.results[i].paramName] = response.results[i].value;\n        }\n      }\n  \t}\n\n  \t//grab async results slightly differently\n  \telse {\n  \t\tprocessedResponse.jobId = this._currentJobId;\n  \t  responseValue = response.value;\n  \t}\n\n  \t// if output is a raster layer, we also need to stub out a MapService url using jobid\n  \tif (this.options.async === true && response.dataType === 'GPRasterDataLayer') {\n  \t\tvar baseURL = this.options.url;\n  \t\tvar n = baseURL.indexOf('GPServer');\n  \t\tvar serviceURL = baseURL.slice(0,n)+'MapServer/';\n  \t\tprocessedResponse.outputMapService = serviceURL+'jobs/'+this._currentJobId;\n  \t}\n\n    return processedResponse;\n  },\n\n  processAsyncOutput: function(response) {\n    var processedResponse = {};\n    processedResponse.jobId = this._currentJobId;\n\n    // if output is a raster layer, we also need to stub out a MapService url using jobid\n    if (this.options.async === true && response.dataType === 'GPRasterDataLayer') {\n      var baseURL = this.options.url;\n      var n = baseURL.indexOf('GPServer');\n      var serviceURL = baseURL.slice(0,n)+'MapServer/';\n      processedResponse.outputMapService = serviceURL+'jobs/'+this._currentJobId;\n    }\n\n    // if output is GPFeatureRecordSetLayer, convert to GeoJSON\n    if (response.dataType === 'GPFeatureRecordSetLayer' ) {\n      var featureCollection = L.esri.Util.responseToFeatureCollection(response.value);\n      processedResponse[response.paramName] = featureCollection;\n    }\n\n    else {\n      processedResponse[response.paramName] = response.value;\n    }\n\n    return processedResponse;\n  }\n\n});\n\nEsriLeafletGP.Tasks.geoprocessing = function(params) {\n  return new EsriLeafletGP.Tasks.Geoprocessing(params);\n};\n"]}