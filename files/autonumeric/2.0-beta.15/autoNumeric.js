(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *               autoNumeric.js\n *\n * @version      2.0-beta.15\n * @date         2016-12-27 UTC 14:00\n *\n * @author       Bob Knothe\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\n *               cf. AUTHORS.md.\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n * @since        2009-08-09\n *\n * @summary      autoNumeric is a jQuery plugin that automatically formats currency\n * (money) and numbers as-you-type in a form inputs. It supports most\n * international numeric formats and currency signs including those used in\n * Europe, North and South America, Asia, as well as India's' lakhs.\n *\n *               Note : Some functions are borrowed from big.js\n * @link         https://github.com/MikeMcl/big.js/\n *\n * Please report any bugs to https://github.com/BobKnothe/autoNumeric\n *\n * @license      Released under the MIT License\n * @link         http://www.opensource.org/licenses/mit-license.php\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\n * Defaults options are public - these can be overridden by the following:\n * - HTML5 data attributes\n * - Options passed by the 'init' or 'update' methods\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nvar defaultSettings = {\n    /* Allowed thousand separator characters\n     * comma = \",\"\n     * period \"full stop\" = \".\"\n     * quote = \"'\"\n     * space = \" \"\n     * none = \"\"\n     * NOTE: do not use numeric characters\n     * Deprecated older option name : aSep\n     */\n    digitGroupSeparator: ',',\n\n    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     * Deprecated older option name : nSep\n     */\n    noSeparatorOnFocus: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\n     * Deprecated older option name : dGroup\n     */\n    digitalGroupSpacing: '3',\n\n    /* Allowed decimal separator characters\n     * period \"full stop\" = \".\"\n     * comma = \",\"\n     * Deprecated older option name : aDec\n     */\n    decimalCharacter: '.',\n\n    /* Allow to declare alternative decimal separator which is automatically replaced by decimalCharacter\n     * developed for countries the use a comma \",\" as the decimal character\n     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n     * Deprecated older option name : altDec\n     */\n    decimalCharacterAlternative: null,\n\n    /* currencySymbol = allowed currency symbol\n     * Must be in quotes currencySymbol: \"$\"\n     * space to the right of the currency symbol currencySymbol: '$ '\n     * space to the left of the currency symbol currencySymbol: ' $'\n     * Deprecated older option name : aSign\n     */\n    currencySymbol: '',\n\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\n     * for prefix currencySymbolPlacement: \"p\" (default)\n     * for suffix currencySymbolPlacement: \"s\"\n     * Deprecated older option name : pSign\n     */\n    currencySymbolPlacement: 'p',\n\n    /* Placement of negative sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {currencySymbol: \"$\"}\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"}\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"}\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\n     * Deprecated older option name : pNeg\n     */\n    negativePositiveSignPlacement: 'l',\n\n    /* Additional suffix\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     * Deprecated older option name : aSuffix\n     */\n    suffixText: '',\n\n    /* Override min max limits\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\n     * Deprecated older option name : oLimits\n     */\n    overrideMinMaxLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than minimumValue\n     * Deprecated older option name : vMax\n     */\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than maximumValue\n     * Deprecated older option name : vMin\n     */\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\n     * Deprecated older option name : mDec\n     */\n    decimalPlacesOverride: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     * Deprecated older option name : eDec\n     */\n    decimalPlacesShownOnFocus: null,\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     * Deprecated older option name : scaleDecimal\n     */\n    scaleDecimalPlaces: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     * Deprecated older option name : aStor\n     */\n    saveValueToSessionStorage: false,\n\n    /*\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\n     *                The non-pasted numbers are dropped and therefore not used at all.\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\n     *\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\n     *          Only the first number will be used (here '123').\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\n     */\n    //TODO Shouldn't we use `truncate` as the default value?\n    onInvalidPaste: 'error',\n\n    /* method used for rounding\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * roundingMethod: \"U05\" Rounds up to next .05\n     * roundingMethod: \"D05\" Rounds down to next .05\n     * Deprecated older option name : mRound\n     */\n    roundingMethod: 'S',\n\n    /* Controls decimal padding\n     * allowDecimalPadding: true - always Pad decimals with zeros\n     * allowDecimalPadding: false - does not pad with zeros.\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     * Deprecated older option name : aPad\n     */\n    allowDecimalPadding: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * negativeBracketsTypeOnBlur: null - (default)\n     * negativeBracketsTypeOnBlur: '(,)', negativeBracketsTypeOnBlur: '[,]', negativeBracketsTypeOnBlur: '<,>' or negativeBracketsTypeOnBlur: '{,}'\n     * Deprecated older option name : nBracket\n     */\n    negativeBracketsTypeOnBlur: null,\n\n    /* Displayed on empty string \"\"\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n     * Deprecated older option name : wEmpty\n     */\n    emptyInputBehavior: 'focus',\n\n    /* Controls leading zero behavior\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     * Deprecated older option name : lZero\n     */\n    leadingZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value on initialization\n     * Deprecated older option name : aForm\n     */\n    formatOnPageLoad: true,\n\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\n     * Deprecated older option name : sNumber\n     */\n    selectNumberOnly: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {defaultValueOverride: \"\"}\n     * value=1234.56 {defaultValueOverride: '1234.56'}\n     * Deprecated older option name : anDefault\n     */\n    defaultValueOverride: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     * Deprecated older option name : unSetOnSubmit\n     */\n    unformatOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     * Deprecated older option name : outputType\n     */\n    outputFormat: null,\n\n    /* Error handling function\n     * true => all warning are shown\n     * false => no warnings are shown, only the thrown errors\n     * Deprecated older option name : debug\n     */\n    showWarnings: true,\n\n    /*\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\n     */\n    failOnUnknownOption: false\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n * //TODO Replace every call to this object with a call to `keyName`\n * @deprecated\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\n * Those names are listed here :\n * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n */\nvar keyName = {\n    // Special values\n    Unidentified: 'Unidentified',\n\n    // Modifier keys\n    Alt: 'Alt',\n    AltGr: 'AltGraph',\n    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n    Ctrl: 'Control',\n    Fn: 'Fn',\n    FnLock: 'FnLock',\n    Hyper: 'Hyper', // 'OS' under Firefox\n    Meta: 'Meta', // The Windows, Command or ⌘ key // 'OS' under Firefox and IE9\n    Windows: 'Meta', // This is a non-official key name\n    Command: 'Meta', // This is a non-official key name\n    NumLock: 'NumLock',\n    ScrollLock: 'ScrollLock',\n    Shift: 'Shift',\n    Super: 'Super', // 'OS' under Firefox\n    Symbol: 'Symbol',\n    SymbolLock: 'SymbolLock',\n\n    // Whitespace keys\n    Enter: 'Enter',\n    Tab: 'Tab',\n    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\n    // Navigation keys\n    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n    End: 'End',\n    Home: 'Home',\n    PageDown: 'PageDown',\n    PageUp: 'PageUp',\n\n    // Editing keys\n    Backspace: 'Backspace',\n    Clear: 'Clear',\n    Copy: 'Copy',\n    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n    Cut: 'Cut',\n    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n    EraseEof: 'EraseEof',\n    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n    Insert: 'Insert',\n    Paste: 'Paste',\n    Redo: 'Redo',\n    Undo: 'Undo',\n\n    // UI keys\n    Accept: 'Accept',\n    Again: 'Again',\n    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n    Cancel: 'Cancel',\n    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n    Execute: 'Execute',\n    Find: 'Find',\n    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n    Help: 'Help',\n    Pause: 'Pause',\n    Play: 'Play',\n    Props: 'Props',\n    Select: 'Select',\n    ZoomIn: 'ZoomIn',\n    ZoomOut: 'ZoomOut',\n\n    // Device keys\n    BrightnessDown: 'BrightnessDown',\n    BrightnessUp: 'BrightnessUp',\n    Eject: 'Eject',\n    LogOff: 'LogOff',\n    Power: 'Power',\n    PowerOff: 'PowerOff',\n    PrintScreen: 'PrintScreen',\n    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n    WakeUp: 'WakeUp',\n\n    // IME and composition keys\n    Compose: 'Compose',\n    Dead: 'Dead',\n\n    // Function keys\n    F1: 'F1',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n\n    // Document keys\n    Print: 'Print',\n\n    // 'Normal' keys\n    num0: '0',\n    num1: '1',\n    num2: '2',\n    num3: '3',\n    num4: '4',\n    num5: '5',\n    num6: '6',\n    num7: '7',\n    num8: '8',\n    num9: '9',\n    numpad0: '0',\n    numpad1: '1',\n    numpad2: '2',\n    numpad3: '3',\n    numpad4: '4',\n    numpad5: '5',\n    numpad6: '6',\n    numpad7: '7',\n    numpad8: '8',\n    numpad9: '9',\n    a: 'a',\n    b: 'b',\n    c: 'c',\n    d: 'd',\n    e: 'e',\n    f: 'f',\n    g: 'g',\n    h: 'h',\n    i: 'i',\n    j: 'j',\n    k: 'k',\n    l: 'l',\n    m: 'm',\n    n: 'n',\n    o: 'o',\n    p: 'p',\n    q: 'q',\n    r: 'r',\n    s: 's',\n    t: 't',\n    u: 'u',\n    v: 'v',\n    w: 'w',\n    x: 'x',\n    y: 'y',\n    z: 'z',\n    MultiplyNumpad: '*',\n    PlusNumpad: '+',\n    MinusNumpad: '-',\n    DotNumpad: '.',\n    SlashNumpad: '/',\n    Semicolon: ';',\n    Equal: '=',\n    Comma: ',',\n    Hyphen: '-',\n    Minus: '-',\n    Plus: '+',\n    Dot: '.',\n    Slash: '/',\n    Backquote: '`',\n    LeftBracket: '[',\n    RightBracket: ']',\n    Backslash: '\\\\',\n    Quote: \"'\"\n};\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param {string} value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param {object} obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the parameter is a number (or a number written as a string).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\n     * Return TRUE if the parameter is an integer (and not a float).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param {string} text\n     * @param {AutoNumericHolder} holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {*} needle\n     * @param {Array} array\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    // function hasDecimals(str) {\n    //     const [, decimalPart] = str.split('.');\n    //     return !isUndefined(decimalPart);\n    // }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     *\n     * @param {string} str\n     * @returns {int}\n     */\n    function decimalPlaces(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Return the code for the key used to generate the given event.\n     *\n     * @param {Event} event\n     * @returns {string|Number}\n     */\n    function keyCodeNumber(event) {\n        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n    }\n\n    /**\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\n     *\n     * @param {string} value\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\n     * @returns {boolean}\n     */\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n        var parsedValue = parseStr(value);\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n    }\n\n    /**\n     * Return TRUE if the given string contains a negative sign on the first character.\n     *\n     * @param {string} string A number represented by a string\n     * @returns {boolean}\n     */\n    function isNegative(string) {\n        return string.charAt(0) === '-';\n    }\n\n    /**\n     * Return the negative version of the value (represented as a string) given as a parameter.\n     *\n     * @param {string} value\n     * @returns {*}\n     */\n    function setRawNegativeSign(value) {\n        if (!isNegative(value)) {\n            return '-' + value;\n        }\n\n        return value;\n    }\n\n    /**\n     * Insert a character or a string at the index given (0 being the far left side).\n     *\n     * @param {string} str\n     * @param {string} char\n     * @param {int} caretPosition\n     * @returns {string}\n     */\n    function insertCharAtPosition(str, char, caretPosition) {\n        return '' + str.slice(0, caretPosition) + char + str.slice(caretPosition);\n    }\n\n    /**\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\n     *\n     * @param {string} string\n     * @param {int} index\n     * @param {string} newCharacter\n     * @returns {string}\n     */\n    function replaceCharAt(string, index, newCharacter) {\n        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n    }\n\n    /**\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\n     *\n     * @param {string|number} value\n     * @param {object} settings\n     * @returns {number}\n     */\n    function clampToRangeLimits(value, settings) {\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n    }\n\n    /**\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\n     *\n     * @param {string} formattedNumberString\n     * @param {int} caretPosition This must be a positive integer\n     * @param {string} decimalCharacter\n     * @returns {number}\n     */\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\n        var numberDotAndNegativeSignCount = 0;\n        for (var i = 0; i < caretPosition; i++) {\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                numberDotAndNegativeSignCount++;\n            }\n        }\n\n        return numberDotAndNegativeSignCount;\n    }\n\n    /**\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\n     *\n     * @example\n     * 1234567|89.01   : position 7 (rawNumberString)\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\n     *\n     * @param {string} rawNumberString\n     * @param {int} caretPositionInRawValue\n     * @param {string} formattedNumberString\n     * @param {string} decimalCharacter\n     * @returns {*}\n     */\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n        var formattedNumberStringSize = formattedNumberString.length;\n        var rawNumberStringSize = rawNumberString.length;\n\n        var formattedNumberStringIndex = void 0;\n        var rawNumberStringIndex = 0;\n        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n                rawNumberStringIndex++;\n            }\n        }\n\n        return formattedNumberStringIndex;\n    }\n\n    /**\n     * Return the number of dot '.' in the given text.\n     *\n     * @param {string} text\n     * @returns {number}\n     */\n    function countDotsInText(text) {\n        return countCharInText('.', text);\n    }\n\n    /**\n     * Count the number of occurrence of the given character, in the given text.\n     *\n     * @param {string} character\n     * @param {string} text\n     * @returns {number}\n     */\n    function countCharInText(character, text) {\n        var charCounter = 0;\n        for (var i = 0; i < text.length; i++) {\n            if (text[i] === character) {\n                charCounter++;\n            }\n        }\n\n        return charCounter;\n    }\n\n    /**\n     * Return the index that can be used to set the caret position.\n     * This takes into account that the position is starting at '0', not 1.\n     *\n     * @param {int} characterCount\n     * @returns {number}\n     */\n    function convertCharacterCountToIndexPosition(characterCount) {\n        return Math.max(characterCount, characterCount - 1);\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @returns {{}}\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @param {int} start\n     * @param {int|null} end\n     */\n    function setElementSelection(that, start) {\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        if (isUndefinedOrNullOrEmpty(end)) {\n            end = start;\n        }\n\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function that throw error messages\n     *\n     * @param {string} message\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\n     * Function that display a warning messages, according to the debug level.\n     *\n     * @param {string} message\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\n     */\n    function warning(message) {\n        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (showWarning) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * Run any callbacks found in the settings object.\n     * Any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\n     *\n     * @param {string} minimumValue\n     * @param {string} maximumValue\n     * @returns {number}\n     */\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n    }\n\n    /**\n     * Strip all unwanted non-number characters and leave only a number alert\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} leftOrAll\n     * @returns {string|*}\n     */\n\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n        if (settings.currencySymbol !== '') {\n            // Remove currency sign\n            s = s.replace(settings.currencySymbol, '');\n        }\n        if (settings.suffixText) {\n            // Remove suffix\n            while (contains(s, settings.suffixText)) {\n                s = s.replace(settings.suffixText, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.decimalCharacterAlternative) {\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n        }\n\n        // Get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.decimalCharacter),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                nSign = settings.negativeSignCharacter;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n        }\n\n        if (leftOrAll && settings.leadingZero === 'deny' || !settings.onOff && settings.leadingZero === 'allow') {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * Sets or removes brackets on negative values, depending on the focus state.\n     * The focus state is 'stored' in the settings object under the `settings.onOff` attribute. //TODO Use another object to keep track of internal data that are not settings\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function toggleNegativeBracket(s, settings) {\n        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n                firstBracket = _settings$negativeBra2[0],\n                lastBracket = _settings$negativeBra2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.negativeSignCharacter, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Convert locale format to Javascript numeric string\n     * Allows locale decimal separator to be a period or a comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     *\n     * @param {string} s\n     * @returns {string|void|XML|*}\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"outputFormat\" option definition for more details.\n     *\n     * @param {string|null} value\n     * @param {string} locale\n     * @returns {*}\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace(settings.negativeSignCharacter, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is formatted with decimals\n            s += '0.00';\n        }\n\n        return s;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character to use those defined in the settings.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace('-', settings.negativeSignCharacter);\n        }\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace('.', settings.decimalCharacter);\n        }\n\n        return s;\n    }\n\n    /**\n     * Private function to check for empty value\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @param {boolean} signOnEmpty\n     * @returns {*}\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\n     * Modify the input value by adding the group separators, as defined in the settings.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function addGroupSeparators(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n        }\n\n        if (settings.trailingNegative && !contains(inputValue, '-')) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isNegative = contains(inputValue, '-');\n        if (isNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n        var digitalGroup = void 0;\n        switch (settings.digitalGroupSpacing) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default:\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.digitGroupSeparator !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n            }\n        }\n\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.decimalPlacesOverride) {\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        if (settings.currencySymbolPlacement === 'p') {\n            if (isNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = settings.currencySymbol + inputValue;\n            }\n        }\n\n        if (settings.currencySymbolPlacement === 's') {\n            if (isNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n                        break;\n                    case 'l':\n                        inputValue = inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n                        break;\n                    case 'p':\n                        inputValue = settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.currencySymbol;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n            inputValue = toggleNegativeBracket(inputValue, settings);\n        }\n        settings.trailingNegative = false;\n\n        return inputValue + settings.suffixText;\n    }\n\n    /**\n     * Truncate not needed zeros\n     *\n     * @param {string} roundedInputValue\n     * @param {int} temporaryDecimalPlacesOverride\n     * @returns {void|XML|string|*}\n     */\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n        var regex = void 0;\n        switch (temporaryDecimalPlacesOverride) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (temporaryDecimalPlacesOverride === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\n     * Round the input value using the rounding method defined in the settings.\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\n     *\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function roundValue(inputValue, settings) {\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n            switch (settings.roundingMethod) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var temporaryDecimalPlacesOverride = void 0;\n\n        // sets the truncate zero method\n        if (settings.allowDecimalPadding) {\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n        } else {\n            temporaryDecimalPlacesOverride = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (inputValue.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n        var inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.decimalPlacesOverride) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < temporaryDecimalPlacesOverride) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.decimalCharacter;\n                }\n\n                var zeros = '000000';\n                while (cDec < temporaryDecimalPlacesOverride) {\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > temporaryDecimalPlacesOverride) {\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = void 0;\n        if (inputValueHasADot) {\n            rLength = settings.decimalPlacesOverride - 1;\n        } else {\n            rLength = settings.decimalPlacesOverride + dPos;\n        }\n\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.roundingMethod === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} isPaste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, isPaste) {\n        s = isPaste ? roundValue(s, settings) : s;\n\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n            var _s$split3 = s.split(settings.decimalCharacter),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n                if (settings.decimalPlacesOverride > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {number|string} n A numeric value.\n     * @returns {{}}\n     */\n    function parseStr(n) {\n        var x = {}; // A Big number instance.\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings.\n     * This uses the parsed strings for the above parseStr function.\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {object} y Big number instance\n     * @param {object} x Big number instance\n     * @returns {*}\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Check that the number satisfy the format conditions\n     * and lays between settings.minimumValue and settings.maximumValue\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function checkIfInRangeWithOverrideOption(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.minimumValue);\n        var maxParse = parseStr(settings.maximumValue);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.overrideMinMaxLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * Thanks to Anthony & Evan C\n     *\n     * @param {Element|string} element\n     * @returns {*|jQuery|HTMLElement}\n     */\n    function getCurrentElement(element) {\n        /*\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n         * for jQuery to be able to parse the selector correctly.\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n         */\n        if (isString(element)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(element);\n    }\n\n    /**\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     * @param {boolean} update\n     * @returns {*}\n     */\n    function getAutoNumericHolder($this, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $this.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $this.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (update || isUndefined(holder) && settings) {\n            holder = new AutoNumericHolder($this.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n     *\n     * @param {object} settings\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        //TODO Rename the old option names to the new ones\n        settings.oDec = settings.decimalPlacesOverride;\n        settings.oPad = settings.allowDecimalPadding;\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n        settings.oSep = settings.digitGroupSeparator;\n        settings.oSign = settings.currencySymbol;\n        settings.oSuffix = settings.suffixText;\n    }\n\n    /**\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\n     * This is taken from Quirksmode.\n     *\n     * @param {string} name\n     * @returns {*}\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported.\n     * This is taken from Modernizr.\n     *\n     * @returns {boolean}\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\n     *\n     * @param {Element|EventTarget} element\n     * @param {object} settings\n     * @param {string} action\n     * @returns {*}\n     */\n    function saveValueToPersistentStorage(element, settings, action) {\n        if (settings.saveValueToSessionStorage) {\n            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n            var date = void 0;\n            var expires = void 0;\n\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (action) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (action) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n\n    var AutoNumericHolder = function () {\n        /**\n         * Class constructor\n         *\n         * @param {HTMLElement} that - A reference to the current DOM element\n         * @param {object} settings\n         */\n        function AutoNumericHolder(that, settings) {\n            _classCallCheck(this, AutoNumericHolder);\n\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        /**\n         * Update the value and the selection values inside the AutoNumericHolder object.\n         * This keeps tracks of the input value, as well as the current selection.\n         * This also resets the 'processed' and 'formatted' state.\n         *\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\n         *        this function is called on each event handler.\n         *\n         * @private\n         */\n\n\n        _createClass(AutoNumericHolder, [{\n            key: '_updateAutoNumericHolderProperties',\n            value: function _updateAutoNumericHolderProperties() {\n                this.value = this.that.value;\n                this.selection = getElementSelection(this.that);\n                this.processed = false;\n                this.formatted = false;\n            }\n\n            /**\n             * Update the keycode of the key that triggered the given event.\n             * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\n             *\n             * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\n             * e.key describe the key name used to trigger the event.\n             * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\n                 * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n             * The key list is described here\n             * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n             *\n             * @param {Event} e\n             * @private\n             */\n\n        }, {\n            key: '_updateAutoNumericHolderEventKeycode',\n            value: function _updateAutoNumericHolderEventKeycode(e) {\n                // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n                this.eventKeyCode = keyCodeNumber(e);\n            }\n\n            /**\n             * Set the text selection inside the input with the given start and end position.\n             *\n             * @param {int} start\n             * @param {int} end\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_setSelection',\n            value: function _setSelection(start, end, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                start = Math.max(start, 0);\n                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n                this.selection = {\n                    start: start,\n                    end: end,\n                    length: end - start\n                };\n\n                if (isUndefined(setReal) || setReal) {\n                    setElementSelection(this.that, start, end);\n                }\n            }\n\n            /**\n             * Set the caret position inside the input at the given position.\n             *\n             * @param {int} pos\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_setCaretPosition',\n            value: function _setCaretPosition(pos, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                this._setSelection(pos, pos, setReal);\n            }\n\n            /**\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\n             * Those parts are left 'untouched', ie. formatted by autoNumeric.\n             *\n             * @returns {[string, string]} The parts on the left and right of the caret or selection\n             * @private\n             */\n\n        }, {\n            key: '_getLeftAndRightPartAroundTheSelection',\n            value: function _getLeftAndRightPartAroundTheSelection() {\n                var value = this.value;\n                var left = value.substring(0, this.selection.start);\n                var right = value.substring(this.selection.end, value.length);\n\n                return [left, right];\n            }\n\n            /**\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\n             * Those parts are unformatted (stripped) of any non-numbers characters.\n             *\n             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\n             * @private\n             */\n\n        }, {\n            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n                var settingsClone = this.settingsClone;\n\n                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n                    left = _getLeftAndRightPartA2[0],\n                    right = _getLeftAndRightPartA2[1];\n\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n\n\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n\n                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\n                if (settingsClone.trailingNegative && !contains(left, '-')) {\n                    left = '-' + left;\n                    right = right === '-' ? '' : right;\n                }\n\n                settingsClone.trailingNegative = false;\n\n                return [left, right];\n            }\n\n            /**\n             * Strip parts from excess characters and leading zeros.\n             *\n             * @param {string} left\n             * @param {string} right\n             * @returns {[*,*]}\n             * @private\n             */\n\n        }, {\n            key: '_normalizeParts',\n            value: function _normalizeParts(left, right) {\n                var settingsClone = this.settingsClone;\n\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\n                // If right is not empty and first character is not decimalCharacter\n                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\n                // Prevents multiple leading zeros from being entered\n                if (settingsClone.leadingZero === 'deny' && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n                    left = left.substring(0, left.length - 1);\n                }\n\n                if (settingsClone.trailingNegative && !contains(left, '-')) {\n                    left = '-' + left;\n                    settingsClone.trailingNegative = false;\n                }\n\n                // Insert zero if has leading dot\n                this.newValue = left + right;\n                if (settingsClone.decimalCharacter) {\n                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n                    if (m) {\n                        left = left.replace(m[1], m[1] + '0');\n                        this.newValue = left + right;\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\n             *\n             * @param {string} left\n             * @param {string} right\n             * @param {boolean} isPaste\n             * @returns {boolean}\n             * @private\n             */\n\n        }, {\n            key: '_setValueParts',\n            value: function _setValueParts(left, right) {\n                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                var settingsClone = this.settingsClone;\n                var parts = this._normalizeParts(left, right);\n\n                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n                    minTest = _checkIfInRangeWithOv2[0],\n                    maxTest = _checkIfInRangeWithOv2[1];\n\n                var position = parts[0].length;\n                this.newValue = parts.join('');\n\n                if (minTest && maxTest) {\n                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n                        settingsClone.rawValue = '';\n                    } else {\n                        settingsClone.rawValue = testValue;\n                    }\n\n                    if (position > this.newValue.length) {\n                        position = this.newValue.length;\n                    }\n\n                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                        if (parts[1] === '') {\n                            position = 1;\n                        } else {\n                            position = 0;\n                        }\n                    }\n\n                    this.value = this.newValue;\n                    this._setCaretPosition(position, false);\n\n                    return true;\n                }\n\n                if (!minTest) {\n                    this.$that.trigger('autoNumeric:minExceeded');\n                } else if (!maxTest) {\n                    this.$that.trigger('autoNumeric:maxExceeded');\n                }\n\n                return false;\n            }\n\n            /**\n             * Helper function for `_expandSelectionOnSign()`.\n             *\n             * @returns {*} Sign position of a formatted value\n             * @private\n             */\n\n        }, {\n            key: '_getSignPosition',\n            value: function _getSignPosition() {\n                var settingsClone = this.settingsClone;\n                var currencySymbol = settingsClone.currencySymbol;\n                var that = this.that;\n\n                if (currencySymbol) {\n                    var currencySymbolLen = currencySymbol.length;\n                    if (settingsClone.currencySymbolPlacement === 'p') {\n                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n                    }\n                    var valueLen = that.value.length;\n                    return [valueLen - currencySymbolLen, valueLen];\n                }\n\n                return [1000, -1];\n            }\n\n            /**\n             * Expands selection to cover whole sign\n             * Prevents partial deletion/copying/overwriting of a sign\n             *\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_expandSelectionOnSign',\n            value: function _expandSelectionOnSign(setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean only)\n                //TODO Use array destructuring here to set signPosition to more explicit variables\n                var signPosition = this._getSignPosition();\n                var selection = this.selection;\n\n                // If selection catches something except sign and catches only space from sign\n                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                    // Then select without empty space\n                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                        if (selection.start < signPosition[0]) {\n                            this._setSelection(selection.start, signPosition[0], setReal);\n                        } else {\n                            this._setSelection(signPosition[1], selection.end, setReal);\n                        }\n                    } else {\n                        // Else select with whole sign\n                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                    }\n                }\n            }\n\n            /**\n             * Try to strip pasted value to digits\n             */\n\n        }, {\n            key: '_checkPaste',\n            value: function _checkPaste() {\n                if (!isUndefined(this.valuePartsBeforePaste)) {\n                    var oldParts = this.valuePartsBeforePaste;\n\n                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n                        left = _getLeftAndRightPartA4[0],\n                        right = _getLeftAndRightPartA4[1];\n\n                    // Try to strip the pasted value first\n\n\n                    delete this.valuePartsBeforePaste;\n\n                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                        this.value = oldParts.join('');\n                        this._setCaretPosition(oldParts[0].length, false);\n                    }\n                }\n            }\n\n            /**\n             * Process pasting, cursor moving and skipping of not interesting keys.\n             * If this function returns TRUE, then further processing is not performed.\n             *\n             * @param {Event} e\n             * @returns {boolean}\n             * @private\n             */\n\n        }, {\n            key: '_skipAlways',\n            value: function _skipAlways(e) {\n                // Catch the ctrl up on ctrl-v\n                if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKeyCode === keyCode.Insert) {\n                    //TODO Move this test inside the `onKeyup` handler\n                    this._checkPaste();\n                    return false;\n                }\n\n                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n                if (this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12 || this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick || this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space ||\n                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n                this.eventKeyCode < keyCode.Backspace && (e.which === 0 || e.which === this.eventKeyCode) || this.eventKeyCode === keyCode.NumLock || this.eventKeyCode === keyCode.ScrollLock || this.eventKeyCode === keyCode.Insert || this.eventKeyCode === keyCode.Command) {\n                    return true;\n                }\n\n                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n                if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n                    if (this.settings.selectNumberOnly) {\n                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                        e.preventDefault();\n                        var valueLen = this.that.value.length;\n                        var currencySymbolLen = this.settings.currencySymbol.length;\n                        var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                        var suffixTextLen = this.settings.suffixText.length;\n                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n                        var start = void 0;\n                        if (currencySymbolPlacement === 's') {\n                            start = 0;\n                        } else {\n                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n                        }\n\n                        var end = void 0;\n                        if (currencySymbolPlacement === 'p') {\n                            end = valueLen - suffixTextLen;\n                        } else {\n                            switch (negativePositiveSignPlacement) {\n                                case 'l':\n                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n                                    break;\n                                case 'r':\n                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n                                    break;\n                                default:\n                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n                            }\n                        }\n\n                        setElementSelection(this.that, start, end);\n                    }\n\n                    return true;\n                }\n\n                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n                if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n                    if (e.type === 'keydown') {\n                        this._expandSelectionOnSign();\n                    }\n\n                    // Try to prevent wrong paste\n                    if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n                        if (e.type === 'keydown' || e.type === 'keypress') {\n                            if (isUndefined(this.valuePartsBeforePaste)) {\n                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                            }\n                        } else {\n                            this._checkPaste();\n                        }\n                    }\n\n                    return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n                }\n\n                if (e.ctrlKey || e.metaKey) {\n                    return true;\n                }\n\n                // Jump over thousand separator\n                //TODO Move this test inside the `onKeydown` handler\n                if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n                    if (e.type === 'keydown' && !e.shiftKey) {\n                        if (this.eventKeyCode === keyCode.LeftArrow && (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start - 1);\n                        } else if (this.eventKeyCode === keyCode.RightArrow && (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start + 1);\n                        }\n                    }\n                    return true;\n                }\n\n                return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n            }\n\n            /**\n             * Process deletion of characters when the minus sign is to the right of the numeric characters.\n             *\n             * @param {string} left The part on the left of the caret or selection\n             * @param {string} right The part on the right of the caret or selection\n             * @returns {[string, string]}\n             * @private\n             */\n\n        }, {\n            key: '_processCharacterDeletionIfTrailingNegativeSign',\n            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    left = _ref2[0],\n                    right = _ref2[1];\n\n                var settingsClone = this.settingsClone;\n                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.value.charAt(this.selection.start - 1) === '-') {\n                            left = left.substring(1);\n                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n                            right = right.substring(1, right.length);\n                        }\n                        if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        if (left[0] === '-') {\n                            right = right.substring(1);\n                        }\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n                            left = left.substring(0, left.length - 1);\n                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                        right = right.substring(1);\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Process the deletion of characters.\n             */\n\n        }, {\n            key: '_processCharacterDeletion',\n            value: function _processCharacterDeletion() {\n                var settingsClone = this.settingsClone;\n\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\n                    left = _getUnformattedLeftAn2[0];\n                    right = _getUnformattedLeftAn2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && contains(this.value, '-')) {\n                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]); //TODO Change `this.value` to `this.that.value`?\n\n\n                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\n                        left = _processCharacterDele2[0];\n                        right = _processCharacterDele2[1];\n                    } else {\n                        if (this.eventKeyCode === keyCode.Backspace) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                } else {\n                    this._expandSelectionOnSign(false);\n\n                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\n                    left = _getUnformattedLeftAn4[0];\n                    right = _getUnformattedLeftAn4[1];\n                }\n\n                this._setValueParts(left, right);\n            }\n\n            /**\n             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n             * Returns TRUE if the keycode is allowed.\n             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\n             *\n             * @param {Event} e\n             * @returns {boolean}\n             */\n\n        }, {\n            key: '_processCharacterInsertion',\n            value: function _processCharacterInsertion(e) {\n                var settingsClone = this.settingsClone;\n\n                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n                    left = _getUnformattedLeftAn6[0],\n                    right = _getUnformattedLeftAn6[1];\n\n                settingsClone.throwInput = true;\n\n                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n                // Do not allow decimal character if no decimal part allowed\n                if (e.key === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && e.key === settingsClone.decimalCharacterAlternative || (e.key === '.' || e.key === ',') && this.eventKeyCode === keyCode.DotNumpad) {\n                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character before negativeSignCharacter character\n                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character if other decimal character present\n                    if (contains(left, settingsClone.decimalCharacter)) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n                        right = right.substr(1);\n                    }\n\n                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent minus if not allowed\n                if ((e.key === '-' || e.key === '+') && settingsClone.negativeSignCharacter === '-') {\n                    if (!settingsClone) {\n                        return true;\n                    }\n\n                    // Caret is always after minus\n                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === '-' || contains(left, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = e.key === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    } else {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = e.key === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    }\n\n                    this._setValueParts(left, right);\n\n                    return true;\n                }\n\n                // If the user tries to insert digit before minus sign\n                var eventNumber = Number(e.key);\n                if (eventNumber >= 0 && eventNumber <= 9) {\n                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && e.key !== '0') {\n                        left = settingsClone.negativeSignCharacter + left;\n                    }\n\n                    this._setValueParts(left + e.key, right);\n\n                    return true;\n                }\n\n                // Prevent any other character\n                settingsClone.throwInput = false;\n\n                return false;\n            }\n\n            /**\n             * Formatting of just processed value while keeping the cursor position\n             *\n             * @param {Event} e\n             * @private\n             */\n\n        }, {\n            key: '_formatValue',\n            value: function _formatValue(e) {\n                var _this = this;\n\n                var settingsClone = this.settingsClone;\n                var leftLength = this.value;\n\n                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n                    left = _getUnformattedLeftAn8[0];\n\n                // No grouping separator and no currency sign\n\n\n                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                        subParts = _leftLength$split2[0];\n\n                    var nSign = '';\n                    if (contains(subParts, '-')) {\n                        nSign = '-';\n                        subParts = subParts.replace('-', '');\n                        left = left.replace('-', '');\n                    }\n\n                    // Strip leading zero on positive value if needed\n                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    // Strip leading zero on negative value if needed\n                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    left = nSign + left;\n                }\n\n                var value = addGroupSeparators(this.value, this.settingsClone);\n                var position = value.length;\n                if (value) {\n                    // Prepare regexp which searches for cursor position from unformatted left part\n                    var leftAr = left.split('');\n\n                    // Fixes caret position with trailing minus sign\n                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n                        leftAr.shift();\n\n                        if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) && settingsClone.caretFix) {\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                                (function () {\n                                    var signParts = settingsClone.currencySymbol.split('');\n                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                    var escapedParts = [];\n                                    $.each(signParts, function (i, miniParts) {\n                                        miniParts = signParts[i];\n                                        if (isInArray(miniParts, escapeChr)) {\n                                            escapedParts.push('\\\\' + miniParts);\n                                        } else {\n                                            escapedParts.push(miniParts);\n                                        }\n                                    });\n\n                                    if (_this.eventKeyCode === keyCode.Backspace) {\n                                        escapedParts.push('-');\n                                    }\n\n                                    // Pushing the escaped sign\n                                    leftAr.push(escapedParts.join(''));\n                                    settingsClone.caretFix = e.type === 'keydown';\n                                })();\n                            }\n                        }\n                    }\n\n                    for (var i = 0; i < leftAr.length; i++) {\n                        if (!leftAr[i].match('\\\\d')) {\n                            leftAr[i] = '\\\\' + leftAr[i];\n                        }\n                    }\n\n                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                    // Search cursor position in formatted value\n                    var newLeft = value.match(leftReg);\n                    if (newLeft) {\n                        position = newLeft[0].length;\n\n                        // If we are just before the sign which is in prefix position\n                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n                            // Place caret after prefix sign\n                            position = this.settingsClone.currencySymbol.length + (value.charAt(0) === '-' ? 1 : 0);\n                        }\n                    } else {\n                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n                            // If we could not find a place for cursor and have a sign as a suffix\n                            // Place caret before suffix currency sign\n                            position -= settingsClone.currencySymbol.length;\n                        }\n\n                        if (settingsClone.suffixText) {\n                            // If we could not find a place for cursor and have a suffix\n                            // Place caret before suffix\n                            position -= settingsClone.suffixText.length;\n                        }\n                    }\n                }\n\n                // Only update the value if it has changed. This prevents modifying the selection, if any.\n                if (value !== this.that.value || value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n                    this.that.value = value;\n                    this._setCaretPosition(position);\n                }\n\n                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n            }\n        }]);\n\n        return AutoNumericHolder;\n    }();\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @param {HTMLElement} that - A reference to the current DOM element\n     * @returns {*}\n     * @private\n     */\n\n\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = getCurrentElement(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = scIndex.indexOf(i);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = scIndex.indexOf(i);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusInAndMouseEnter($this, holder, e) {\n        var settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n            settings.onOff = true;\n\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                $this.val(toggleNegativeBracket(e.target.value, settings));\n            }\n\n            var result = void 0;\n            //TODO Do not repeat yourself with the `$this.autoNumeric('set', settings.rawValue);` line\n            if (settings.decimalPlacesShownOnFocus) {\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.scaleDivisor) {\n                settings.decimalPlacesOverride = settings.oDec;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.noSeparatorOnFocus) {\n                settings.digitGroupSeparator = '';\n                settings.currencySymbol = '';\n                settings.suffixText = '';\n                $this.autoNumeric('set', settings.rawValue);\n            } else if ((result = stripAllNonNumberCharacters(e.target.value, settings, true)) !== settings.rawValue) {\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n                $this.val(onEmpty);\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n                    setElementSelection(e.target, 0, 0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handler for 'keydown' events.\n     * The user just started pushing any key, hence one event is sent.\n     *\n     * Note :\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n     * - keydown\n     * - keypress\n     * - input\n     * - keyup\n     *\n     * ...when inputting a modifier key (ie. 'ctrl') :\n     * - keydown\n     * - keyup\n     *\n     * If 'delete' or 'backspace' is entered, the following events are sent :\n     * - keydown\n     * - input\n     * - keyup\n     *\n     * If 'enter' is entered and the value has not changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - keyup\n     *\n     * If 'enter' is entered and the value has been changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - change\n     * - keyup\n     *\n     * When a paste is done, the following events are sent :\n     * - input (if paste is done with the mouse)\n     *\n     * - keydown (if paste is done with ctrl+v)\n     * - keydown\n     * - input\n     * - keyup\n     * - keyup\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        holder._updateAutoNumericHolderEventKeycode(e);\n        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatValue(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\n     * Handler for 'keypress' events.\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeypress(holder, e) {\n        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n        if (e.key === keyName.Insert) {\n            return;\n        }\n\n        var processed = holder.processed;\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        var isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n        if (isCharacterInsertionAllowed) {\n            holder._formatValue(e);\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            } else {\n                // If the value has not changed, we do not allow the input event to be sent\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        e.preventDefault();\n\n        holder.formatted = false;\n    }\n\n    /**\n     * Handler for 'keyup' events.\n     * The user just released any key, hence one event is sent.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {object} settings\n     * @param {Event} e\n     */\n    function onKeyup(holder, settings, e) {\n        holder._updateAutoNumericHolderProperties(e);\n\n        var skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        if (skip || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.currencySymbol) {\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n            }\n        } else if (holder.eventKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n            saveValueToPersistentStorage(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatValue(e);\n        }\n\n        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n        if (e.target.value !== holder.initialValueOnKeydown) {\n            triggerEvent('autoNumeric:formatted', e.target);\n        }\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            var value = e.target.value;\n            var origValue = value;\n            var settings = holder.settingsClone;\n            settings.onOff = false;\n\n            if (settings.saveValueToSessionStorage) {\n                saveValueToPersistentStorage(e.target, settings, 'set');\n            }\n\n            if (settings.noSeparatorOnFocus === true) {\n                settings.digitGroupSeparator = settings.oSep;\n                settings.currencySymbol = settings.oSign;\n                settings.suffixText = settings.oSuffix;\n            }\n\n            if (settings.decimalPlacesShownOnFocus !== null) {\n                settings.decimalPlacesOverride = settings.oDec;\n                settings.allowDecimalPadding = settings.oPad;\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n            }\n\n            value = stripAllNonNumberCharacters(value, settings, true);\n\n            if (value !== '') {\n                if (settings.trailingNegative) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n                    minTest = _checkIfInRangeWithOv4[0],\n                    maxTest = _checkIfInRangeWithOv4[1];\n\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                    settings.rawValue = value;\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? +settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n                    value = roundValue(value, settings);\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.emptyInputBehavior === 'zero') {\n                    settings.rawValue = '0';\n                    value = roundValue('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = addGroupSeparators(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                $this.val(groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onPaste($this, holder, e) {\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        var rawPastedText = e.clipboardData.getData('text/plain');\n\n        // 0. Special case if the user has selected all the input text before pasting\n        var initialFormattedValue = e.target.value;\n        var selectionStart = e.target.selectionStart || 0;\n        var selectionEnd = e.target.selectionEnd || 0;\n        var selectionSize = selectionEnd - selectionStart;\n        var isAllInputTextSelected = false;\n\n        if (selectionSize === initialFormattedValue.length) {\n            isAllInputTextSelected = true;\n        }\n\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n        var isPasteNegative = isNegative(rawPastedText);\n        if (isPasteNegative) {\n            // 1a. Remove the negative sign from the pasted text\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n        }\n        var rawPastedTextSize = rawPastedText.length; // This use the 'cleaned' paste text\n\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n        var pastedText = preparePastedText(rawPastedText, holder);\n\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n        if (!isNumber(pastedText) || pastedText === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                //TODO Should we send a warning instead of throwing an error?\n                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n            }\n\n            return;\n        }\n\n        // 4. Calculate the paste result\n        var caretPositionOnInitialTextAfterPasting = void 0;\n        var initialUnformattedNumber = void 0;\n        if (e.target.value === '') {\n            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n            initialUnformattedNumber = '';\n        } else {\n            initialUnformattedNumber = $this.autoNumeric('get');\n        }\n        var isInitialValueNegative = isNegative(initialUnformattedNumber);\n        var isPasteNegativeAndInitialValueIsPositive = void 0;\n        var result = void 0;\n\n        // If the pasted content is negative, then the result will be negative too\n        if (isPasteNegative && !isInitialValueNegative) {\n            initialUnformattedNumber = '-' + initialUnformattedNumber;\n            isInitialValueNegative = true;\n            isPasteNegativeAndInitialValueIsPositive = true;\n        } else {\n            isPasteNegativeAndInitialValueIsPositive = false;\n        }\n\n        switch (holder.settings.onInvalidPaste) {\n            /* 4a. Truncate paste behavior:\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\n             * Otherwise paste all the numbers in the clipboard.\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\n             *\n             * 4b. Replace paste behavior:\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\n             */\n            /* eslint no-case-declarations: 0 */\n            case 'truncate':\n            case 'replace':\n                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                var leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                var rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                // -- Here, we are good to go to continue on the same basis\n\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                var minParse = parseStr(holder.settings.minimumValue);\n                var maxParse = parseStr(holder.settings.maximumValue);\n                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                var pastedTextIndex = 0;\n                var modifiedLeftPart = leftPart;\n\n                while (pastedTextIndex < pastedText.length) {\n                    // Modify the result with another pasted character\n                    modifiedLeftPart += pastedText[pastedTextIndex];\n                    result = modifiedLeftPart + rightPart;\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                //XXX Here we have the result for the `truncate` option\n                if (holder.settings.onInvalidPaste === 'truncate') {\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                    result = lastGoodKnownResult;\n                    break;\n                }\n                //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                //    If you do get to the range limits, use the previous known good value within those limits.\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                        lastGoodKnownResultIndex++;\n                        continue;\n                    }\n\n                    // This replace one character at a time\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                    lastGoodKnownResultIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                result = lastGoodKnownResult;\n\n                break;\n            /* 4c. Normal paste behavior:\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\n             */\n            case 'error':\n            case 'ignore':\n            case 'clamp':\n            default:\n                // Test if there is a selection in the input\n                if (selectionStart === selectionEnd) {\n                    // There is no selection, and this is the caret position : Insert the paste into the element.value at that caret position\n                    var indexWhereToInsertThePastedText = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                        indexWhereToInsertThePastedText++;\n                    }\n\n                    result = insertCharAtPosition(initialUnformattedNumber, pastedText, indexWhereToInsertThePastedText);\n\n                    caretPositionOnInitialTextAfterPasting = indexWhereToInsertThePastedText + rawPastedTextSize - countDotsInText(rawPastedText); // I must not count the characters that have been removed from the pasted text (ie. '.')\n                } else {\n                    // There is a selection : replace the selection with the paste content\n                    var firstPart = e.target.value.slice(0, selectionStart);\n                    var lastPart = e.target.value.slice(selectionEnd, e.target.value.length);\n                    result = firstPart + pastedText + lastPart;\n\n                    // Finally, remove any unwanted non-number characters\n                    if (firstPart !== '' || lastPart !== '') {\n                        // If the whole input has been selected prior to pasting, then firstPart and lastPart are empty, hence we only use the pastedText variable, otherwise we remove the potential decimal character in the result variable\n                        result = preparePastedText(result, holder);\n                    }\n\n                    // Add back the negative sign if needed\n                    if (isInitialValueNegative) {\n                        result = setRawNegativeSign(result);\n                    }\n\n                    if (isAllInputTextSelected) {\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                        caretPositionOnInitialTextAfterPasting = result.length;\n                    } else {\n                        // Normal case\n                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\n                        if (isPasteNegativeAndInitialValueIsPositive) {\n                            // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                            indexSelectionEndInRawValue++;\n                        }\n\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + rawPastedTextSize - countDotsInText(rawPastedText);\n                    }\n                }\n        }\n\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n        if (!isNumber(result) || result === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n                //TODO This is not DRY ; refactor with above\n            }\n            return;\n        }\n\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n        /*\n         * If 'error' (this is the default) :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, then throw an error in the console.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'ignore' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, do nothing more.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'clamp' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\n         *        paste result.\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\n         * If 'truncate' :\n         *      - Truncate paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         * If 'replace' :\n         *      - Replace paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n          *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         */\n        var valueHasBeenSet = false;\n        var valueHasBeenClamped = false;\n        try {\n            $this.autoNumeric('set', result);\n            valueHasBeenSet = true;\n        } catch (error) {\n            var clampedValue = void 0;\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    clampedValue = clampToRangeLimits(result, holder.settings);\n                    try {\n                        $this.autoNumeric('set', clampedValue);\n                    } catch (error) {\n                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n                    }\n\n                    valueHasBeenClamped = true;\n                    valueHasBeenSet = true;\n                    result = clampedValue; // This is used only for setting the caret position later\n                    break;\n                case 'error':\n                case 'truncate':\n                case 'replace':\n                    // Throw an error message\n                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n                // falls through\n                case 'ignore':\n                // Do nothing\n                // falls through\n                default:\n                    return; // ...and nothing else should be changed\n            }\n        }\n\n        // 7. Then lastly, set the caret position at the right logical place\n        var caretPositionInFormattedNumber = void 0;\n        if (valueHasBeenSet) {\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    if (valueHasBeenClamped) {\n                        if (holder.settings.currencySymbolPlacement === 's') {\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                        } else {\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n                        }\n\n                        break;\n                    } // else if the value has not been clamped, the default behavior is used...\n                // falls through\n                case 'error':\n                case 'ignore':\n                case 'truncate':\n                case 'replace':\n                default:\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\n            }\n        }\n\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n            triggerEvent('input', e.target);\n        }\n    }\n\n    /**\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onBlur(holder, e) {\n        if (e.target.value !== holder.valueOnFocus) {\n            triggerEvent('change', e.target);\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\n        }\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unformatOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\n     * Routine to format the default value on page load\n     *\n     * @param {object} settings\n     * @param {object} $input jQuery-selected <input> element\n     * @param {object} $this jQuery-selected DOM element\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `defaultValueOverride` altogether.\n             */\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                var testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                    $this.autoNumeric('set', testedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(currentValue.replace(',', '.'))) {\n                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n                    }\n\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                    if (!settings.saveValueToSessionStorage) {\n                        var toStrip = void 0;\n\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                            settings.onOff = true;\n                            toStrip = toggleNegativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        settings.rawValue = (settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && settings.negativeSignCharacter !== '' && contains(currentValue, '-') ? '-' + stripAllNonNumberCharacters(toStrip, settings, true) : stripAllNonNumberCharacters(toStrip, settings, true);\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.emptyInputBehavior) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.currencySymbol);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.defaultValueOverride !== null) {\n                if (settings.defaultValueOverride === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\n     *\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\n     *\n     * @param {object} options\n     * @param {object} settings\n     */\n    function correctPNegOption(options, settings) {\n        //TODO Merge the options and settings parameter to use only `settings`\n        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.negativePositiveSignPlacement) && options.currencySymbol !== '') {\n            switch (settings.currencySymbolPlacement) {\n                case 's':\n                    settings.negativePositiveSignPlacement = 'p';\n                    break;\n                case 'p':\n                    settings.negativePositiveSignPlacement = 'r';\n                    break;\n                default:\n                //\n            }\n        }\n    }\n\n    /**\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\n     *\n     * @param {object} settings\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n            maximumValueIntegerPart = _settings$maximumValu2[0];\n\n        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n            _ref4 = _slicedToArray(_ref3, 1),\n            minimumValueIntegerPart = _ref4[0];\n\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n    }\n\n    /**\n     * Modify `decimalPlacesOverride` as needed\n     *\n     * @param {object} settings\n     */\n    function correctMDecOption(settings) {\n        if (!isNull(settings.scaleDivisor) && !isNull(settings.scaleDecimalPlaces)) {\n            // Override the maximum number of decimal places with the one defined with the number of decimals to show when not in focus, if set\n            settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\n        } else if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n        settings.oDec = String(settings.decimalPlacesOverride);\n\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n    }\n\n    /**\n     * Sets the alternative decimal separator key.\n     *\n     * @param {object} settings\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n                settings.decimalCharacterAlternative = ',';\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n                settings.decimalCharacterAlternative = '.';\n            }\n        }\n    }\n\n    /**\n     * Caches regular expressions for stripAllNonNumberCharacters\n     *\n     * @param {object} settings\n     */\n    function cachesUsualRegularExpressions(settings) {\n        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.negativeSignCharacter ? '\\\\' + settings.negativeSignCharacter : '') + '\\\\' + settings.decimalCharacter + '\\\\d].*?(\\\\d|\\\\' + settings.decimalCharacter + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + '\\\\d]\\\\D*$');\n\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(\\\\d+\\\\' + settings.decimalCharacter + '\\\\d+)|(\\\\d*(?:\\\\' + settings.decimalCharacter + '\\\\d*)?))');\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(\\\\d)');\n    }\n\n    /**\n     * Modify the user settings to make them 'exploitable' later.\n     *\n     * @param {object} settings\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, function (key, value) {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\n     * Convert the old settings options name to new ones.\n     *\n     * @param {object} options\n     */\n    function convertOldOptionsToNewOnes(options) {\n        //TODO Delete this function once the old options are not used anymore\n        var oldOptionsConverter = {\n            // Old option name, with their corresponding new option\n            aSep: 'digitGroupSeparator',\n            nSep: 'noSeparatorOnFocus',\n            dGroup: 'digitalGroupSpacing',\n            aDec: 'decimalCharacter',\n            altDec: 'decimalCharacterAlternative',\n            aSign: 'currencySymbol',\n            pSign: 'currencySymbolPlacement',\n            pNeg: 'negativePositiveSignPlacement',\n            aSuffix: 'suffixText',\n            oLimits: 'overrideMinMaxLimits',\n            vMax: 'maximumValue',\n            vMin: 'minimumValue',\n            mDec: 'decimalPlacesOverride',\n            eDec: 'decimalPlacesShownOnFocus',\n            scaleDecimal: 'scaleDecimalPlaces',\n            aStor: 'saveValueToSessionStorage',\n            mRound: 'roundingMethod',\n            aPad: 'allowDecimalPadding',\n            nBracket: 'negativeBracketsTypeOnBlur',\n            wEmpty: 'emptyInputBehavior',\n            lZero: 'leadingZero',\n            aForm: 'formatOnPageLoad',\n            sNumber: 'selectNumberOnly',\n            anDefault: 'defaultValueOverride',\n            unSetOnSubmit: 'unformatOnSubmit',\n            outputType: 'outputFormat',\n            debug: 'showWarnings',\n            // Current options :\n            digitGroupSeparator: true,\n            noSeparatorOnFocus: true,\n            digitalGroupSpacing: true,\n            decimalCharacter: true,\n            decimalCharacterAlternative: true,\n            currencySymbol: true,\n            currencySymbolPlacement: true,\n            negativePositiveSignPlacement: true,\n            suffixText: true,\n            overrideMinMaxLimits: true,\n            maximumValue: true,\n            minimumValue: true,\n            decimalPlacesOverride: true,\n            decimalPlacesShownOnFocus: true,\n            scaleDivisor: true,\n            scaleDecimalPlaces: true,\n            scaleSymbol: true,\n            saveValueToSessionStorage: true,\n            onInvalidPaste: true,\n            roundingMethod: true,\n            allowDecimalPadding: true,\n            negativeBracketsTypeOnBlur: true,\n            emptyInputBehavior: true,\n            leadingZero: true,\n            formatOnPageLoad: true,\n            selectNumberOnly: true,\n            defaultValueOverride: true,\n            unformatOnSubmit: true,\n            outputFormat: true,\n            showWarnings: true,\n            failOnUnknownOption: true,\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n            onOff: true,\n            runOnce: true,\n            rawValue: true,\n            trailingNegative: true,\n            caretFix: true,\n            throwInput: true,\n            strip: true,\n            tagList: true,\n            negativeSignCharacter: true,\n            mIntPos: true,\n            mIntNeg: true,\n            oDec: true,\n            oPad: true,\n            oBracket: true,\n            oSep: true,\n            oSign: true,\n            oSuffix: true,\n            aNegRegAutoStrip: true,\n            skipFirstAutoStrip: true,\n            skipLastAutoStrip: true,\n            allowedAutoStrip: true,\n            numRegAutoStrip: true,\n            stripReg: true,\n            holder: true\n        };\n\n        for (var option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (oldOptionsConverter[option] === true) {\n                    // If the option is a 'new' option, we continue looping\n                    continue;\n                }\n\n                if (oldOptionsConverter.hasOwnProperty(option)) {\n                    // Else we have an 'old' option name\n                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\n                    // Then we modify the initial option object to use the new options instead of the old ones\n                    options[oldOptionsConverter[option]] = options[option];\n                    delete options[option];\n                } else if (options.failOnUnknownOption) {\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                }\n            }\n        }\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n     *\n     * @param {object} options\n     * @param {object} $this jQuery-selected DOM element\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If the user used old options, we convert them to new ones\n        if (update || !isNull(options)) {\n            convertOldOptionsToNewOnes(options);\n        }\n\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // If we couldn't grab any settings create them from the default ones and combine them with the options passed\n                // The settings are generated for the first time\n                // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    onOff: false,\n                    runOnce: false,\n                    rawValue: '',\n                    trailingNegative: false,\n                    caretFix: false,\n                    throwInput: true, // Throw input event\n                    strip: true,\n                    tagList: allowedTagList\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            correctPNegOption(options, settings);\n\n            // Set the negative sign if needed\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctMDecOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\n         *\n         * @param {object} options\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                var holder = getAutoNumericHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.formatOnPageLoad) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    this.addEventListener('focusin', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseenter', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('focusout', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseleave', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('keydown', function (e) {\n                        onKeydown(holder, e);\n                    }, false);\n                    this.addEventListener('keypress', function (e) {\n                        onKeypress(holder, e);\n                    }, false);\n                    this.addEventListener('keyup', function (e) {\n                        onKeyup(holder, settings, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onBlur(holder, e);\n                    }, false);\n                    this.addEventListener('paste', function (e) {\n                        onPaste($this, holder, e);\n                    }, false);\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n                }\n            });\n        },\n\n\n        /**\n         * Method to stop and remove autoNumeric for the current element.\n         * Note: this does not remove the formatting.\n         *\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\n         *\n         * @returns {*|jQuery}\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\n         *\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\n         *\n         * @returns {*|jQuery}\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings.\n         * It can be called multiple times if needed.\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '}).\n         *\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\n         *\n         * @param {object} options\n         * @returns {*|jQuery}\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var strip = $this.autoNumeric('get');\n                var settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getAutoNumericHolder($this, settings, true);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         *\n         * @example $(someSelector).autoNumeric('set', 'value'); // Formats the value being passed as the second parameter\n         *\n         * @param {*} newValue\n         * @returns {*|jQuery}\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = newValue.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method');\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!isNumber(Number(value))) {\n                    warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n                        minTest = _checkIfInRangeWithOv6[0],\n                        maxTest = _checkIfInRangeWithOv6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.decimalPlacesOverride = settings.scaleDecimalPlaces ? settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n                            }\n\n                            value = roundValue(value, settings);\n                            if (settings.decimalPlacesShownOnFocus === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                            value = addGroupSeparators(value, settings);\n                        }\n\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            saveValueToPersistentStorage($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * Method to un-format inputs.\n         * This is handy to use right before form submission.\n         *\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\n         * Please see option \"outputFormat\" for more details\n         *\n         * @example $(someSelector).autoNumeric('unSet');\n         *\n         * @returns {*|jQuery}\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\n         * Method to re-format inputs.\n         * This is handy to use right after form submission.\n         *\n         * This is called after the 'unSet' method to reformat the input\n         *\n         * @example $(someSelector).autoNumeric('reSet');\n         *\n         * @returns {*|jQuery}\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage $(someSelector).autoNumeric('get');\n         *\n         * @returns {string}\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = getCurrentElement(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.emptyInputBehavior === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n                    settings.onOff = true;\n                    value = toggleNegativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\n                    value = stripAllNonNumberCharacters(value, settings, true);\n                }\n\n                value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n            }\n\n            // Always return a numeric string\n            return value;\n        },\n\n\n        /**\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputFormat\" option definition for more details.\n         *\n         * @returns {*}\n         */\n        getLocalized: function getLocalized() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputFormat);\n        },\n\n\n        /**\n         * Return the input unformatted value as a number.\n         *\n         * @returns {number}\n         */\n        getNumber: function getNumber() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n\n            return toLocale(value, 'number');\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {string}\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {{}|[]}\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\n         *\n         * @example\n         * $(someSelector).autoNumeric('getSettings');\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\n         *\n         * @returns {object}\n         */\n        getSettings: function getSettings() {\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n            return this.data('autoNumeric');\n        }\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     *\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\n     * @param {*} args\n     * @returns {*}\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @returns {object}\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * Public function that allows formatting without an element trigger.\n     *\n     * @param {number} value\n     * @param {object} options\n     * @returns {*}\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Check the validity of the `value` parameter\n        if (!isNumber(value)) {\n            throwError('A number is needed to be able to format it, [' + value + '] given.');\n        }\n\n        // Initiate a very basic settings object\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        if (value < 0) {\n            settings.negativeSignCharacter = '-';\n        }\n        var valueString = value.toString();\n        valueString = fromLocale(valueString);\n\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n\n        // Basic tests to check if the given valueString is valid\n\n        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n            minTest = _checkIfInRangeWithOv8[0],\n            maxTest = _checkIfInRangeWithOv8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        valueString = roundValue(valueString, settings);\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n        valueString = addGroupSeparators(valueString, settings);\n\n        return valueString;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\n     * Public function that allows unformatting without an element.\n     *\n     * @param {string|number} value\n     * @param {object} options\n     * @returns {*}\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) {\n            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.negativeSignCharacter = '-';\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n            settings.negativeSignCharacter = '-';\n            settings.onOff = true;\n            value = toggleNegativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        value = toLocale(value, settings.outputFormat);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // If the user used old options, we convert them to new ones\n        if (!isNull(userOptions)) {\n            convertOldOptionsToNewOnes(userOptions);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        // First things first, we test that the `showWarnings` option is valid\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n        }\n\n        // Define the regular expressions needed for the following tests\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.digitGroupSeparator, [',', '.', ' ', '', \"'\"])) {\n            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\', \"\\'\" or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n        }\n\n        if (!isInArray(options.decimalCharacter, [',', '.'])) {\n            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.decimalCharacter + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.decimalCharacter === options.digitGroupSeparator) {\n            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n        }\n\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n        }\n\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n        }\n\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n        }\n\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.negativePositiveSignPlacement + '] given.');\n        }\n\n        if (!isString(options.suffixText) || options.suffixText !== '' && (contains(options.suffixText, '-') || testNumericalCharacters.test(options.suffixText))) {\n            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n        }\n\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n        }\n\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n        }\n\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n        }\n\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n        }\n\n        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n        ) {\n                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n            }\n\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n        }\n\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n        }\n\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n        }\n\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n        }\n\n        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n        }\n\n        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n        }\n\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n        }\n\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n        }\n\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n        }\n\n        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n        }\n    };\n\n    $.fn.autoValidate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event and immediately sent it from the given element.\n     * By default, if no element is given, the event is thrown from `document`.\n     *\n     * @param {string} eventName\n     * @param {Element} element\n     * @param {object} detail\n     */\n    function triggerEvent(eventName) {\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var event = void 0;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail: detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImFsbG93ZWRUYWdMaXN0IiwiZGVmYXVsdFNldHRpbmdzIiwiZGlnaXRHcm91cFNlcGFyYXRvciIsIm5vU2VwYXJhdG9yT25Gb2N1cyIsImRpZ2l0YWxHcm91cFNwYWNpbmciLCJkZWNpbWFsQ2hhcmFjdGVyIiwiZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlIiwiY3VycmVuY3lTeW1ib2wiLCJjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCIsIm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Iiwic3VmZml4VGV4dCIsIm92ZXJyaWRlTWluTWF4TGltaXRzIiwibWF4aW11bVZhbHVlIiwibWluaW11bVZhbHVlIiwiZGVjaW1hbFBsYWNlc092ZXJyaWRlIiwiZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyIsInNjYWxlRGl2aXNvciIsInNjYWxlRGVjaW1hbFBsYWNlcyIsInNjYWxlU3ltYm9sIiwic2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSIsIm9uSW52YWxpZFBhc3RlIiwicm91bmRpbmdNZXRob2QiLCJhbGxvd0RlY2ltYWxQYWRkaW5nIiwibmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIiLCJlbXB0eUlucHV0QmVoYXZpb3IiLCJsZWFkaW5nWmVybyIsImZvcm1hdE9uUGFnZUxvYWQiLCJzZWxlY3ROdW1iZXJPbmx5IiwiZGVmYXVsdFZhbHVlT3ZlcnJpZGUiLCJ1bmZvcm1hdE9uU3VibWl0Iiwib3V0cHV0Rm9ybWF0Iiwic2hvd1dhcm5pbmdzIiwiZmFpbE9uVW5rbm93bk9wdGlvbiIsImtleUNvZGUiLCJCYWNrc3BhY2UiLCJUYWIiLCJFbnRlciIsIlNoaWZ0IiwiQ3RybCIsIkFsdCIsIlBhdXNlQnJlYWsiLCJDYXBzTG9jayIsIkVzYyIsIlNwYWNlIiwiUGFnZVVwIiwiUGFnZURvd24iLCJFbmQiLCJIb21lIiwiTGVmdEFycm93IiwiVXBBcnJvdyIsIlJpZ2h0QXJyb3ciLCJEb3duQXJyb3ciLCJJbnNlcnQiLCJEZWxldGUiLCJudW0wIiwibnVtMSIsIm51bTIiLCJudW0zIiwibnVtNCIsIm51bTUiLCJudW02IiwibnVtNyIsIm51bTgiLCJudW05IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJXaW5kb3dzIiwiUmlnaHRDbGljayIsIm51bXBhZDAiLCJudW1wYWQxIiwibnVtcGFkMiIsIm51bXBhZDMiLCJudW1wYWQ0IiwibnVtcGFkNSIsIm51bXBhZDYiLCJudW1wYWQ3IiwibnVtcGFkOCIsIm51bXBhZDkiLCJNdWx0aXBseU51bXBhZCIsIlBsdXNOdW1wYWQiLCJNaW51c051bXBhZCIsIkRvdE51bXBhZCIsIlNsYXNoTnVtcGFkIiwiRjEiLCJGMiIsIkYzIiwiRjQiLCJGNSIsIkY2IiwiRjciLCJGOCIsIkY5IiwiRjEwIiwiRjExIiwiRjEyIiwiTnVtTG9jayIsIlNjcm9sbExvY2siLCJNeUNvbXB1dGVyIiwiTXlDYWxjdWxhdG9yIiwiU2VtaWNvbG9uIiwiRXF1YWwiLCJDb21tYSIsIkh5cGhlbiIsIkRvdCIsIlNsYXNoIiwiQmFja3F1b3RlIiwiTGVmdEJyYWNrZXQiLCJCYWNrc2xhc2giLCJSaWdodEJyYWNrZXQiLCJRdW90ZSIsIkNvbW1hbmQiLCJrZXlOYW1lIiwiVW5pZGVudGlmaWVkIiwiQWx0R3IiLCJGbiIsIkZuTG9jayIsIkh5cGVyIiwiTWV0YSIsIlN1cGVyIiwiU3ltYm9sIiwiU3ltYm9sTG9jayIsIkNsZWFyIiwiQ29weSIsIkNyU2VsIiwiQ3V0IiwiRXJhc2VFb2YiLCJFeFNlbCIsIlBhc3RlIiwiUmVkbyIsIlVuZG8iLCJBY2NlcHQiLCJBZ2FpbiIsIkF0dG4iLCJDYW5jZWwiLCJDb250ZXh0TWVudSIsIkV4ZWN1dGUiLCJGaW5kIiwiRmluaXNoIiwiSGVscCIsIlBhdXNlIiwiUGxheSIsIlByb3BzIiwiU2VsZWN0IiwiWm9vbUluIiwiWm9vbU91dCIsIkJyaWdodG5lc3NEb3duIiwiQnJpZ2h0bmVzc1VwIiwiRWplY3QiLCJMb2dPZmYiLCJQb3dlciIsIlBvd2VyT2ZmIiwiUHJpbnRTY3JlZW4iLCJIaWJlcm5hdGUiLCJTdGFuZGJ5IiwiV2FrZVVwIiwiQ29tcG9zZSIsIkRlYWQiLCJQcmludCIsIk1pbnVzIiwiUGx1cyIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImlzTnVsbCIsInZhbHVlIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkiLCJpc1N0cmluZyIsInN0ciIsIlN0cmluZyIsImlzQm9vbGVhbiIsImlzVHJ1ZU9yRmFsc2VTdHJpbmciLCJsb3dlcmNhc2VWYWx1ZSIsInRvTG93ZXJDYXNlIiwiaXNPYmplY3QiLCJyZWZlcmVuY2UiLCJBcnJheSIsImlzQXJyYXkiLCJpc0VtcHR5T2JqIiwib2JqIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiaXNOdW1iZXIiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsImlzSW50IiwicGFyc2VJbnQiLCJwcmVwYXJlUGFzdGVkVGV4dCIsInRleHQiLCJob2xkZXIiLCJzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMiLCJzZXR0aW5nc0Nsb25lIiwicmVwbGFjZSIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJkZWNpbWFsUGxhY2VzIiwic3BsaXQiLCJkZWNpbWFsUGFydCIsImxlbmd0aCIsImtleUNvZGVOdW1iZXIiLCJldmVudCIsIndoaWNoIiwiY2hlY2tJZkluUmFuZ2UiLCJwYXJzZWRNaW5WYWx1ZSIsInBhcnNlZE1heFZhbHVlIiwicGFyc2VkVmFsdWUiLCJwYXJzZVN0ciIsInRlc3RNaW5NYXgiLCJpc05lZ2F0aXZlIiwic3RyaW5nIiwiY2hhckF0Iiwic2V0UmF3TmVnYXRpdmVTaWduIiwiaW5zZXJ0Q2hhckF0UG9zaXRpb24iLCJjaGFyIiwiY2FyZXRQb3NpdGlvbiIsInNsaWNlIiwicmVwbGFjZUNoYXJBdCIsImluZGV4IiwibmV3Q2hhcmFjdGVyIiwic3Vic3RyIiwiY2xhbXBUb1JhbmdlTGltaXRzIiwic2V0dGluZ3MiLCJNYXRoIiwibWF4IiwibWluIiwiY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlIiwiZm9ybWF0dGVkTnVtYmVyU3RyaW5nIiwibnVtYmVyRG90T3JOZWdhdGl2ZVNpZ24iLCJSZWdFeHAiLCJudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCIsInRlc3QiLCJmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyIiwicmF3TnVtYmVyU3RyaW5nIiwiY2FyZXRQb3NpdGlvbkluUmF3VmFsdWUiLCJmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplIiwicmF3TnVtYmVyU3RyaW5nU2l6ZSIsImZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4IiwicmF3TnVtYmVyU3RyaW5nSW5kZXgiLCJjb3VudERvdHNJblRleHQiLCJjb3VudENoYXJJblRleHQiLCJjaGFyYWN0ZXIiLCJjaGFyQ291bnRlciIsImNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbiIsImNoYXJhY3RlckNvdW50IiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwibW92ZVN0YXJ0IiwiZW5kIiwic3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJzZXRFbGVtZW50U2VsZWN0aW9uIiwicmFuZ2UiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsIndhcm5pbmciLCJzaG93V2FybmluZyIsImNvbnNvbGUiLCJ3YXJuIiwicnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0IiwiJHRoaXMiLCIkIiwiZWFjaCIsInZhbCIsImF1dG9OdW1lcmljIiwibWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aCIsImxlZnRPckFsbCIsInNraXBGaXJzdEF1dG9TdHJpcCIsInRyYWlsaW5nTmVnYXRpdmUiLCJza2lwTGFzdEF1dG9TdHJpcCIsImFsbG93ZWRBdXRvU3RyaXAiLCJtYXRjaCIsIm51bVJlZ0F1dG9TdHJpcCIsImpvaW4iLCJuU2lnbiIsImludGVnZXJQYXJ0IiwibW9kaWZpZWRJbnRlZ2VyUGFydCIsIm5lZ2F0aXZlU2lnbkNoYXJhY3RlciIsIm1JbnRQb3MiLCJtSW50TmVnIiwib25PZmYiLCJzdHJpcFJlZyIsInRvZ2dsZU5lZ2F0aXZlQnJhY2tldCIsImZpcnN0QnJhY2tldCIsImxhc3RCcmFja2V0IiwiZnJvbUxvY2FsZSIsImxhc3RJbmRleE9mIiwidG9Mb2NhbGUiLCJsb2NhbGUiLCJyZXN1bHQiLCJOdW1iZXIiLCJtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUiLCJtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUiLCJjaGVja0VtcHR5IiwiaW5wdXRWYWx1ZSIsInNpZ25PbkVtcHR5IiwiYWRkR3JvdXBTZXBhcmF0b3JzIiwic3RyaXAiLCJlbXB0eSIsImRpZ2l0YWxHcm91cCIsInN1YnN0cmluZyIsInJhd1ZhbHVlIiwidHJ1bmNhdGVaZXJvcyIsInJvdW5kZWRJbnB1dFZhbHVlIiwidGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlIiwicmVnZXgiLCJyb3VuZFZhbHVlIiwicm91bmQiLCJjZWlsIiwiZmxvb3IiLCJpdlJvdW5kZWQiLCJkUG9zIiwiaW5wdXRWYWx1ZUhhc0FEb3QiLCJ2ZFBvcyIsImNEZWMiLCJ6ZXJvcyIsInJMZW5ndGgiLCJ0Um91bmQiLCJvZGQiLCJpdkFycmF5IiwidHJ1bmNhdGVEZWNpbWFsIiwiaXNQYXN0ZSIsIm1vZGlmaWVkRGVjaW1hbFBhcnQiLCJuTCIsInNlYXJjaCIsInhjIiwieWMiLCJ4TmVnIiwiY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24iLCJtaW5QYXJzZSIsIm1heFBhcnNlIiwidmFsUGFyc2UiLCJnZXRDdXJyZW50RWxlbWVudCIsImVsZW1lbnQiLCJnZXRBdXRvTnVtZXJpY0hvbGRlciIsInVwZGF0ZSIsImRhdGEiLCJBdXRvTnVtZXJpY0hvbGRlciIsImdldCIsImtlZXBBbk9yaWdpbmFsU2V0dGluZ3NDb3B5Iiwib0RlYyIsIm9QYWQiLCJvQnJhY2tldCIsIm9TZXAiLCJvU2lnbiIsIm9TdWZmaXgiLCJyZWFkQ29va2llIiwibmFtZSIsIm5hbWVFUSIsImNhIiwiY29va2llIiwic3RvcmFnZVRlc3QiLCJtb2QiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwic2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSIsImFjdGlvbiIsInN0b3JlZE5hbWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZCIsImRhdGUiLCJleHBpcmVzIiwiRGF0ZSIsInNldFRpbWUiLCJnZXRUaW1lIiwidG9VVENTdHJpbmciLCJnZXRJdGVtIiwiJHRoYXQiLCJmb3JtYXR0ZWQiLCJwcm9jZXNzZWQiLCJldmVudEtleUNvZGUiLCJzZXRSZWFsIiwicG9zIiwiX3NldFNlbGVjdGlvbiIsImxlZnQiLCJyaWdodCIsIl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uIiwic3RyaXBaZXJvcyIsIm5ld1ZhbHVlIiwiYU5lZ1JlZ0F1dG9TdHJpcCIsInBhcnRzIiwiX25vcm1hbGl6ZVBhcnRzIiwibWluVGVzdCIsIm1heFRlc3QiLCJ0ZXN0VmFsdWUiLCJfc2V0Q2FyZXRQb3NpdGlvbiIsInRyaWdnZXIiLCJjdXJyZW5jeVN5bWJvbExlbiIsImhhc05lZyIsInZhbHVlTGVuIiwic2lnblBvc2l0aW9uIiwiX2dldFNpZ25Qb3NpdGlvbiIsInZhbHVlUGFydHNCZWZvcmVQYXN0ZSIsIm9sZFBhcnRzIiwibW9kaWZpZWRMZWZ0UGFydCIsIl9zZXRWYWx1ZVBhcnRzIiwiY3RybEtleSIsIm1ldGFLZXkiLCJ0eXBlIiwic2hpZnRLZXkiLCJfY2hlY2tQYXN0ZSIsInByZXZlbnREZWZhdWx0IiwibmVnTGVuIiwic3VmZml4VGV4dExlbiIsIl9leHBhbmRTZWxlY3Rpb25PblNpZ24iLCJjYXJldEZpeCIsIl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24iLCJ0aHJvd0lucHV0IiwiX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24iLCJrZXkiLCJldmVudE51bWJlciIsImxlZnRMZW5ndGgiLCJzdWJQYXJ0cyIsImxlZnRBciIsInNoaWZ0IiwicHVzaCIsInNpZ25QYXJ0cyIsImVzY2FwZUNociIsImVzY2FwZWRQYXJ0cyIsIm1pbmlQYXJ0cyIsImxlZnRSZWciLCJuZXdMZWZ0IiwiX2dldFN0cmluZ09yQXJyYXkiLCJnZXRBcnJheUJlaGF2aW9yIiwiZm9ybUluZGV4IiwiYWxsRm9ybUVsZW1lbnRzIiwiYWlJbmRleCIsInNjSW5kZXgiLCJyU3VibWl0dGVyVHlwZXMiLCJyU3VibWl0dGFibGUiLCJyQ2hlY2thYmxlVHlwZSIsInJOb25BdXRvTnVtZXJpY1R5cGVzIiwiY291bnQiLCJmaWVsZCIsImxvY2FsTmFtZSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImZvcm1GaWVsZHMiLCJzZXJpYWxpemVBcnJheSIsInNjRWxlbWVudCIsInRlc3RJbnB1dCIsInNlcmlhbGl6ZSIsImZvcm1QYXJ0cyIsImlucHV0TmFtZSIsIm1vZGlmaWVkSW5wdXRWYWx1ZSIsIm9uRm9jdXNJbkFuZE1vdXNlRW50ZXIiLCJpcyIsInRhcmdldCIsInZhbHVlT25Gb2N1cyIsImxhc3RWYWwiLCJvbkVtcHR5Iiwib25LZXlkb3duIiwiX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyRXZlbnRLZXljb2RlIiwiaW5pdGlhbFZhbHVlT25LZXlkb3duIiwicmVhZE9ubHkiLCJ0cmlnZ2VyRXZlbnQiLCJfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzIiwiX3NraXBBbHdheXMiLCJfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uIiwiX2Zvcm1hdFZhbHVlIiwib25LZXlwcmVzcyIsImlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCIsIl9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uIiwib25LZXl1cCIsInNraXAiLCJvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSIsIm9yaWdWYWx1ZSIsImdyb3VwZWRWYWx1ZSIsImNoYW5nZSIsIm9uUGFzdGUiLCJyYXdQYXN0ZWRUZXh0IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJpbml0aWFsRm9ybWF0dGVkVmFsdWUiLCJzZWxlY3Rpb25TaXplIiwiaXNBbGxJbnB1dFRleHRTZWxlY3RlZCIsImlzUGFzdGVOZWdhdGl2ZSIsInJhd1Bhc3RlZFRleHRTaXplIiwicGFzdGVkVGV4dCIsImNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nIiwiaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyIiwiaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSIsImlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUiLCJsZWZ0Rm9ybWF0dGVkUGFydCIsInJpZ2h0Rm9ybWF0dGVkUGFydCIsImxlZnRQYXJ0IiwicmlnaHRQYXJ0IiwibGFzdEdvb2RLbm93blJlc3VsdCIsInBhc3RlZFRleHRJbmRleCIsImxhc3RHb29kS25vd25SZXN1bHRJbmRleCIsImxhc3RHb29kS25vd25SZXN1bHRTaXplIiwiaW5kZXhXaGVyZVRvSW5zZXJ0VGhlUGFzdGVkVGV4dCIsImZpcnN0UGFydCIsImxhc3RQYXJ0IiwiaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlIiwic2VsZWN0ZWRUZXh0IiwidmFsdWVIYXNCZWVuU2V0IiwidmFsdWVIYXNCZWVuQ2xhbXBlZCIsImVycm9yIiwiY2xhbXBlZFZhbHVlIiwiY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyIiwib25CbHVyIiwib25TdWJtaXQiLCJjbG9zZXN0Iiwib24iLCIkc2V0dGluZ3MiLCJnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSIsIiRpbnB1dCIsImN1cnJlbnRFbGVtZW50VGFnIiwiZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZCIsInNldFZhbHVlIiwiY3VycmVudFZhbHVlIiwiYXR0ciIsInRlc3RlZEN1cnJlbnRWYWx1ZSIsIkluZmluaXR5IiwidG9TdHJpcCIsInRhZ0xpc3QiLCJjb3JyZWN0UE5lZ09wdGlvbiIsIm9wdGlvbnMiLCJjYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcyIsIm1heGltdW1WYWx1ZUludGVnZXJQYXJ0IiwibWluaW11bVZhbHVlSW50ZWdlclBhcnQiLCJjb3JyZWN0TURlY09wdGlvbiIsInNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIiLCJjYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyIsImFOZWdSZWciLCJhbGxvd2VkIiwidHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzIiwiY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMiLCJvbGRPcHRpb25zQ29udmVydGVyIiwiYVNlcCIsIm5TZXAiLCJkR3JvdXAiLCJhRGVjIiwiYWx0RGVjIiwiYVNpZ24iLCJwU2lnbiIsInBOZWciLCJhU3VmZml4Iiwib0xpbWl0cyIsInZNYXgiLCJ2TWluIiwibURlYyIsImVEZWMiLCJzY2FsZURlY2ltYWwiLCJhU3RvciIsIm1Sb3VuZCIsImFQYWQiLCJuQnJhY2tldCIsIndFbXB0eSIsImxaZXJvIiwiYUZvcm0iLCJzTnVtYmVyIiwiYW5EZWZhdWx0IiwidW5TZXRPblN1Ym1pdCIsIm91dHB1dFR5cGUiLCJkZWJ1ZyIsInJ1bk9uY2UiLCJvcHRpb24iLCJnZXRJbml0aWFsU2V0dGluZ3MiLCJleHRlbmQiLCJ0YWdEYXRhIiwibWV0aG9kcyIsImluaXQiLCJhZGRFdmVudExpc3RlbmVyIiwiZGVzdHJveSIsInJlbW92ZURhdGEiLCJvZmYiLCJ3aXBlIiwic2V0IiwiYXR0ZW1wdGVkVmFsdWUiLCJ1blNldCIsInJlU2V0IiwiZXEiLCJnZXRMb2NhbGl6ZWQiLCJnZXROdW1iZXIiLCJnZXRGb3JtYXR0ZWQiLCJnZXRTdHJpbmciLCJnZXRBcnJheSIsImdldFNldHRpbmdzIiwiZm4iLCJtZXRob2QiLCJhcmdzIiwiYXBwbHkiLCJkZWZhdWx0cyIsInZhbHVlU3RyaW5nIiwiYXV0b1N0cmlwIiwiYXV0b1VuZm9ybWF0IiwidXNlck9wdGlvbnMiLCJzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJ2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzIiwiYXV0b1ZhbGlkYXRlIiwiaXNWYWxpZCIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJwYXJhbXMiLCJldnQiLCJFdmVudCIsImZvcm1hdCIsInVuRm9ybWF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0RBOztBQUVBO0FBQ0EsSUFBSUEsbUJBQUo7QUFDQSxJQUFJ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WWxhLFNBQVosR0FBd0J4QyxPQUFPa2QsS0FBUCxDQUFhMWEsU0FBckM7QUFDQXhDLGVBQU8wYyxXQUFQLEdBQXFCQSxXQUFyQjtBQUNILEtBZEQ7QUFlSCxDQTNpSUEsQ0FBRDs7QUE2aUlBOzs7a0JBR2U7QUFDWFMsWUFBVXJwQixVQURDO0FBRVhzcEIsY0FBVXJwQixZQUZDO0FBR1hDLHNDQUhXO0FBSVhDLHNCQUpXLEVBSUQ7QUFDVkMsc0NBTFcsRSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgICAgICAgICAgICAgIGF1dG9OdW1lcmljLmpzXG4gKlxuICogQHZlcnNpb24gICAgICAyLjAtYmV0YS4xNVxuICogQGRhdGUgICAgICAgICAyMDE2LTEyLTI3IFVUQyAxNDowMFxuICpcbiAqIEBhdXRob3IgICAgICAgQm9iIEtub3RoZVxuICogQGNvbnRyaWJ1dG9ycyBBbGV4YW5kcmUgQm9ubmVhdSwgU29rb2xvdiBZdXJhIGFuZCBvdGhlciBHaXRodWIgdXNlcnMsXG4gKiAgICAgICAgICAgICAgIGNmLiBBVVRIT1JTLm1kLlxuICogQGNvcHlyaWdodCAgICAyMDA5IFJvYmVydCBKLiBLbm90aGUgaHR0cDovL3d3dy5kZWNvcnBsYW5pdC5jb20vcGx1Z2luL1xuICogQHNpbmNlICAgICAgICAyMDA5LTA4LTA5XG4gKlxuICogQHN1bW1hcnkgICAgICBhdXRvTnVtZXJpYyBpcyBhIGpRdWVyeSBwbHVnaW4gdGhhdCBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgY3VycmVuY3lcbiAqIChtb25leSkgYW5kIG51bWJlcnMgYXMteW91LXR5cGUgaW4gYSBmb3JtIGlucHV0cy4gSXQgc3VwcG9ydHMgbW9zdFxuICogaW50ZXJuYXRpb25hbCBudW1lcmljIGZvcm1hdHMgYW5kIGN1cnJlbmN5IHNpZ25zIGluY2x1ZGluZyB0aG9zZSB1c2VkIGluXG4gKiBFdXJvcGUsIE5vcnRoIGFuZCBTb3V0aCBBbWVyaWNhLCBBc2lhLCBhcyB3ZWxsIGFzIEluZGlhJ3MnIGxha2hzLlxuICpcbiAqICAgICAgICAgICAgICAgTm90ZSA6IFNvbWUgZnVuY3Rpb25zIGFyZSBib3Jyb3dlZCBmcm9tIGJpZy5qc1xuICogQGxpbmsgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gKlxuICogUGxlYXNlIHJlcG9ydCBhbnkgYnVncyB0byBodHRwczovL2dpdGh1Yi5jb20vQm9iS25vdGhlL2F1dG9OdW1lcmljXG4gKlxuICogQGxpY2Vuc2UgICAgICBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIEBsaW5rICAgICAgICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5cbi8qIGdsb2JhbCBtb2R1bGUsIHJlcXVpcmUsIGRlZmluZSAqL1xuXG4vLyBGdW5jdGlvbnMgbmFtZXMgZm9yIEVTNiBleHBvcnRzXG5sZXQgYXV0b0Zvcm1hdDtcbmxldCBhdXRvVW5Gb3JtYXQ7XG5sZXQgZ2V0RGVmYXVsdENvbmZpZztcbmxldCB2YWxpZGF0ZTtcbmxldCBhcmVTZXR0aW5nc1ZhbGlkO1xuXG4vLyBBdXRvTnVtZXJpYyBkZWZhdWx0IHNldHRpbmdzXG4vKipcbiAqIExpc3Qgb2YgYWxsb3dlZCB0YWcgb24gd2hpY2ggYXV0b051bWVyaWMgY2FuIGJlIHVzZWQuXG4gKi9cbmNvbnN0IGFsbG93ZWRUYWdMaXN0ID0gW1xuICAgICdiJyxcbiAgICAnY2FwdGlvbicsXG4gICAgJ2NpdGUnLFxuICAgICdjb2RlJyxcbiAgICAnY29uc3QnLFxuICAgICdkZCcsXG4gICAgJ2RlbCcsXG4gICAgJ2RpdicsXG4gICAgJ2RmbicsXG4gICAgJ2R0JyxcbiAgICAnZW0nLFxuICAgICdoMScsXG4gICAgJ2gyJyxcbiAgICAnaDMnLFxuICAgICdoNCcsXG4gICAgJ2g1JyxcbiAgICAnaDYnLFxuICAgICdpbnMnLFxuICAgICdrZGInLFxuICAgICdsYWJlbCcsXG4gICAgJ2xpJyxcbiAgICAnb3B0aW9uJyxcbiAgICAnb3V0cHV0JyxcbiAgICAncCcsXG4gICAgJ3EnLFxuICAgICdzJyxcbiAgICAnc2FtcGxlJyxcbiAgICAnc3BhbicsXG4gICAgJ3N0cm9uZycsXG4gICAgJ3RkJyxcbiAgICAndGgnLFxuICAgICd1Jyxcbl07XG5cbi8qKlxuICogRGVmYXVsdHMgb3B0aW9ucyBhcmUgcHVibGljIC0gdGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGZvbGxvd2luZzpcbiAqIC0gSFRNTDUgZGF0YSBhdHRyaWJ1dGVzXG4gKiAtIE9wdGlvbnMgcGFzc2VkIGJ5IHRoZSAnaW5pdCcgb3IgJ3VwZGF0ZScgbWV0aG9kc1xuICogLSBVc2UgalF1ZXJ5J3MgYCQuZXh0ZW5kYCBtZXRob2QgZm9yIGdsb2JhbCBjaGFuZ2VzIC0gYWxzbyBhIGdyZWF0IHdheSB0byBwYXNzIEFTUC5ORVQgY3VycmVudCBjdWx0dXJlIHNldHRpbmdzXG4gKi9cbmNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHtcbiAgICAvKiBBbGxvd2VkIHRob3VzYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXJzXG4gICAgICogY29tbWEgPSBcIixcIlxuICAgICAqIHBlcmlvZCBcImZ1bGwgc3RvcFwiID0gXCIuXCJcbiAgICAgKiBxdW90ZSA9IFwiJ1wiXG4gICAgICogc3BhY2UgPSBcIiBcIlxuICAgICAqIG5vbmUgPSBcIlwiXG4gICAgICogTk9URTogZG8gbm90IHVzZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVNlcFxuICAgICAqL1xuICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3I6ICcsJyxcblxuICAgIC8qIFdoZW4gdHJ1ZSA9PiByZW1vdmVzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IsIGN1cnJlbmN5IHN5bWJvbCAmIHN1ZmZpeCBcImZvY3VzaW5cIlxuICAgICAqIGV4YW1wbGUgaWYgdGhlIGlucHV0IHZhbHVlIFwiJCAxLDk5OS44OCBzdWZmaXhcIlxuICAgICAqIG9uIFwiZm9jdXNpblwiIGl0IGJlY29tZXMgXCIxOTk5Ljg4XCIgYW5kIGJhY2sgdG8gXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiIG9uIGZvY3VzIG91dC5cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogblNlcFxuICAgICAqL1xuICAgIG5vU2VwYXJhdG9yT25Gb2N1czogZmFsc2UsXG5cbiAgICAvKiBEaWdpdGFsIGdyb3VwaW5nIGZvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHVzZWQgaW4gRm9ybWF0XG4gICAgICogZGlnaXRhbEdyb3VwU3BhY2luZzogXCIyXCIsIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiM1wiLCByZXN1bHRzIGluIDk5OSw5OTksOTk5IGRlZmF1bHRcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjRcIiwgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGRHcm91cFxuICAgICAqL1xuICAgIGRpZ2l0YWxHcm91cFNwYWNpbmc6ICczJyxcblxuICAgIC8qIEFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuICAgICAqIHBlcmlvZCBcImZ1bGwgc3RvcFwiID0gXCIuXCJcbiAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFEZWNcbiAgICAgKi9cbiAgICBkZWNpbWFsQ2hhcmFjdGVyOiAnLicsXG5cbiAgICAvKiBBbGxvdyB0byBkZWNsYXJlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgYnkgZGVjaW1hbENoYXJhY3RlclxuICAgICAqIGRldmVsb3BlZCBmb3IgY291bnRyaWVzIHRoZSB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgaGF2ZSBrZXlib2FyZHNcXG51bWVyaWMgcGFkcyB0aGF0IGhhdmUgYSBwZXJpb2QgJ2Z1bGwgc3RvcCcgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVycyAoU3BhaW4gaXMgYW4gZXhhbXBsZSlcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYWx0RGVjXG4gICAgICovXG4gICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlOiBudWxsLFxuXG4gICAgLyogY3VycmVuY3lTeW1ib2wgPSBhbGxvd2VkIGN1cnJlbmN5IHN5bWJvbFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGN1cnJlbmN5U3ltYm9sOiBcIiRcIlxuICAgICAqIHNwYWNlIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGN1cnJlbmN5U3ltYm9sOiAnJCAnXG4gICAgICogc3BhY2UgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBjdXJyZW5jeVN5bWJvbDogJyAkJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU2lnblxuICAgICAqL1xuICAgIGN1cnJlbmN5U3ltYm9sOiAnJyxcblxuICAgIC8qIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID0gcGxhY2VtZW50IG9mIGN1cnJlbmN5IHNpZ24gYXMgYSBwPXByZWZpeCBvciBzPXN1ZmZpeFxuICAgICAqIGZvciBwcmVmaXggY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwicFwiIChkZWZhdWx0KVxuICAgICAqIGZvciBzdWZmaXggY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHBTaWduXG4gICAgICovXG4gICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6ICdwJyxcblxuICAgIC8qIFBsYWNlbWVudCBvZiBuZWdhdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW5jeVN5bWJvbCBvcHRpb24gbD1sZWZ0LCByPXJpZ2h0LCBwPXByZWZpeCAmIHM9c3VmZml4XG4gICAgICogLTEsMjM0LjU2ICA9PiBkZWZhdWx0IG5vIG9wdGlvbnMgcmVxdWlyZWRcbiAgICAgKiAtJDEsMjM0LjU2ID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCJ9XG4gICAgICogJC0xLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9XG4gICAgICogLTEsMjM0LjU2JCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn1cbiAgICAgKiAxLDIzNC41Ni0gID0+IHtuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJzXCJ9XG4gICAgICogJDEsMjM0LjU2LSA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJzXCJ9XG4gICAgICogMSwyMzQuNTYtJCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCJ9XG4gICAgICogMSwyMzQuNTYkLSA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInJcIn1cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogcE5lZ1xuICAgICAqL1xuICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiAnbCcsXG5cbiAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIHN1ZmZpeFRleHQ6ICdncm9zcycsIGEgc3BhY2UgaXMgYWxsb3dlZCBzdWZmaXhUZXh0OiAnIGRvbGxhcnMnXG4gICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU3VmZml4XG4gICAgICovXG4gICAgc3VmZml4VGV4dDogJycsXG5cbiAgICAvKiBPdmVycmlkZSBtaW4gbWF4IGxpbWl0c1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIG1heGltdW1WYWx1ZSBhbmQgaWdub3JlcyBtaW5pbXVtVmFsdWUgc2V0dGluZ3NcbiAgICAgKiBvdmVycmlkZU1pbk1heExpbWl0czogXCJmbG9vclwiIGFkaGVyZXMgdG8gbWluaW11bVZhbHVlIGFuZCBpZ25vcmVzIG1heGltdW1WYWx1ZSBzZXR0aW5nc1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImlnbm9yZVwiIGlnbm9yZXMgYm90aCBtaW5pbXVtVmFsdWUgJiBtYXhpbXVtVmFsdWVcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogb0xpbWl0c1xuICAgICAqL1xuICAgIG92ZXJyaWRlTWluTWF4TGltaXRzOiBudWxsLFxuXG4gICAgLyogTWF4aW11bSBwb3NzaWJsZSB2YWx1ZVxuICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIG1pbmltdW1WYWx1ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB2TWF4XG4gICAgICovXG4gICAgbWF4aW11bVZhbHVlOiAnOTk5OTk5OTk5OTk5OS45OScsIC8vIDkuOTk5Ljk5OS45OTkuOTk5LDk5IH49IDEwMDAwIGJpbGxpb25zXG5cbiAgICAvKiBNaW5pbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAqIHZhbHVlIG11c3QgYmUgc21hbGxlciB0aGFuIG1heGltdW1WYWx1ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB2TWluXG4gICAgICovXG4gICAgbWluaW11bVZhbHVlOiAnLTk5OTk5OTk5OTk5OTkuOTknLCAvLyAtOS45OTkuOTk5Ljk5OS45OTksOTkgfj0gMTAwMDAgYmlsbGlvbnNcblxuICAgIC8qIE1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzID0gdXNlZCB0byBvdmVycmlkZSBkZWNpbWFsIHBsYWNlcyBzZXQgYnkgdGhlIG1pbmltdW1WYWx1ZSAmIG1heGltdW1WYWx1ZSB2YWx1ZXNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbURlY1xuICAgICAqL1xuICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZTogbnVsbCxcblxuICAgIC8qIEV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIHZpc2libGUgd2hlbiBpbnB1dCBoYXMgZm9jdXMgLSBleGFtcGxlOlxuICAgICAqIHtkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcbiAgICAgKiB0aGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZURlY1xuICAgICAqL1xuICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXM6IG51bGwsXG5cbiAgICAvKiBUaGUgbmV4dCB0aHJlZSBvcHRpb25zIChzY2FsZURpdmlzb3IsIHNjYWxlRGVjaW1hbFBsYWNlcyAmIHNjYWxlU3ltYm9sKSBoYW5kbGUgc2NhbGluZyBvZiB0aGUgaW5wdXQgd2hlbiB0aGUgaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG5vbi1zY2FsZWQgdmFsdWUgaXMgaGVsZCBpbiBkYXRhIGFuZCBpdCBpcyBhZHZpc2VkIHRoYXQgeW91IHVzZSB0aGUgXCJzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlXCIgb3B0aW9uIHRvIGVuc3VyZSByZXRhaW5pbmcgdGhlIHZhbHVlXG4gICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXG4gICAgICogRXhhbXBsZTogd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbnMgc2V0IHtzY2FsZURpdmlzb3I6ICcxMDAwJywgc2NhbGVEZWNpbWFsUGxhY2VzOiAnMScsIHNjYWxlU3ltYm9sOiAnIEsnfVxuICAgICAqIEV4YW1wbGU6IGZvY3VzaW4gdmFsdWUgXCIxLDExMS4xMVwiIGZvY3Vzb3V0IHZhbHVlIFwiMS4xIEtcIlxuICAgICAqL1xuXG4gICAgLyogVGhlIGBzY2FsZURpdmlzb3JgIGRlY2lkZXMgdGhlIG9uIGZvY3VzIHZhbHVlIGFuZCBwbGFjZXMgdGhlIHJlc3VsdCBpbiB0aGUgaW5wdXQgb24gZm9jdXNvdXRcbiAgICAgKiBFeGFtcGxlIHtzY2FsZURpdmlzb3I6ICcxMDAwJ30gb3IgPGlucHV0IGRhdGEtc2NhbGUtZGl2aXNvcj1cIjEwMDBcIj5cbiAgICAgKiBUaGUgZGl2aXNvciB2YWx1ZSAtIGRvZXMgbm90IG5lZWQgdG8gYmUgd2hvbGUgbnVtYmVyIGJ1dCBwbGVhc2UgdW5kZXJzdGFuZCB0aGF0IEphdmFzY3JpcHQgaGFzIGxpbWl0ZWQgYWNjdXJhY3kgaW4gbWF0aFxuICAgICAqIFRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBmdWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlICdoaWRkZW4nIGRlY2ltYWxzLlxuICAgICAqL1xuICAgIHNjYWxlRGl2aXNvcjogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZURlY2ltYWxQbGFjZXNgIG9wdGlvbiBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2Ugd2hlbiBub3QgaW4gZm9jdXMgLSBmb3IgdGhpcyB0byB3b3JrLCBgc2NhbGVkRGl2aXNvcmAgbXVzdCBub3QgYmUgYG51bGxgLlxuICAgICAqIFRoaXMgaXMgb3B0aW9uYWwgOyBpZiBvbWl0dGVkIHRoZSBkZWNpbWFsIHBsYWNlcyB3aWxsIGJlIHRoZSBzYW1lIHdoZW4gdGhlIGlucHV0IGhhcyB0aGUgZm9jdXMuXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHNjYWxlRGVjaW1hbFxuICAgICAqL1xuICAgIHNjYWxlRGVjaW1hbFBsYWNlczogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZVN5bWJvbGAgb3B0aW9uIGlzIGEgc3ltYm9sIHBsYWNlZCBhcyBhIHN1ZmZpeCB3aGVuIG5vdCBpbiBmb2N1cy5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIHRvby5cbiAgICAgKi9cbiAgICBzY2FsZVN5bWJvbDogbnVsbCxcblxuICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcbiAgICAgKiBpZiBpZSA2IG9yIDcgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU3RvclxuICAgICAqL1xuICAgIHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2U6IGZhbHNlLFxuXG4gICAgLypcbiAgICAgKiBNYW5hZ2UgaG93IGF1dG9OdW1lcmljIHJlYWN0IHdoZW4gdGhlIHVzZXIgdHJpZXMgdG8gcGFzdGUgYW4gaW52YWxpZCBudW1iZXIuXG4gICAgICogLSAnZXJyb3InICAgIDogKFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IpIFRoZSBpbnB1dCB2YWx1ZSBpcyBub3QgY2hhbmdlZCBhbmQgYW4gZXJyb3IgaXMgb3V0cHV0IGluIHRoZSBjb25zb2xlLlxuICAgICAqIC0gJ2lnbm9yZScgICA6IGlkZW0gdGhhbiAnZXJyb3InLCBidXQgZmFpbCBzaWxlbnRseSB3aXRob3V0IG91dHB1dHRpbmcgYW55IGVycm9yL3dhcm5pbmcgaW4gdGhlIGNvbnNvbGUuXG4gICAgICogLSAnY2xhbXAnICAgIDogaWYgdGhlIHBhc3RlZCB2YWx1ZSBpcyBlaXRoZXIgdG9vIHNtYWxsIG9yIHRvbyBiaWcgcmVnYXJkaW5nIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSByYW5nZSwgdGhlbiB0aGUgcmVzdWx0IGlzIGNsYW1wZWQgdG8gdGhvc2UgbGltaXRzLlxuICAgICAqIC0gJ3RydW5jYXRlJyA6IGF1dG9OdW1lcmljIHdpbGwgaW5zZXJ0IGFzIG1hbnkgcGFzdGVkIG51bWJlcnMgaXQgY2FuIGF0IHRoZSBpbml0aWFsIGNhcmV0L3NlbGVjdGlvbiwgdW50aWwgZXZlcnl0aGluZyBpcyBwYXN0ZWQsIG9yIHRoZSByYW5nZSBsaW1pdCBpcyBoaXQuXG4gICAgICogICAgICAgICAgICAgICAgVGhlIG5vbi1wYXN0ZWQgbnVtYmVycyBhcmUgZHJvcHBlZCBhbmQgdGhlcmVmb3JlIG5vdCB1c2VkIGF0IGFsbC5cbiAgICAgKiAtICdyZXBsYWNlJyAgOiBhdXRvTnVtZXJpYyB3aWxsIGZpcnN0IGluc2VydCBhcyBtYW55IHBhc3RlZCBudW1iZXJzIGl0IGNhbiBhdCB0aGUgaW5pdGlhbCBjYXJldC9zZWxlY3Rpb24sIHRoZW4gaWYgdGhlIHJhbmdlIGxpbWl0IGlzIGhpdCwgaXQgd2lsbCB0cnlcbiAgICAgKiAgICAgICAgICAgICAgICB0byByZXBsYWNlIG9uZSBieSBvbmUgdGhlIHJlbWFpbmluZyBpbml0aWFsIG51bWJlcnMgKG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjYXJldCkgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcGFzdGVkIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBOb3RlIDEgOiBBIHBhc3RlIGNvbnRlbnQgc3RhcnRpbmcgd2l0aCBhIG5lZ2F0aXZlIHNpZ24gJy0nIHdpbGwgYmUgYWNjZXB0ZWQgYW55d2hlcmUgaW4gdGhlIGlucHV0LCBhbmQgd2lsbCBzZXQgdGhlIHJlc3VsdGluZyB2YWx1ZSBhcyBhIG5lZ2F0aXZlIG51bWJlclxuICAgICAqIE5vdGUgMiA6IEEgcGFzdGUgY29udGVudCBzdGFydGluZyB3aXRoIGEgbnVtYmVyIHdpbGwgYmUgYWNjZXB0ZWQsIGV2ZW4gaWYgdGhlIHJlc3QgaXMgZ2liYmVyaXNoIChpZS4gJzEyM2Zvb2JhcjQ1NicpLlxuICAgICAqICAgICAgICAgIE9ubHkgdGhlIGZpcnN0IG51bWJlciB3aWxsIGJlIHVzZWQgKGhlcmUgJzEyMycpLlxuICAgICAqIE5vdGUgMyA6IFRoZSBwYXN0ZSBldmVudCB3b3JrcyB3aXRoIHRoZSBgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c2Agb3B0aW9uIHRvby5cbiAgICAgKi9cbiAgICAvL1RPRE8gU2hvdWxkbid0IHdlIHVzZSBgdHJ1bmNhdGVgIGFzIHRoZSBkZWZhdWx0IHZhbHVlP1xuICAgIG9uSW52YWxpZFBhc3RlOiAnZXJyb3InLFxuXG4gICAgLyogbWV0aG9kIHVzZWQgZm9yIHJvdW5kaW5nXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiU1wiLCBSb3VuZC1IYWxmLVVwIFN5bW1ldHJpYyAoZGVmYXVsdClcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJBXCIsIFJvdW5kLUhhbGYtVXAgQXN5bW1ldHJpY1xuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcImFcIiwgUm91bmQtSGFsZi1Eb3duIEFzeW1tZXRyaWMgKGxvd2VyIGNhc2UgYSlcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJCXCIsIFJvdW5kLUhhbGYtRXZlbiBcIkJhbmtlcnMgUm91bmRpbmdcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiRFwiLCBSb3VuZCBEb3duIFwiUm91bmQtVG93YXJkLVplcm9cIiAtIHNhbWUgYXMgdHJ1bmNhdGVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJDXCIsIFJvdW5kIHRvIENlaWxpbmcgXCJUb3dhcmQgUG9zaXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIk4wNVwiIFJvdW5kcyB0byB0aGUgbmVhcmVzdCAuMDUgPT4gc2FtZSBhcyBcIkNIRlwiIHVzZWQgaW4gMS45WCBhbmQgc3RpbGwgdmFsaWRcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJVMDVcIiBSb3VuZHMgdXAgdG8gbmV4dCAuMDVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBtUm91bmRcbiAgICAgKi9cbiAgICByb3VuZGluZ01ldGhvZDogJ1MnLFxuXG4gICAgLyogQ29udHJvbHMgZGVjaW1hbCBwYWRkaW5nXG4gICAgICogYWxsb3dEZWNpbWFsUGFkZGluZzogdHJ1ZSAtIGFsd2F5cyBQYWQgZGVjaW1hbHMgd2l0aCB6ZXJvc1xuICAgICAqIGFsbG93RGVjaW1hbFBhZGRpbmc6IGZhbHNlIC0gZG9lcyBub3QgcGFkIHdpdGggemVyb3MuXG4gICAgICogTm90ZTogc2V0dGluZyBhbGxvd0RlY2ltYWxQYWRkaW5nIHRvICdmYWxzZScgd2lsbCBvdmVycmlkZSB0aGUgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIHRoYW5rcyB0byBKb25hcyBKb2hhbnNzb24gZm9yIHRoZSBzdWdnZXN0aW9uXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFQYWRcbiAgICAgKi9cbiAgICBhbGxvd0RlY2ltYWxQYWRkaW5nOiB0cnVlLFxuXG4gICAgLyogQWRkcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMgKGllLiB0cmFuc2Zvcm1zICctJCA5OTkuOTknIHRvICcoOTk5Ljk5KScpXG4gICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cbiAgICAgKiBUaGUgbGVmdCBhbmQgcmlnaHQgc3ltYm9scyBzaG91bGQgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyOiBudWxsIC0gKGRlZmF1bHQpXG4gICAgICogbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXI6ICcoLCknLCBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogJ1ssXScsIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyOiAnPCw+JyBvciBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogJ3ssfSdcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbkJyYWNrZXRcbiAgICAgKi9cbiAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogbnVsbCxcblxuICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJmb2N1c1wiIC0gKGRlZmF1bHQpIGN1cnJlbmN5IHNpZ24gZGlzcGxheWVkIGFuZCB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXNcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwicHJlc3NcIiAtIGN1cnJlbmN5IHNpZ24gZGlzcGxheXMgb24gYW55IGtleSBiZWluZyBwcmVzc2VkXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwiemVyb1wiIC0gaWYgdGhlIGlucHV0IGhhcyBubyB2YWx1ZSBvbiBmb2N1cyBvdXQgZGlzcGxheXMgYSB6ZXJvIFwicm91bmRlZFwiIHdpdGggb3Igd2l0aG91dCBhIGN1cnJlbmN5IHNpZ25cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogd0VtcHR5XG4gICAgICovXG4gICAgZW1wdHlJbnB1dEJlaGF2aW9yOiAnZm9jdXMnLFxuXG4gICAgLyogQ29udHJvbHMgbGVhZGluZyB6ZXJvIGJlaGF2aW9yXG4gICAgICogbGVhZGluZ1plcm86IFwiYWxsb3dcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBaZXJvcyB3aWxsIGJlIHRydW5jYXRlZCB3aGVuIGVudGVyaW5nIGFkZGl0aW9uYWwgZGlnaXRzLiBPbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIGRlbGV0ZWQuXG4gICAgICogbGVhZGluZ1plcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcbiAgICAgKiBsZWFkaW5nWmVybzogXCJrZWVwXCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZC5cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbFplcm9cbiAgICAgKi9cbiAgICBsZWFkaW5nWmVybzogJ2RlbnknLFxuXG4gICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cbiAgICAgKiBmYWxzZSA9IHdpbGwgbm90IGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBpbml0aWFsaXphdGlvblxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhRm9ybVxuICAgICAqL1xuICAgIGZvcm1hdE9uUGFnZUxvYWQ6IHRydWUsXG5cbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdCB0aGUgY29tcGxldGUgaW5wdXQgdGV4dCwgb3Igb25seSB0aGUgaW5wdXQgbnVtZXJpYyB2YWx1ZVxuICAgICAqIE5vdGUgOiBJZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduLCBvbmx5IHRoZSBudW1lcmljIHZhbHVlIHdpbGwgc2VsZWN0ZWRcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogc051bWJlclxuICAgICAqL1xuICAgIHNlbGVjdE51bWJlck9ubHk6IGZhbHNlLFxuXG4gICAgLyogSGVscGVyIG9wdGlvbiBmb3IgQVNQLk5FVCBwb3N0YmFja1xuICAgICAqIHNob3VsZCBiZSB0aGUgdmFsdWUgb2YgdGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBleGFtcGxlczpcbiAgICAgKiBubyBkZWZhdWx0IHZhbHVlPVwiXCIge2RlZmF1bHRWYWx1ZU92ZXJyaWRlOiBcIlwifVxuICAgICAqIHZhbHVlPTEyMzQuNTYge2RlZmF1bHRWYWx1ZU92ZXJyaWRlOiAnMTIzNC41Nid9XG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFuRGVmYXVsdFxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZU92ZXJyaWRlOiBudWxsLFxuXG4gICAgLyogUmVtb3ZlcyBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBldmVudFxuICAgICAqIHRoaXMgb3V0cHV0IGZvcm1hdDogcG9zaXRpdmUgbm5ubi5ubiwgbmVnYXRpdmUgLW5ubm4ubm5cbiAgICAgKiByZXZpZXcgdGhlICd1blNldCcgbWV0aG9kIGZvciBvdGhlciBmb3JtYXRzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHVuU2V0T25TdWJtaXRcbiAgICAgKi9cbiAgICB1bmZvcm1hdE9uU3VibWl0OiBmYWxzZSxcblxuICAgIC8qIEFsbG93cyB0aGUgb3V0cHV0IHRvIGJlIGluIHRoZSBsb2NhbGUgZm9ybWF0IHZpYSB0aGUgXCJnZXRcIiwgXCJnZXRTdHJpbmdcIiAmIFwiZ2V0QXJyYXlcIiBtZXRob2RzXG4gICAgICogbnVsbCBvciAnc3RyaW5nJyA9PiAnbm5ubi5ubicgb3IgJy1ubm5uLm5uJyBhcyB0ZXh0IHR5cGUuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICogJ251bWJlcicgICAgICAgICA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGFzIGEgTnVtYmVyIChXYXJuaW5nOiB0aGlzIHdvcmtzIG9ubHkgZm9yIGludGVnZXJzIGluZmVyaW9yIHRvIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICAgICAqICcsJyBvciAnLSwnICAgICAgPT4gJ25ubm4sbm4nIG9yICctbm5ubixubidcbiAgICAgKiAnLi0nICAgICAgICAgICAgID0+ICdubm5uLm5uJyBvciAnbm5ubi5ubi0nXG4gICAgICogJywtJyAgICAgICAgICAgICA9PiAnbm5ubixubicgb3IgJ25ubm4sbm4tJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBvdXRwdXRUeXBlXG4gICAgICovXG4gICAgb3V0cHV0Rm9ybWF0OiBudWxsLFxuXG4gICAgLyogRXJyb3IgaGFuZGxpbmcgZnVuY3Rpb25cbiAgICAgKiB0cnVlID0+IGFsbCB3YXJuaW5nIGFyZSBzaG93blxuICAgICAqIGZhbHNlID0+IG5vIHdhcm5pbmdzIGFyZSBzaG93biwgb25seSB0aGUgdGhyb3duIGVycm9yc1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBkZWJ1Z1xuICAgICAqL1xuICAgIHNob3dXYXJuaW5nczogdHJ1ZSxcblxuICAgIC8qXG4gICAgICogVGhpcyBvcHRpb24gaXMgdGhlICdzdHJpY3QgbW9kZScgKGFrYSAnZGVidWcnIG1vZGUpLCB3aGljaCBhbGxvd3MgYXV0b051bWVyaWMgdG8gc3RyaWN0bHkgYW5hbHlzZSB0aGUgb3B0aW9ucyBwYXNzZWQsIGFuZCBmYWlscyBpZiBhbiB1bmtub3duIG9wdGlvbnMgaXMgdXNlZCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAqIFlvdSBzaG91bGQgc2V0IHRoYXQgdG8gJ1RSVUUnIGlmIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSB5b3UgYXJlIG9ubHkgdXNpbmcgJ3B1cmUnIGF1dG9OdW1lcmljIHNldHRpbmdzIG9iamVjdHMgaW4geW91ciBjb2RlLlxuICAgICAqIElmIHlvdSBzZWUgdW5jYXVnaHQgZXJyb3JzIGluIHRoZSBjb25zb2xlIGFuZCB5b3VyIGNvZGUgc3RhcnRzIHRvIGZhaWwsIHRoaXMgbWVhbnMgc29tZWhvdyB0aG9zZSBvcHRpb25zIGdldHMgY29ycnVwdGVkIGJ5IGFub3RoZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBmYWlsT25Vbmtub3duT3B0aW9uOiBmYWxzZSxcbn07XG5cbi8qKlxuICogV3JhcHBlciB2YXJpYWJsZSB0aGF0IGhvbGQgbmFtZWQga2V5Ym9hcmQga2V5cyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUga2V5Q29kZSBhcyBzZWVuIGluIERPTSBldmVudHMuXG4gKiAvL1RPRE8gUmVwbGFjZSBldmVyeSBjYWxsIHRvIHRoaXMgb2JqZWN0IHdpdGggYSBjYWxsIHRvIGBrZXlOYW1lYFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuY29uc3Qga2V5Q29kZSA9IHtcbiAgICBCYWNrc3BhY2U6ICAgICAgOCxcbiAgICBUYWI6ICAgICAgICAgICAgOSxcbiAgICBFbnRlcjogICAgICAgICAgMTMsXG4gICAgU2hpZnQ6ICAgICAgICAgIDE2LFxuICAgIEN0cmw6ICAgICAgICAgICAxNyxcbiAgICBBbHQ6ICAgICAgICAgICAgMTgsXG4gICAgUGF1c2VCcmVhazogICAgIDE5LFxuICAgIENhcHNMb2NrOiAgICAgICAyMCxcbiAgICBFc2M6ICAgICAgICAgICAgMjcsXG4gICAgU3BhY2U6ICAgICAgICAgIDMyLFxuICAgIFBhZ2VVcDogICAgICAgICAzMyxcbiAgICBQYWdlRG93bjogICAgICAgMzQsXG4gICAgRW5kOiAgICAgICAgICAgIDM1LFxuICAgIEhvbWU6ICAgICAgICAgICAzNixcbiAgICBMZWZ0QXJyb3c6ICAgICAgMzcsXG4gICAgVXBBcnJvdzogICAgICAgIDM4LFxuICAgIFJpZ2h0QXJyb3c6ICAgICAzOSxcbiAgICBEb3duQXJyb3c6ICAgICAgNDAsXG4gICAgSW5zZXJ0OiAgICAgICAgIDQ1LFxuICAgIERlbGV0ZTogICAgICAgICA0NixcbiAgICBudW0wOiAgICAgICAgICAgNDgsXG4gICAgbnVtMTogICAgICAgICAgIDQ5LFxuICAgIG51bTI6ICAgICAgICAgICA1MCxcbiAgICBudW0zOiAgICAgICAgICAgNTEsXG4gICAgbnVtNDogICAgICAgICAgIDUyLFxuICAgIG51bTU6ICAgICAgICAgICA1MyxcbiAgICBudW02OiAgICAgICAgICAgNTQsXG4gICAgbnVtNzogICAgICAgICAgIDU1LFxuICAgIG51bTg6ICAgICAgICAgICA1NixcbiAgICBudW05OiAgICAgICAgICAgNTcsXG4gICAgYTogICAgICAgICAgICAgIDY1LFxuICAgIGI6ICAgICAgICAgICAgICA2NixcbiAgICBjOiAgICAgICAgICAgICAgNjcsXG4gICAgZDogICAgICAgICAgICAgIDY4LFxuICAgIGU6ICAgICAgICAgICAgICA2OSxcbiAgICBmOiAgICAgICAgICAgICAgNzAsXG4gICAgZzogICAgICAgICAgICAgIDcxLFxuICAgIGg6ICAgICAgICAgICAgICA3MixcbiAgICBpOiAgICAgICAgICAgICAgNzMsXG4gICAgajogICAgICAgICAgICAgIDc0LFxuICAgIGs6ICAgICAgICAgICAgICA3NSxcbiAgICBsOiAgICAgICAgICAgICAgNzYsXG4gICAgbTogICAgICAgICAgICAgIDc3LFxuICAgIG46ICAgICAgICAgICAgICA3OCxcbiAgICBvOiAgICAgICAgICAgICAgNzksXG4gICAgcDogICAgICAgICAgICAgIDgwLFxuICAgIHE6ICAgICAgICAgICAgICA4MSxcbiAgICByOiAgICAgICAgICAgICAgODIsXG4gICAgczogICAgICAgICAgICAgIDgzLFxuICAgIHQ6ICAgICAgICAgICAgICA4NCxcbiAgICB1OiAgICAgICAgICAgICAgODUsXG4gICAgdjogICAgICAgICAgICAgIDg2LFxuICAgIHc6ICAgICAgICAgICAgICA4NyxcbiAgICB4OiAgICAgICAgICAgICAgODgsXG4gICAgeTogICAgICAgICAgICAgIDg5LFxuICAgIHo6ICAgICAgICAgICAgICA5MCxcbiAgICBXaW5kb3dzOiAgICAgICAgOTEsXG4gICAgUmlnaHRDbGljazogICAgIDkzLFxuICAgIG51bXBhZDA6ICAgICAgICA5NixcbiAgICBudW1wYWQxOiAgICAgICAgOTcsXG4gICAgbnVtcGFkMjogICAgICAgIDk4LFxuICAgIG51bXBhZDM6ICAgICAgICA5OSxcbiAgICBudW1wYWQ0OiAgICAgICAgMTAwLFxuICAgIG51bXBhZDU6ICAgICAgICAxMDEsXG4gICAgbnVtcGFkNjogICAgICAgIDEwMixcbiAgICBudW1wYWQ3OiAgICAgICAgMTAzLFxuICAgIG51bXBhZDg6ICAgICAgICAxMDQsXG4gICAgbnVtcGFkOTogICAgICAgIDEwNSxcbiAgICBNdWx0aXBseU51bXBhZDogMTA2LFxuICAgIFBsdXNOdW1wYWQ6ICAgICAxMDcsXG4gICAgTWludXNOdW1wYWQ6ICAgIDEwOSxcbiAgICBEb3ROdW1wYWQ6ICAgICAgMTEwLFxuICAgIFNsYXNoTnVtcGFkOiAgICAxMTEsXG4gICAgRjE6ICAgICAgICAgICAgIDExMixcbiAgICBGMjogICAgICAgICAgICAgMTEzLFxuICAgIEYzOiAgICAgICAgICAgICAxMTQsXG4gICAgRjQ6ICAgICAgICAgICAgIDExNSxcbiAgICBGNTogICAgICAgICAgICAgMTE2LFxuICAgIEY2OiAgICAgICAgICAgICAxMTcsXG4gICAgRjc6ICAgICAgICAgICAgIDExOCxcbiAgICBGODogICAgICAgICAgICAgMTE5LFxuICAgIEY5OiAgICAgICAgICAgICAxMjAsXG4gICAgRjEwOiAgICAgICAgICAgIDEyMSxcbiAgICBGMTE6ICAgICAgICAgICAgMTIyLFxuICAgIEYxMjogICAgICAgICAgICAxMjMsXG4gICAgTnVtTG9jazogICAgICAgIDE0NCxcbiAgICBTY3JvbGxMb2NrOiAgICAgMTQ1LFxuICAgIE15Q29tcHV0ZXI6ICAgICAxODIsXG4gICAgTXlDYWxjdWxhdG9yOiAgIDE4MyxcbiAgICBTZW1pY29sb246ICAgICAgMTg2LFxuICAgIEVxdWFsOiAgICAgICAgICAxODcsXG4gICAgQ29tbWE6ICAgICAgICAgIDE4OCxcbiAgICBIeXBoZW46ICAgICAgICAgMTg5LFxuICAgIERvdDogICAgICAgICAgICAxOTAsXG4gICAgU2xhc2g6ICAgICAgICAgIDE5MSxcbiAgICBCYWNrcXVvdGU6ICAgICAgMTkyLFxuICAgIExlZnRCcmFja2V0OiAgICAyMTksXG4gICAgQmFja3NsYXNoOiAgICAgIDIyMCxcbiAgICBSaWdodEJyYWNrZXQ6ICAgMjIxLFxuICAgIFF1b3RlOiAgICAgICAgICAyMjIsXG4gICAgQ29tbWFuZDogICAgICAgIDIyNCxcbn07XG5cbi8qKlxuICogV3JhcHBlciB2YXJpYWJsZSB0aGF0IGhvbGQgbmFtZWQga2V5Ym9hcmQga2V5cyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUga2V5IG5hbWUgKGFzIHNldCBpbiBLZXlib2FyZEV2ZW50LmtleSkuXG4gKiBUaG9zZSBuYW1lcyBhcmUgbGlzdGVkIGhlcmUgOlxuICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5L0tleV9WYWx1ZXNcbiAqL1xuY29uc3Qga2V5TmFtZSA9IHtcbiAgICAvLyBTcGVjaWFsIHZhbHVlc1xuICAgIFVuaWRlbnRpZmllZDogICAnVW5pZGVudGlmaWVkJyxcblxuICAgIC8vIE1vZGlmaWVyIGtleXNcbiAgICBBbHQ6ICAgICAgICAgICAgJ0FsdCcsXG4gICAgQWx0R3I6ICAgICAgICAgICdBbHRHcmFwaCcsXG4gICAgQ2Fwc0xvY2s6ICAgICAgICdDYXBzTG9jaycsIC8vIFVuZGVyIENocm9tZSwgZS5rZXkgaXMgZW1wdHkgZm9yIENhcHNMb2NrXG4gICAgQ3RybDogICAgICAgICAgICdDb250cm9sJyxcbiAgICBGbjogICAgICAgICAgICAgJ0ZuJyxcbiAgICBGbkxvY2s6ICAgICAgICAgJ0ZuTG9jaycsXG4gICAgSHlwZXI6ICAgICAgICAgICdIeXBlcicsIC8vICdPUycgdW5kZXIgRmlyZWZveFxuICAgIE1ldGE6ICAgICAgICAgICAnTWV0YScsIC8vIFRoZSBXaW5kb3dzLCBDb21tYW5kIG9yIOKMmCBrZXkgLy8gJ09TJyB1bmRlciBGaXJlZm94IGFuZCBJRTlcbiAgICBXaW5kb3dzOiAgICAgICAgJ01ldGEnLCAvLyBUaGlzIGlzIGEgbm9uLW9mZmljaWFsIGtleSBuYW1lXG4gICAgQ29tbWFuZDogICAgICAgICdNZXRhJywgLy8gVGhpcyBpcyBhIG5vbi1vZmZpY2lhbCBrZXkgbmFtZVxuICAgIE51bUxvY2s6ICAgICAgICAnTnVtTG9jaycsXG4gICAgU2Nyb2xsTG9jazogICAgICdTY3JvbGxMb2NrJyxcbiAgICBTaGlmdDogICAgICAgICAgJ1NoaWZ0JyxcbiAgICBTdXBlcjogICAgICAgICAgJ1N1cGVyJywgLy8gJ09TJyB1bmRlciBGaXJlZm94XG4gICAgU3ltYm9sOiAgICAgICAgICdTeW1ib2wnLFxuICAgIFN5bWJvbExvY2s6ICAgICAnU3ltYm9sTG9jaycsXG5cbiAgICAvLyBXaGl0ZXNwYWNlIGtleXNcbiAgICBFbnRlcjogICAgICAgICAgJ0VudGVyJyxcbiAgICBUYWI6ICAgICAgICAgICAgJ1RhYicsXG4gICAgU3BhY2U6ICAgICAgICAgICcgJywgLy8gJ1NwYWNlYmFyJyBmb3IgRmlyZWZveCA8MzcsIGFuZCBJRTlcblxuICAgIC8vIE5hdmlnYXRpb24ga2V5c1xuICAgIERvd25BcnJvdzogICAgICAnQXJyb3dEb3duJywgLy8gJ0Rvd24nIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBMZWZ0QXJyb3c6ICAgICAgJ0Fycm93TGVmdCcsIC8vICdMZWZ0JyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgUmlnaHRBcnJvdzogICAgICdBcnJvd1JpZ2h0JywgLy8gJ1JpZ2h0JyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgVXBBcnJvdzogICAgICAgICdBcnJvd1VwJywgLy8gJ1VwJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgRW5kOiAgICAgICAgICAgICdFbmQnLFxuICAgIEhvbWU6ICAgICAgICAgICAnSG9tZScsXG4gICAgUGFnZURvd246ICAgICAgICdQYWdlRG93bicsXG4gICAgUGFnZVVwOiAgICAgICAgICdQYWdlVXAnLFxuXG4gICAgLy8gRWRpdGluZyBrZXlzXG4gICAgQmFja3NwYWNlOiAgICAgICdCYWNrc3BhY2UnLFxuICAgIENsZWFyOiAgICAgICAgICAnQ2xlYXInLFxuICAgIENvcHk6ICAgICAgICAgICAnQ29weScsXG4gICAgQ3JTZWw6ICAgICAgICAgICdDclNlbCcsIC8vICdDcnNlbCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIEN1dDogICAgICAgICAgICAnQ3V0JyxcbiAgICBEZWxldGU6ICAgICAgICAgJ0RlbGV0ZScsIC8vICdEZWwnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBFcmFzZUVvZjogICAgICAgJ0VyYXNlRW9mJyxcbiAgICBFeFNlbDogICAgICAgICAgJ0V4U2VsJywgLy8gJ0V4c2VsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgSW5zZXJ0OiAgICAgICAgICdJbnNlcnQnLFxuICAgIFBhc3RlOiAgICAgICAgICAnUGFzdGUnLFxuICAgIFJlZG86ICAgICAgICAgICAnUmVkbycsXG4gICAgVW5kbzogICAgICAgICAgICdVbmRvJyxcblxuICAgIC8vIFVJIGtleXNcbiAgICBBY2NlcHQ6ICAgICAgICAgJ0FjY2VwdCcsXG4gICAgQWdhaW46ICAgICAgICAgICdBZ2FpbicsXG4gICAgQXR0bjogICAgICAgICAgICdBdHRuJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3gsIENocm9tZSwgYW5kIElFOSAoJ0thbmFNb2RlJyB3aGVuIHVzaW5nIHRoZSBKYXBhbmVzZSBrZXlib2FyZCBsYXlvdXQpXG4gICAgQ2FuY2VsOiAgICAgICAgICdDYW5jZWwnLFxuICAgIENvbnRleHRNZW51OiAgICAnQ29udGV4dE1lbnUnLCAvLyAnQXBwcycgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIEVzYzogICAgICAgICAgICAnRXNjYXBlJywgLy8gJ0VzYycgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIEV4ZWN1dGU6ICAgICAgICAnRXhlY3V0ZScsXG4gICAgRmluZDogICAgICAgICAgICdGaW5kJyxcbiAgICBGaW5pc2g6ICAgICAgICAgJ0ZpbmlzaCcsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94LCBDaHJvbWUsIGFuZCBJRTkgKCdLYXRha2FuYScgd2hlbiB1c2luZyB0aGUgSmFwYW5lc2Uga2V5Ym9hcmQgbGF5b3V0KVxuICAgIEhlbHA6ICAgICAgICAgICAnSGVscCcsXG4gICAgUGF1c2U6ICAgICAgICAgICdQYXVzZScsXG4gICAgUGxheTogICAgICAgICAgICdQbGF5JyxcbiAgICBQcm9wczogICAgICAgICAgJ1Byb3BzJyxcbiAgICBTZWxlY3Q6ICAgICAgICAgJ1NlbGVjdCcsXG4gICAgWm9vbUluOiAgICAgICAgICdab29tSW4nLFxuICAgIFpvb21PdXQ6ICAgICAgICAnWm9vbU91dCcsXG5cbiAgICAvLyBEZXZpY2Uga2V5c1xuICAgIEJyaWdodG5lc3NEb3duOiAnQnJpZ2h0bmVzc0Rvd24nLFxuICAgIEJyaWdodG5lc3NVcDogICAnQnJpZ2h0bmVzc1VwJyxcbiAgICBFamVjdDogICAgICAgICAgJ0VqZWN0JyxcbiAgICBMb2dPZmY6ICAgICAgICAgJ0xvZ09mZicsXG4gICAgUG93ZXI6ICAgICAgICAgICdQb3dlcicsXG4gICAgUG93ZXJPZmY6ICAgICAgICdQb3dlck9mZicsXG4gICAgUHJpbnRTY3JlZW46ICAgICdQcmludFNjcmVlbicsXG4gICAgSGliZXJuYXRlOiAgICAgICdIaWJlcm5hdGUnLCAvLyAnVW5pZGVudGlmaWVkJyBmb3IgRmlyZWZveCA8PTM3XG4gICAgU3RhbmRieTogICAgICAgICdTdGFuZGJ5JywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIFdha2VVcDogICAgICAgICAnV2FrZVVwJyxcblxuICAgIC8vIElNRSBhbmQgY29tcG9zaXRpb24ga2V5c1xuICAgIENvbXBvc2U6ICAgICAgICAnQ29tcG9zZScsXG4gICAgRGVhZDogICAgICAgICAgICdEZWFkJyxcblxuICAgIC8vIEZ1bmN0aW9uIGtleXNcbiAgICBGMTogICAgICAgICAgICAgJ0YxJyxcbiAgICBGMjogICAgICAgICAgICAgJ0YyJyxcbiAgICBGMzogICAgICAgICAgICAgJ0YzJyxcbiAgICBGNDogICAgICAgICAgICAgJ0Y0JyxcbiAgICBGNTogICAgICAgICAgICAgJ0Y1JyxcbiAgICBGNjogICAgICAgICAgICAgJ0Y2JyxcbiAgICBGNzogICAgICAgICAgICAgJ0Y3JyxcbiAgICBGODogICAgICAgICAgICAgJ0Y4JyxcbiAgICBGOTogICAgICAgICAgICAgJ0Y5JyxcbiAgICBGMTA6ICAgICAgICAgICAgJ0YxMCcsXG4gICAgRjExOiAgICAgICAgICAgICdGMTEnLFxuICAgIEYxMjogICAgICAgICAgICAnRjEyJyxcblxuICAgIC8vIERvY3VtZW50IGtleXNcbiAgICBQcmludDogICAgICAgICAgJ1ByaW50JyxcblxuICAgIC8vICdOb3JtYWwnIGtleXNcbiAgICBudW0wOiAgICAgICAgICAgJzAnLFxuICAgIG51bTE6ICAgICAgICAgICAnMScsXG4gICAgbnVtMjogICAgICAgICAgICcyJyxcbiAgICBudW0zOiAgICAgICAgICAgJzMnLFxuICAgIG51bTQ6ICAgICAgICAgICAnNCcsXG4gICAgbnVtNTogICAgICAgICAgICc1JyxcbiAgICBudW02OiAgICAgICAgICAgJzYnLFxuICAgIG51bTc6ICAgICAgICAgICAnNycsXG4gICAgbnVtODogICAgICAgICAgICc4JyxcbiAgICBudW05OiAgICAgICAgICAgJzknLFxuICAgIG51bXBhZDA6ICAgICAgICAnMCcsXG4gICAgbnVtcGFkMTogICAgICAgICcxJyxcbiAgICBudW1wYWQyOiAgICAgICAgJzInLFxuICAgIG51bXBhZDM6ICAgICAgICAnMycsXG4gICAgbnVtcGFkNDogICAgICAgICc0JyxcbiAgICBudW1wYWQ1OiAgICAgICAgJzUnLFxuICAgIG51bXBhZDY6ICAgICAgICAnNicsXG4gICAgbnVtcGFkNzogICAgICAgICc3JyxcbiAgICBudW1wYWQ4OiAgICAgICAgJzgnLFxuICAgIG51bXBhZDk6ICAgICAgICAnOScsXG4gICAgYTogICAgICAgICAgICAgICdhJyxcbiAgICBiOiAgICAgICAgICAgICAgJ2InLFxuICAgIGM6ICAgICAgICAgICAgICAnYycsXG4gICAgZDogICAgICAgICAgICAgICdkJyxcbiAgICBlOiAgICAgICAgICAgICAgJ2UnLFxuICAgIGY6ICAgICAgICAgICAgICAnZicsXG4gICAgZzogICAgICAgICAgICAgICdnJyxcbiAgICBoOiAgICAgICAgICAgICAgJ2gnLFxuICAgIGk6ICAgICAgICAgICAgICAnaScsXG4gICAgajogICAgICAgICAgICAgICdqJyxcbiAgICBrOiAgICAgICAgICAgICAgJ2snLFxuICAgIGw6ICAgICAgICAgICAgICAnbCcsXG4gICAgbTogICAgICAgICAgICAgICdtJyxcbiAgICBuOiAgICAgICAgICAgICAgJ24nLFxuICAgIG86ICAgICAgICAgICAgICAnbycsXG4gICAgcDogICAgICAgICAgICAgICdwJyxcbiAgICBxOiAgICAgICAgICAgICAgJ3EnLFxuICAgIHI6ICAgICAgICAgICAgICAncicsXG4gICAgczogICAgICAgICAgICAgICdzJyxcbiAgICB0OiAgICAgICAgICAgICAgJ3QnLFxuICAgIHU6ICAgICAgICAgICAgICAndScsXG4gICAgdjogICAgICAgICAgICAgICd2JyxcbiAgICB3OiAgICAgICAgICAgICAgJ3cnLFxuICAgIHg6ICAgICAgICAgICAgICAneCcsXG4gICAgeTogICAgICAgICAgICAgICd5JyxcbiAgICB6OiAgICAgICAgICAgICAgJ3onLFxuICAgIE11bHRpcGx5TnVtcGFkOiAnKicsXG4gICAgUGx1c051bXBhZDogICAgICcrJyxcbiAgICBNaW51c051bXBhZDogICAgJy0nLFxuICAgIERvdE51bXBhZDogICAgICAnLicsXG4gICAgU2xhc2hOdW1wYWQ6ICAgICcvJyxcbiAgICBTZW1pY29sb246ICAgICAgJzsnLFxuICAgIEVxdWFsOiAgICAgICAgICAnPScsXG4gICAgQ29tbWE6ICAgICAgICAgICcsJyxcbiAgICBIeXBoZW46ICAgICAgICAgJy0nLFxuICAgIE1pbnVzOiAgICAgICAgICAnLScsXG4gICAgUGx1czogICAgICAgICAgICcrJyxcbiAgICBEb3Q6ICAgICAgICAgICAgJy4nLFxuICAgIFNsYXNoOiAgICAgICAgICAnLycsXG4gICAgQmFja3F1b3RlOiAgICAgICdgJyxcbiAgICBMZWZ0QnJhY2tldDogICAgJ1snLFxuICAgIFJpZ2h0QnJhY2tldDogICAnXScsXG4gICAgQmFja3NsYXNoOiAgICAgICdcXFxcJyxcbiAgICBRdW90ZTogICAgICAgICAgXCInXCIsXG59O1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgIC8vVE9ETyBUaGlzIHN1cmVseSBjYW4gYmUgaW1wcm92ZWQgYnkgbGV0dGluZyB3ZWJwYWNrIHRha2UgY2FyZSBvZiBnZW5lcmF0aW5nIHRoaXMgVU1EIHBhcnRcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xufSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xufVxufSgkID0+IHtcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyBudWxsXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyBudWxsLCBGQUxTRSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBGQUxTRSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCgwKSB8fCAnJyA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBpcyBhIFN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBib29sZWFuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgJ3RydWUnIG9yICdmYWxzZSdcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbnkgY2FzZXMgZm9yIHRob3NlIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUcnVlT3JGYWxzZVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsb3dlcmNhc2VWYWx1ZSA9IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyY2FzZVZhbHVlID09PSAndHJ1ZScgfHwgbG93ZXJjYXNlVmFsdWUgPT09ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVmZXJlbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QocmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2UgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGVtcHR5XG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0IGFuZCBodHRwOi8vanNwZXJmLmNvbS9lbXB0eS1vYmplY3QtdGVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG51bWJlciAob3IgYSBudW1iZXIgd3JpdHRlbiBhcyBhIHN0cmluZykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcihuKSB7XG4gICAgICAgIHJldHVybiAhaXNBcnJheShuKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBpbnRlZ2VyIChhbmQgbm90IGEgZmxvYXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnQobikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInICYmIHBhcnNlRmxvYXQobikgPT09IHBhcnNlSW50KG4sIDEwKSAmJiAhaXNOYU4obik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXN0ZWQgdGV4dCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ3x2b2lkfFhNTHwqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXBhcmVQYXN0ZWRUZXh0KHRleHQsIGhvbGRlcikge1xuICAgICAgICByZXR1cm4gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHRleHQsIGhvbGRlci5zZXR0aW5nc0Nsb25lLCB0cnVlKS5yZXBsYWNlKGhvbGRlci5zZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHN0cmluZyBgc3RyYCBjb250YWlucyB0aGUgc3RyaW5nIGBuZWVkbGVgXG4gICAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjb2VyY2UgdGhlIHBhcmFtZXRlcnMgdHlwZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmVlZGxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoc3RyLCBuZWVkbGUpIHtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8ICFpc1N0cmluZyhuZWVkbGUpIHx8IHN0ciA9PT0gJycgfHwgbmVlZGxlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgbmVlZGxlYCBpcyBpbiB0aGUgYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gbmVlZGxlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luQXJyYXkobmVlZGxlLCBhcnJheSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpIHx8IGFycmF5ID09PSBbXSB8fCBpc1VuZGVmaW5lZChuZWVkbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIEFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGFyclxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW10pID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIE1ha2Ugc3VyZSBhbiBhcnJheSBoYXMgYSBjbGFzcyBhdHRyaWJ1dGUgb2YgW29iamVjdCBBcnJheV1cbiAgICAgICAgICAgIC8vIFRlc3QgcGFzc2VkLCBub3cgY2hlY2sgaWYgaXMgYW4gQXJyYXlcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycikgfHwgKHR5cGVvZiBhcnIgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9TdHJpbmcgbWVzc2FnZSBjaGFuZ2VkIGZvciBPYmplY3QgQXJyYXknKTsgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cmluZyByZXR1cm5lZCBieSBgdG9TdHJpbmdgIGRvZXMgbm90IGNoYW5nZSBpbiB0aGUgZnV0dXJlIChjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODM2NTIxNSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmxvYXQgbnVtYmVyLCBhbmQgdGhhdCBudW1iZXIgaGFzIGEgZGVjaW1hbCBwYXJ0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgLy8gZnVuY3Rpb24gaGFzRGVjaW1hbHMoc3RyKSB7XG4gICAgLy8gICAgIGNvbnN0IFssIGRlY2ltYWxQYXJ0XSA9IHN0ci5zcGxpdCgnLicpO1xuICAgIC8vICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KTtcbiAgICAvLyB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7aW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY2ltYWxQbGFjZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IFssIGRlY2ltYWxQYXJ0XSA9IHN0ci5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxQYXJ0Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY29kZSBmb3IgdGhlIGtleSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnaXZlbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ3xOdW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5Q29kZU51bWJlcihldmVudCkge1xuICAgICAgICAvLyBgZXZlbnQua2V5Q29kZWAgYW5kIGBldmVudC53aGljaGAgYXJlIGRlcHJlY2F0ZWQsIGBLZXlib2FyZEV2ZW50LmtleWAgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleSkgbXVzdCBiZSB1c2VkIG5vd1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBldmVudC53aGljaCA9PT0gJ3VuZGVmaW5lZCcpP2V2ZW50LmtleUNvZGU6ZXZlbnQud2hpY2g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHZhbHVlIChhIG51bWJlciBhcyBhIHN0cmluZykgaXMgd2l0aGluIHRoZSByYW5nZSBzZXQgaW4gdGhlIHNldHRpbmdzIGBtaW5pbXVtVmFsdWVgIGFuZCBgbWF4aW11bVZhbHVlYCwgRkFMU0Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnNlZE1pblZhbHVlIFBhcnNlZCB2aWEgdGhlIGBwYXJzZVN0cigpYCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZWRNYXhWYWx1ZSBQYXJzZWQgdmlhIHRoZSBgcGFyc2VTdHIoKWAgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0lmSW5SYW5nZSh2YWx1ZSwgcGFyc2VkTWluVmFsdWUsIHBhcnNlZE1heFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VTdHIodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGVzdE1pbk1heChwYXJzZWRNaW5WYWx1ZSwgcGFyc2VkVmFsdWUpID4gLTEgJiYgdGVzdE1pbk1heChwYXJzZWRNYXhWYWx1ZSwgcGFyc2VkVmFsdWUpIDwgMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGEgbmVnYXRpdmUgc2lnbiBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBBIG51bWJlciByZXByZXNlbnRlZCBieSBhIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmVnYXRpdmUoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApID09PSAnLSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZWdhdGl2ZSB2ZXJzaW9uIG9mIHRoZSB2YWx1ZSAocmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcpIGdpdmVuIGFzIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UmF3TmVnYXRpdmVTaWduKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNOZWdhdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgLSR7dmFsdWV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgb3IgYSBzdHJpbmcgYXQgdGhlIGluZGV4IGdpdmVuICgwIGJlaW5nIHRoZSBmYXIgbGVmdCBzaWRlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICAgICAqIEBwYXJhbSB7aW50fSBjYXJldFBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRDaGFyQXRQb3NpdGlvbihzdHIsIGNoYXIsIGNhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGAke3N0ci5zbGljZSgwLCBjYXJldFBvc2l0aW9uKX0ke2NoYXJ9JHtzdHIuc2xpY2UoY2FyZXRQb3NpdGlvbil9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIHBvc2l0aW9uIGBpbmRleGAgaW4gdGhlIHN0cmluZyBgc3RyaW5nYCBieSB0aGUgY2hhcmFjdGVyKHMpIGBuZXdDaGFyYWN0ZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7aW50fSBpbmRleFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdDaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VDaGFyQXQoc3RyaW5nLCBpbmRleCwgbmV3Q2hhcmFjdGVyKSB7XG4gICAgICAgIHJldHVybiBgJHtzdHJpbmcuc3Vic3RyKDAsIGluZGV4KX0ke25ld0NoYXJhY3Rlcn0ke3N0cmluZy5zdWJzdHIoaW5kZXggKyBuZXdDaGFyYWN0ZXIubGVuZ3RoKX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgY2xhbXBlZCB0byB0aGUgbmVhcmVzdCBtaW5pbXVtL21heGltdW0gdmFsdWUsIGFzIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXBUb1JhbmdlTGltaXRzKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICAvL1hYWCBUaGlzIGZ1bmN0aW9uIGFsd2F5cyBhc3N1bWUgYHNldHRpbmdzLm1pbmltdW1WYWx1ZWAgaXMgbG93ZXIgdGhhbiBgc2V0dGluZ3MubWF4aW11bVZhbHVlYFxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBNYXRoLm1pbihzZXR0aW5ncy5tYXhpbXVtVmFsdWUsIHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbnVtYmVyIG9yIGRvdCBjaGFyYWN0ZXJzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGNhcmV0LCBpbiBhIGZvcm1hdHRlZCBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTnVtYmVyU3RyaW5nXG4gICAgICogQHBhcmFtIHtpbnR9IGNhcmV0UG9zaXRpb24gVGhpcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsQ2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoZm9ybWF0dGVkTnVtYmVyU3RyaW5nLCBjYXJldFBvc2l0aW9uLCBkZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgIC8vIEhlcmUgd2UgY291bnQgdGhlIGRvdCBhbmQgcmVwb3J0IGl0IGFzIGEgbnVtYmVyIGNoYXJhY3RlciB0b28sIHNpbmNlIGl0IHdpbGwgJ3N0YXknIGluIHRoZSBKYXZhc2NyaXB0IG51bWJlciB3aGVuIHVuZm9ybWF0dGVkXG4gICAgICAgIGNvbnN0IG51bWJlckRvdE9yTmVnYXRpdmVTaWduID0gbmV3IFJlZ0V4cChgWzAtOSR7ZGVjaW1hbENoYXJhY3Rlcn0tXWApOyAvLyBObyBuZWVkIHRvIGVzY2FwZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaGVyZSwgc2luY2UgaXQncyBpbiBgW11gXG5cbiAgICAgICAgbGV0IG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXJldFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFRlc3QgaWYgdGhlIGNoYXJhY3RlciBpcyBhIG51bWJlciwgYSBkb3Qgb3IgYW4gaHlwaGVuLiBJZiBpdCBpcywgY291bnQgaXQsIG90aGVyd2lzZSBpZ25vcmUgaXRcbiAgICAgICAgICAgIGlmIChudW1iZXJEb3RPck5lZ2F0aXZlU2lnbi50ZXN0KGZvcm1hdHRlZE51bWJlclN0cmluZ1tpXSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhbGsgdGhlIGBmb3JtYXR0ZWROdW1iZXJTdHJpbmdgIGZyb20gbGVmdCB0byByaWdodCwgb25lIGNoYXIgYnkgb25lLCBjb3VudGluZyB0aGUgYGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4YC5cbiAgICAgKiBJZiB0aGUgY2hhciBpcyBpbiB0aGUgYHJhd051bWJlclN0cmluZ2AgKHN0YXJ0aW5nIGF0IGluZGV4IDApLCB0aGVuIGByYXdOdW1iZXJTdHJpbmdJbmRleCsrYCwgYW5kIGNvbnRpbnVlIHVudGlsXG4gICAgICogdGhlcmUgaXMgbm8gbW9yZSBjaGFyYWN0ZXJzIGluIGByYXdOdW1iZXJTdHJpbmdgKSBvciB0aGF0IGByYXdOdW1iZXJTdHJpbmdJbmRleCA9PT0gY2FyZXRQb3NpdGlvbkluUmF3VmFsdWVgLlxuICAgICAqIFdoZW4geW91IHN0b3AsIHRoZSBgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhgIGlzIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgY2FyZXQgc2hvdWxkIGJlIHNldC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogMTIzNDU2N3w4OS4wMSAgIDogcG9zaXRpb24gNyAocmF3TnVtYmVyU3RyaW5nKVxuICAgICAqIDEyMy40NTYuN3w4OSwwMSA6IHBvc2l0aW9uIDkgKGZvcm1hdHRlZE51bWJlclN0cmluZylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByYXdOdW1iZXJTdHJpbmdcbiAgICAgKiBAcGFyYW0ge2ludH0gY2FyZXRQb3NpdGlvbkluUmF3VmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTnVtYmVyU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2ltYWxDaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyKHJhd051bWJlclN0cmluZywgY2FyZXRQb3NpdGlvbkluUmF3VmFsdWUsIGZvcm1hdHRlZE51bWJlclN0cmluZywgZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplID0gZm9ybWF0dGVkTnVtYmVyU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmF3TnVtYmVyU3RyaW5nU2l6ZSA9IHJhd051bWJlclN0cmluZy5sZW5ndGg7XG5cbiAgICAgICAgbGV0IGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4O1xuICAgICAgICBsZXQgcmF3TnVtYmVyU3RyaW5nSW5kZXggPSAwO1xuICAgICAgICBmb3IgKGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4ID0gMDtcbiAgICAgICAgICAgICBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCA8IGZvcm1hdHRlZE51bWJlclN0cmluZ1NpemUgJiZcbiAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCA8IHJhd051bWJlclN0cmluZ1NpemUgJiZcbiAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCA8IGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlO1xuICAgICAgICAgICAgIGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChyYXdOdW1iZXJTdHJpbmdbcmF3TnVtYmVyU3RyaW5nSW5kZXhdID09PSBmb3JtYXR0ZWROdW1iZXJTdHJpbmdbZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhdIHx8XG4gICAgICAgICAgICAgICAgKHJhd051bWJlclN0cmluZ1tyYXdOdW1iZXJTdHJpbmdJbmRleF0gPT09ICcuJyAmJiBmb3JtYXR0ZWROdW1iZXJTdHJpbmdbZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhdID09PSBkZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIHJhd051bWJlclN0cmluZ0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZG90ICcuJyBpbiB0aGUgZ2l2ZW4gdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3VudERvdHNJblRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gY291bnRDaGFySW5UZXh0KCcuJywgdGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ291bnQgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlIG9mIHRoZSBnaXZlbiBjaGFyYWN0ZXIsIGluIHRoZSBnaXZlbiB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3VudENoYXJJblRleHQoY2hhcmFjdGVyLCB0ZXh0KSB7XG4gICAgICAgIGxldCBjaGFyQ291bnRlciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRleHRbaV0gPT09IGNoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudGVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hhckNvdW50ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCB0aGUgY2FyZXQgcG9zaXRpb24uXG4gICAgICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhhdCB0aGUgcG9zaXRpb24gaXMgc3RhcnRpbmcgYXQgJzAnLCBub3QgMS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW50fSBjaGFyYWN0ZXJDb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNoYXJhY3RlckNvdW50KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjaGFyYWN0ZXJDb3VudCwgY2hhcmFjdGVyQ291bnQgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIGdldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEV2ZW50VGFyZ2V0fSB0aGF0XG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3Rpb24odGhhdCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gc2VsZWN0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgc2VsZWN0Lm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLXRoYXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSB0aGF0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gdGhhdC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIHNldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEV2ZW50VGFyZ2V0fSB0aGF0XG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0XG4gICAgICogQHBhcmFtIHtpbnR8bnVsbH0gZW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudFNlbGVjdGlvbih0aGF0LCBzdGFydCwgZW5kID0gbnVsbCkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWRPck51bGxPckVtcHR5KGVuZCkpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoYXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHRocm93IGVycm9yIG1lc3NhZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBkaXNwbGF5IGEgd2FybmluZyBtZXNzYWdlcywgYWNjb3JkaW5nIHRvIHRoZSBkZWJ1ZyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaG93V2FybmluZyBJZiBGQUxTRSwgdGhlbiB0aGUgd2FybmluZyBtZXNzYWdlIGlzIG5vdCBkaXNwbGF5ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UsIHNob3dXYXJuaW5nID0gdHJ1ZSkge1xuICAgICAgICBpZiAoc2hvd1dhcm5pbmcpIHtcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF1dG9OdW1lcmljLXNwZWNpZmljIGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogUnVuIGFueSBjYWxsYmFja3MgZm91bmQgaW4gdGhlIHNldHRpbmdzIG9iamVjdC5cbiAgICAgKiBBbnkgcGFyYW1ldGVyIGNvdWxkIGJlIGEgY2FsbGJhY2s6XG4gICAgICogLSBhIGZ1bmN0aW9uLCB3aGljaCBpbnZva2VkIHdpdGggalF1ZXJ5IGVsZW1lbnQsIHBhcmFtZXRlcnMgYW5kIHRoaXMgcGFyYW1ldGVyIG5hbWUgYW5kIHJldHVybnMgcGFyYW1ldGVyIHZhbHVlXG4gICAgICogLSBhIG5hbWUgb2YgZnVuY3Rpb24sIGF0dGFjaGVkIHRvICQoc2VsZWN0b3IpLmF1dG9OdW1lcmljLmZ1bmN0aW9uTmFtZSgpe30gLSB3aGljaCB3YXMgY2FsbGVkIHByZXZpb3VzbHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0KCR0aGlzLCBzZXR0aW5ncykge1xuICAgICAgICAvLyBMb29wcyB0aHJvdWdoIHRoZSBzZXR0aW5ncyBvYmplY3QgKG9wdGlvbiBhcnJheSkgdG8gZmluZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICQuZWFjaChzZXR0aW5ncywgKGssIHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trXSA9IHZhbCgkdGhpcywgc2V0dGluZ3MsIGspO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgJHRoaXMuYXV0b051bWVyaWNbdmFsXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIENhbGxzIHRoZSBhdHRhY2hlZCBmdW5jdGlvbiBmcm9tIHRoZSBodG1sNSBkYXRhIGV4YW1wbGU6IGRhdGEtYS1zaWduPVwiZnVuY3Rpb25OYW1lXCJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trXSA9ICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0oJHRoaXMsIHNldHRpbmdzLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBtYXhpbXVtIGRlY2ltYWwgbGVuZ3RoIGZyb20gdGhlIG1pbmltdW1WYWx1ZSBhbmQgbWF4aW11bVZhbHVlIHNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWluaW11bVZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1heGltdW1WYWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChtaW5pbXVtVmFsdWUsIG1heGltdW1WYWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZGVjaW1hbFBsYWNlcyhtaW5pbXVtVmFsdWUpLCBkZWNpbWFsUGxhY2VzKG1heGltdW1WYWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0cmlwIGFsbCB1bndhbnRlZCBub24tbnVtYmVyIGNoYXJhY3RlcnMgYW5kIGxlYXZlIG9ubHkgYSBudW1iZXIgYWxlcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsZWZ0T3JBbGxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMocywgc2V0dGluZ3MsIGxlZnRPckFsbCkge1xuICAgICAgICBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5zdWZmaXhUZXh0KSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgc3VmZml4XG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbnMocywgc2V0dGluZ3Muc3VmZml4VGV4dCkpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnN1ZmZpeFRleHQsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0IHJlcGxhY2UgYW55dGhpbmcgYmVmb3JlIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCwgJyQxJDInKTtcblxuICAgICAgICBpZiAoKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycgfHwgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJykpICYmIGNvbnRhaW5zKHMsICctJykgJiYgcyAhPT0gJycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlbiByZXBsYWNlIGFueXRoaW5nIGFmdGVyIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwLCAnJDEnKTtcblxuICAgICAgICAvLyBUaGVuIHJlbW92ZSBhbnkgdW5pbnRlcmVzdGluZyBjaGFyYWN0ZXJzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCwgJycpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSwgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgb25seSBudW1iZXIgc3RyaW5nXG4gICAgICAgIGNvbnN0IG0gPSBzLm1hdGNoKHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCk7XG4gICAgICAgIHMgPSBtID8gW21bMV0sIG1bMl0sIG1bM11dLmpvaW4oJycpIDogJyc7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnYWxsb3cnIHx8IHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAna2VlcCcpIHtcbiAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkSW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgIGlmIChjb250YWlucyhtb2RpZmllZEludGVnZXJQYXJ0LCBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgblNpZ24gPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQucmVwbGFjZShzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50UG9zICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiAhPT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50TmVnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcyA9IGAke25TaWdufSR7bW9kaWZpZWRJbnRlZ2VyUGFydH0ke2lzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KT8nJzpzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICsgZGVjaW1hbFBhcnR9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobGVmdE9yQWxsICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnZGVueScpIHx8XG4gICAgICAgICAgICAoIXNldHRpbmdzLm9uT2ZmICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSAnYWxsb3cnKSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdHJpcFJlZywgJyQxJDInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgcmVtb3ZlcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMsIGRlcGVuZGluZyBvbiB0aGUgZm9jdXMgc3RhdGUuXG4gICAgICogVGhlIGZvY3VzIHN0YXRlIGlzICdzdG9yZWQnIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgdW5kZXIgdGhlIGBzZXR0aW5ncy5vbk9mZmAgYXR0cmlidXRlLiAvL1RPRE8gVXNlIGFub3RoZXIgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgaW50ZXJuYWwgZGF0YSB0aGF0IGFyZSBub3Qgc2V0dGluZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICgoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSB8fCAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3AnKSkge1xuICAgICAgICAgICAgY29uc3QgW2ZpcnN0QnJhY2tldCwgbGFzdEJyYWNrZXRdID0gc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub25PZmYpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJycpO1xuICAgICAgICAgICAgICAgIHMgPSBmaXJzdEJyYWNrZXQgKyBzICsgbGFzdEJyYWNrZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uT2ZmICYmIHMuY2hhckF0KDApID09PSBmaXJzdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGZpcnN0QnJhY2tldCwgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGxhc3RCcmFja2V0LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGxvY2FsZSBmb3JtYXQgdG8gSmF2YXNjcmlwdCBudW1lcmljIHN0cmluZ1xuICAgICAqIEFsbG93cyBsb2NhbGUgZGVjaW1hbCBzZXBhcmF0b3IgdG8gYmUgYSBwZXJpb2Qgb3IgYSBjb21tYSAtIG5vIHRob3VzYW5kIHNlcGFyYXRvciBhbGxvd2VkIG9mIGN1cnJlbmN5IHNpZ25zIGFsbG93ZWRcbiAgICAgKiAnMTIzNC41NicgICAgT0tcbiAgICAgKiAnLTEyMzQuNTYnICAgT0tcbiAgICAgKiAnMTIzNC41Ni0nICAgT0tcbiAgICAgKiAnMTIzNCw1NicgICAgT0tcbiAgICAgKiAnLTEyMzQsNTYnICAgT0tcbiAgICAgKiAnMTIzNCw1Ni0nICAgT0tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHJldHVybnMge3N0cmluZ3x2b2lkfFhNTHwqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21Mb2NhbGUocykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHMsICctJykgJiYgcy5sYXN0SW5kZXhPZignLScpID09PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICBzID0gJy0nICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBJU08gbnVtZXJpYyBzdHJpbmcgdG8gdGhlIGxvY2FsZSBkZWNpbWFsIGFuZCBtaW51cyBzaWduIHBsYWNlbWVudC5cbiAgICAgKiBTZWUgdGhlIFwib3V0cHV0Rm9ybWF0XCIgb3B0aW9uIGRlZmluaXRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG9jYWxlKHZhbHVlLCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKGlzTnVsbChsb2NhbGUpIHx8IGxvY2FsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHN3aXRjaCAobG9jYWxlKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcuLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29udGFpbnModmFsdWUsICctJykgPyB2YWx1ZS5yZXBsYWNlKCctJywgJycpICsgJy0nIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIGNhc2UgJy0sJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJywtJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb250YWlucyhyZXN1bHQsICctJykgPyByZXN1bHQucmVwbGFjZSgnLScsICcnKSArICctJyA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGNhc2VcbiAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgY2FzZSAnLS4nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGdpdmVuIG91dHB1dEZvcm1hdCBbJHtsb2NhbGV9XSBvcHRpb24gaXMgbm90IHJlY29nbml6ZWQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIG9mIHRoZSBnaXZlbiBzdHJpbmcgdmFsdWUgdG8gYW4gaHlwaGVuICgtKSBhbmQgYSBkb3QgKC4pIGluIG9yZGVyIHRvIG1ha2UgdGhhdCB2YWx1ZSAndHlwZWNhc3RhYmxlJyB0byBhIHJlYWwgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZShzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJy0nICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnLScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcy5tYXRjaCgvXFxkLykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHJldHVybmVkIGJ5IGBnZXRgIGlzIGZvcm1hdHRlZCB3aXRoIGRlY2ltYWxzXG4gICAgICAgICAgICBzICs9ICcwLjAwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIHRvIHVzZSB0aG9zZSBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJy0nICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy4nLCBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgZnVuY3Rpb24gdG8gY2hlY2sgZm9yIGVtcHR5IHZhbHVlXG4gICAgICogLy9UT0RPIE1vZGlmeSB0aGlzIGZ1bmN0aW9uIHNvIHRoYXQgaXQgcmV0dXJuIGVpdGhlciBUUlVFIG9yIEZBTFNFIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eS4gVGhlbiBjcmVhdGUgYW5vdGhlciBmdW5jdGlvbiB0byByZXR1cm4gdGhlIGlucHV0IHZhbHVlIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpZ25PbkVtcHR5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tFbXB0eShpbnB1dFZhbHVlLCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09ICcnIHx8IGlucHV0VmFsdWUgPT09IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2Fsd2F5cycgfHwgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpID8gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgc2V0dGluZ3Muc3VmZml4VGV4dCA6IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZSArIHNldHRpbmdzLnN1ZmZpeFRleHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBpbnB1dCB2YWx1ZSBieSBhZGRpbmcgdGhlIGdyb3VwIHNlcGFyYXRvcnMsIGFzIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRHcm91cFNlcGFyYXRvcnMoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGlucHV0VmFsdWUsIHNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMoaW5wdXRWYWx1ZSwgJy0nKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9ICctJyArIGlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbXB0eSA9IGNoZWNrRW1wdHkoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICBjb25zdCBpc05lZ2F0aXZlID0gY29udGFpbnMoaW5wdXRWYWx1ZSwgJy0nKTtcbiAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChlbXB0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcgPSBzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBkaWdpdGFsR3JvdXA7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZykge1xuICAgICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGQpKFxcZHsyfT8pKykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzJzJzpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKD86XFxkezJ9KXswLDJ9XFxkezN9KD86KD86XFxkezJ9KXsyfVxcZHszfSkqPykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezR9PykrKSQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7M30/KSspJC87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGxpdHMgdGhlIHN0cmluZyBhdCB0aGUgZGVjaW1hbCBzdHJpbmdcbiAgICAgICAgbGV0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAmJiBpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBSZS1pbnNlcnRzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdmlhIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRhbEdyb3VwLnRlc3QoaW50ZWdlclBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydC5yZXBsYWNlKGRpZ2l0YWxHcm91cCwgYCQxJHtzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yfSQyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlICE9PSAwICYmICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKb2lucyB0aGUgd2hvbGUgbnVtYmVyIHdpdGggdGhlIGRlY2ltYWwgdmFsdWVcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnRlZ2VyUGFydCArIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgKyBkZWNpbWFsUGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiBpdCdzIGFuIGludGVnZXJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUgKyBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBpbnB1dFZhbHVlICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgcGxhY2VzIGJyYWNrZXRzXG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiAoc2V0dGluZ3MucmF3VmFsdWUgPCAwIHx8IGlucHV0VmFsdWUuY2hhckF0KDApID09PSAnLScpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KGlucHV0VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5zdWZmaXhUZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlIG5vdCBuZWVkZWQgemVyb3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb3VuZGVkSW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7aW50fSB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZHxYTUx8c3RyaW5nfCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVaZXJvcyhyb3VuZGVkSW5wdXRWYWx1ZSwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgIGxldCByZWdleDtcbiAgICAgICAgc3dpdGNoICh0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBwYWRkaW5nIC0gcmVtb3ZlcyB0cmFpbGluZyB6ZXJvcyB1bnRpbCB0aGUgZmlyc3Qgc2lnbmlmaWNhbnQgZGlnaXQgaXMgZW5jb3VudGVyZWRcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvLyBBbGxvd3MgcGFkZGluZyB3aGVuIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBlcXVhbHMgb25lIC0gbGVhdmVzIG9uZSB6ZXJvIHRyYWlsaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC5cXGQoPzpcXGQqWzEtOV0pPykwKiQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlcyBhY2Nlc3MgemVyb3MgdG8gdGhlIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBsZW5ndGggd2hlbiBhbGxvd0RlY2ltYWxQYWRkaW5nIGlzIHNldCB0byB0cnVlXG4gICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKGAoXFxcXC5cXFxcZHske3RlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZX19KD86XFxcXGQqWzEtOV0pPykwKmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlY2ltYWwgcGxhY2VzLCB3ZSBkb24ndCBuZWVkIGEgZGVjaW1hbCBwb2ludCBhdCB0aGUgZW5kXG4gICAgICAgIHJvdW5kZWRJbnB1dFZhbHVlID0gcm91bmRlZElucHV0VmFsdWUucmVwbGFjZShyZWdleCwgJyQxJyk7XG4gICAgICAgIGlmICh0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPT09IDApIHtcbiAgICAgICAgICAgIHJvdW5kZWRJbnB1dFZhbHVlID0gcm91bmRlZElucHV0VmFsdWUucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3VuZGVkSW5wdXRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZCB0aGUgaW5wdXQgdmFsdWUgdXNpbmcgdGhlIHJvdW5kaW5nIG1ldGhvZCBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgbXVsdGlwbGUgcm91bmRpbmcgbWV0aG9kcy4gU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGRldGFpbHMgYWJvdXQgdGhvc2UuXG4gICAgICpcbiAgICAgKiBOb3RlIDogVGhpcyBpcyBoYW5kbGVkIGFzIHRleHQgc2luY2UgSmF2YVNjcmlwdCBtYXRoIGZ1bmN0aW9uIGNhbiByZXR1cm4gaW5hY2N1cmF0ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdW5kVmFsdWUoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgaW5wdXRWYWx1ZSA9IChpbnB1dFZhbHVlID09PSAnJykgPyAnMCcgOiBpbnB1dFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ04wNScgfHwgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdDSEYnIHx8IHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnVTA1JyB8fCBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0QwNScpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mucm91bmRpbmdNZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdOMDUnOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGgucm91bmQoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdVMDUnOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguY2VpbChpbnB1dFZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguZmxvb3IoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFjb250YWlucyhpbnB1dFZhbHVlLCAnLicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZSArICcuMDAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFZhbHVlLmxlbmd0aCAtIGlucHV0VmFsdWUuaW5kZXhPZignLicpIDwgMykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyAnMCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl2Um91bmRlZCA9ICcnO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICBsZXQgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuXG4gICAgICAgIC8vIHNldHMgdGhlIHRydW5jYXRlIHplcm8gbWV0aG9kXG4gICAgICAgIGlmIChzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nKSB7XG4gICAgICAgICAgICB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBpbnB1dFZhbHVlIChpbnB1dCBWYWx1ZSkgaXMgYSBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICBpZiAoaW5wdXRWYWx1ZS5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgblNpZ24gPSAnLSc7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gdGhhdCB3aWxsIGJlIGFkZGVkIGJhY2sgbGF0ZXIgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBlbmQgYSB6ZXJvIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGEgZGlnaXQgKHRoZW4gaXQgaXMgbGlrZWx5IHRvIGJlIGEgZG90KVxuICAgICAgICBpZiAoIWlucHV0VmFsdWUubWF0Y2goL15cXGQvKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9ICcwJyArIGlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBlcXVhbCB0byB6ZXJvLiBJZiBpdCBpcywgcmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduXG4gICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIE51bWJlcihpbnB1dFZhbHVlKSA9PT0gMCkge1xuICAgICAgICAgICAgblNpZ24gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaW1zIGxlYWRpbmcgemVybydzIGFzIG5lZWRlZFxuICAgICAgICBpZiAoKE51bWJlcihpbnB1dFZhbHVlKSA+IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykgfHwgKGlucHV0VmFsdWUubGVuZ3RoID4gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JykpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoL14wKihcXGQpLywgJyQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkUG9zID0gaW5wdXRWYWx1ZS5sYXN0SW5kZXhPZignLicpO1xuICAgICAgICBjb25zdCBpbnB1dFZhbHVlSGFzQURvdCA9IGRQb3MgPT09IC0xO1xuXG4gICAgICAgIC8vIFZpcnR1YWwgZGVjaW1hbCBwb3NpdGlvblxuICAgICAgICBjb25zdCB2ZFBvcyA9IGlucHV0VmFsdWVIYXNBRG90ID8gaW5wdXRWYWx1ZS5sZW5ndGggLSAxIDogZFBvcztcblxuICAgICAgICAvLyBDaGVja3MgZGVjaW1hbCBwbGFjZXMgdG8gZGV0ZXJtaW5lIGlmIHJvdW5kaW5nIGlzIHJlcXVpcmVkIDpcbiAgICAgICAgLy8gQ2hlY2sgaWYgbm8gcm91bmRpbmcgaXMgcmVxdWlyZWRcbiAgICAgICAgbGV0IGNEZWMgPSAoaW5wdXRWYWx1ZS5sZW5ndGggLSAxKSAtIHZkUG9zO1xuXG4gICAgICAgIGlmIChjRGVjIDw9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBwYWQgd2l0aCB6ZXJvc1xuICAgICAgICAgICAgaXZSb3VuZGVkID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChjRGVjIDwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWVIYXNBRG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB6ZXJvcyA9ICcwMDAwMDAnO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjRGVjIDwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHplcm9zID0gemVyb3Muc3Vic3RyaW5nKDAsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSAtIGNEZWMpO1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gemVyb3M7XG4gICAgICAgICAgICAgICAgICAgIGNEZWMgKz0gemVyb3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA+IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZSb3VuZGVkLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID09PSAwICYmIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm91bmRlZCBsZW5ndGggb2YgdGhlIHN0cmluZyBhZnRlciByb3VuZGluZ1xuICAgICAgICBsZXQgckxlbmd0aDtcbiAgICAgICAgaWYgKGlucHV0VmFsdWVIYXNBRG90KSB7XG4gICAgICAgICAgICByTGVuZ3RoID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJMZW5ndGggPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgKyBkUG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdFJvdW5kID0gTnVtYmVyKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGggKyAxKSk7XG4gICAgICAgIGNvbnN0IG9kZCA9IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSA9PT0gJy4nKSA/IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSAlIDIpO1xuICAgICAgICBsZXQgaXZBcnJheSA9IGlucHV0VmFsdWUuc3Vic3RyaW5nKDAsIHJMZW5ndGggKyAxKS5zcGxpdCgnJyk7XG5cbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnUycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiB1cCBzeW1tZXRyaWNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ3MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBzeW1tZXRyaWNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnYScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ2EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdCJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGV2ZW4gXCJCYW5rZXIncyBSb3VuZGluZ1wiXG4gICAgICAgICAgICAodFJvdW5kID09PSA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQicgJiYgb2RkID09PSAxKSAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQycgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgdG8gY2VpbGluZyB0b3dhcmQgcG9zaXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnRicgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgdG8gZmxvb3IgdG93YXJkIG5lZ2F0aXZlIGluZmluaXRlXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ1UnKSkgeyAgICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIGF3YXkgZnJvbSB6ZXJvXG4gICAgICAgICAgICAvLyBSb3VuZCB1cCB0aGUgbGFzdCBkaWdpdCBpZiByZXF1aXJlZCwgYW5kIGNvbnRpbnVlIHVudGlsIG5vIG1vcmUgOSdzIGFyZSBmb3VuZFxuICAgICAgICAgICAgZm9yIChpID0gKGl2QXJyYXkubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl2QXJyYXlbaV0gIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gK2l2QXJyYXlbaV0gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXG4gICAgICAgIGl2QXJyYXkgPSBpdkFycmF5LnNsaWNlKDAsIHJMZW5ndGggKyAxKTtcblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJvdW5kZWQgdmFsdWVcbiAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdkFycmF5LmpvaW4oJycpLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuXG4gICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQYXN0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlRGVjaW1hbChzLCBzZXR0aW5ncywgaXNQYXN0ZSkge1xuICAgICAgICBzID0gKGlzUGFzdGUpID8gcm91bmRWYWx1ZShzLCBzZXR0aW5ncykgOiBzO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICYmIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQgJiYgZGVjaW1hbFBhcnQubGVuZ3RoID4gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWREZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgICAgICBzID0gYCR7aW50ZWdlclBhcnR9JHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSBtaW5pbXVtVmFsdWUsIG1heGltdW1WYWx1ZSAmIHRoZSBpbnB1dCB2YWx1ZSB0byBwcmVwYXJlIGZvciB0ZXN0aW5nIHRvIGRldGVybWluZSBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gLyBtYXggcmFuZ2UuXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBleGFtcGxlOiBtaW5pbXVtVmFsdWU6IFwiOTk5OTk5OTk5OTk5OTk5Ljk5XCIgcmV0dXJucyB0aGUgZm9sbG93aW5nIFwie3M6IC0xLCBlOiAxMiwgYzogQXJyYXlbMTVdfVwiLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy8uIE1hbnkgdGhhbmtzIHRvIE1pa2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG4gQSBudW1lcmljIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XG4gICAgICAgIGNvbnN0IHggPSB7fTsgLy8gQSBCaWcgbnVtYmVyIGluc3RhbmNlLlxuICAgICAgICBsZXQgZTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBuTDtcbiAgICAgICAgbGV0IGo7XG5cbiAgICAgICAgLy8gTWludXMgemVybz9cbiAgICAgICAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSB7XG4gICAgICAgICAgICBuID0gJy0wJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBzaWduLiAxIHBvc2l0aXZlLCAtMSBuZWdhdGl2ZVxuICAgICAgICBuID0gbi50b1N0cmluZygpO1xuICAgICAgICBpZiAobi5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgbiA9IG4uc2xpY2UoMSk7XG4gICAgICAgICAgICB4LnMgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgucyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xuICAgICAgICBlID0gbi5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChlID4gLTEpIHtcbiAgICAgICAgICAgIG4gPSBuLnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZW5ndGggb2Ygc3RyaW5nIGlmIG5vIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgIGlmIChlIDwgMCkge1xuICAgICAgICAgICAgLy8gSW50ZWdlclxuICAgICAgICAgICAgZSA9IG4ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3NcbiAgICAgICAgaSA9IChuLnNlYXJjaCgvWzEtOV0vaSkgPT09IC0xKSA/IG4ubGVuZ3RoIDogbi5zZWFyY2goL1sxLTldL2kpO1xuICAgICAgICBuTCA9IG4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSA9PT0gbkwpIHtcbiAgICAgICAgICAgIC8vIFplcm9cbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmMgPSBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgIGZvciAoaiA9IG5MIC0gMTsgbi5jaGFyQXQoaikgPT09ICcwJzsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgbkwgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5MIC09IDE7XG5cbiAgICAgICAgICAgIC8vIERlY2ltYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHguZSA9IGUgLSBpIC0gMTtcbiAgICAgICAgICAgIHguYyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBhcnJheSBvZiBkaWdpdHMgd2l0aG91dCBsZWFkaW5nL3RyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGUgPSAwOyBpIDw9IG5MOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB4LmNbZV0gPSArbi5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gdGVzdCBpZiB0aGUgaW5wdXQgdmFsdWUgZmFsbHMgd2l0aCB0aGUgTWluIC8gTWF4IHNldHRpbmdzLlxuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvLiBNYW55IHRoYW5rcyB0byBNaWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHkgQmlnIG51bWJlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB4IEJpZyBudW1iZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZXN0TWluTWF4KHksIHgpIHtcbiAgICAgICAgY29uc3QgeGMgPSB4LmM7XG4gICAgICAgIGNvbnN0IHljID0geS5jO1xuICAgICAgICBsZXQgaSA9IHgucztcbiAgICAgICAgbGV0IGogPSB5LnM7XG4gICAgICAgIGxldCBrID0geC5lO1xuICAgICAgICBsZXQgbCA9IHkuZTtcblxuICAgICAgICAvLyBFaXRoZXIgemVybz9cbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoIXhjWzBdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gIXljWzBdPzA6LWo7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xuICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeE5lZyA9IGkgPCAwO1xuXG4gICAgICAgIC8vIENvbXBhcmUgZXhwb25lbnRzXG4gICAgICAgIGlmIChrICE9PSBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGsgPiBsIF4geE5lZyk/MTotMTtcbiAgICAgICAgfVxuICAgICAgICBpID0gLTE7XG4gICAgICAgIGsgPSB4Yy5sZW5ndGg7XG4gICAgICAgIGwgPSB5Yy5sZW5ndGg7XG4gICAgICAgIGogPSAoayA8IGwpID8gayA6IGw7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdFxuICAgICAgICBmb3IgKGkgKz0gMTsgaSA8IGo7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHhjW2ldICE9PSB5Y1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoeGNbaV0gPiB5Y1tpXSBeIHhOZWcpPzE6LTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIGxlbmd0aHNcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKGsgPT09IGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBudW1iZXIgc2F0aXNmeSB0aGUgZm9ybWF0IGNvbmRpdGlvbnNcbiAgICAgKiBhbmQgbGF5cyBiZXR3ZWVuIHNldHRpbmdzLm1pbmltdW1WYWx1ZSBhbmQgc2V0dGluZ3MubWF4aW11bVZhbHVlXG4gICAgICogYW5kIHRoZSBzdHJpbmcgbGVuZ3RoIGRvZXMgbm90IGV4Y2VlZCB0aGUgZGlnaXRzIGluIHNldHRpbmdzLm1pbmltdW1WYWx1ZSBhbmQgc2V0dGluZ3MubWF4aW11bVZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIHMgPSBzLnRvU3RyaW5nKCk7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBjb25zdCBtaW5QYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLm1pbmltdW1WYWx1ZSk7XG4gICAgICAgIGNvbnN0IG1heFBhcnNlID0gcGFyc2VTdHIoc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm92ZXJyaWRlTWluTWF4TGltaXRzKSB7XG4gICAgICAgICAgICBjYXNlICdmbG9vcic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlaWxpbmcnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGFua3MgdG8gQW50aG9ueSAmIEV2YW4gQ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeXxIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgKGFuZCB0aGVyZWZvcmUgaXMgYSBDU1Mgc2VsZWN0b3IpLCB0aGVuIHdlIG5lZWQgdG8gbW9kaWZ5IHRoaXMgc3RyaW5nIGluIG9yZGVyXG4gICAgICAgICAqIGZvciBqUXVlcnkgdG8gYmUgYWJsZSB0byBwYXJzZSB0aGUgc2VsZWN0b3IgY29ycmVjdGx5LlxuICAgICAgICAgKiBjZi4gaHR0cDovL2xlYXJuLmpxdWVyeS5jb20vdXNpbmctanF1ZXJ5LWNvcmUvZmFxL2hvdy1kby1pLXNlbGVjdC1hbi1lbGVtZW50LWJ5LWFuLWlkLXRoYXQtaGFzLWNoYXJhY3RlcnMtdXNlZC1pbi1jc3Mtbm90YXRpb24vXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNTdHJpbmcoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGJsb2NrIGlzIGFwcGFyZW50bHkgbmV2ZXIgZW50ZXJlZC4gV2Ugc2hvdWxkIHJlbW92ZSBpdCBhZnRlciBtYWtpbmcgc3VyZSB0aGF0J3MgMTAwJSB0aGUgY2FzZVxuICAgICAgICAgICAgZWxlbWVudCA9IGAjJHtlbGVtZW50LnJlcGxhY2UoLyg6fFxcLnxcXFt8XXwsfD0pL2csICdcXFxcJDEnKX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBhdHRhY2ggdGhlIGF1dG9OdW1lcmljIGZpZWxkIHByb3BlcnRpZXMgdG8gdGhlIERPTSBlbGVtZW50IHZpYSBhbiBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBdXRvTnVtZXJpY0hvbGRlcigkdGhpcywgc2V0dGluZ3MsIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBkYXRhID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhvbGRlciA9IGRhdGEuaG9sZGVyO1xuICAgICAgICBpZiAodXBkYXRlIHx8IChpc1VuZGVmaW5lZChob2xkZXIpICYmIHNldHRpbmdzKSkge1xuICAgICAgICAgICAgaG9sZGVyID0gbmV3IEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLmdldCgwKSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgZGF0YS5ob2xkZXIgPSBob2xkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICYgbm9TZXBhcmF0b3JPbkZvY3VzIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWQuXG4gICAgICogVGhvc2Ugb3JpZ2luYWwgc2V0dGluZ3MgYXJlIHVzZWQgZXhjbHVzaXZlbHkgaW4gdGhlIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtlZXBBbk9yaWdpbmFsU2V0dGluZ3NDb3B5KHNldHRpbmdzKSB7XG4gICAgICAgIC8vVE9ETyBSZW5hbWUgdGhlIG9sZCBvcHRpb24gbmFtZXMgdG8gdGhlIG5ldyBvbmVzXG4gICAgICAgIHNldHRpbmdzLm9EZWMgICAgID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICBzZXR0aW5ncy5vUGFkICAgICA9IHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmc7XG4gICAgICAgIHNldHRpbmdzLm9CcmFja2V0ID0gc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXI7XG4gICAgICAgIHNldHRpbmdzLm9TZXAgICAgID0gc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvcjtcbiAgICAgICAgc2V0dGluZ3Mub1NpZ24gICAgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgc2V0dGluZ3Mub1N1ZmZpeCAgPSBzZXR0aW5ncy5zdWZmaXhUZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c2AgJiBgbm9TZXBhcmF0b3JPbkZvY3VzYCBvcHRpb25zIGFyZSBiZWluZyB1c2VkLlxuICAgICAqIFRoaXMgaXMgdGFrZW4gZnJvbSBRdWlya3Ntb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkQ29va2llKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgc2Vzc2lvblN0b3JhZ2UgaXMgc3VwcG9ydGVkLlxuICAgICAqIFRoaXMgaXMgdGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yYWdlVGVzdCgpIHtcbiAgICAgICAgY29uc3QgbW9kID0gJ21vZGVybml6cic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiB3aGF0IHRoZSBicm93c2VyIGlzIHN1cHBvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShlbGVtZW50LCBzZXR0aW5ncywgYWN0aW9uKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWROYW1lID0gKGVsZW1lbnQubmFtZSAhPT0gJycgJiYgIWlzVW5kZWZpbmVkKGVsZW1lbnQubmFtZSkpID9gQVVUT18ke2RlY29kZVVSSUNvbXBvbmVudChlbGVtZW50Lm5hbWUpfWAgOmBBVVRPXyR7ZWxlbWVudC5pZH1gO1xuICAgICAgICAgICAgbGV0IGRhdGU7XG4gICAgICAgICAgICBsZXQgZXhwaXJlcztcblxuICAgICAgICAgICAgLy8gU2V0cyBjb29raWUgZm9yIGJyb3dzZXIgdGhhdCBkbyBub3Qgc3VwcG9ydCBzZXNzaW9uU3RvcmFnZSBJRSA2ICYgSUUgN1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VUZXN0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PSR7c2V0dGluZ3MucmF3VmFsdWV9OyBleHBpcmVzPSA7IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgtMSAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIE5vdGUgOiBgdG9HTVRTdHJpbmcoKWAgaGFzIGJlZW4gZGVwcmVjYXRlZCAoY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9HTVRTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0nJyA7JHtleHBpcmVzfTsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb29raWUoc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yZWROYW1lLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb2xkZXIgb2JqZWN0IGZvciBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgY2xhc3MgQXV0b051bWVyaWNIb2xkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGhhdCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IERPTSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGhhdCwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgICAgICAgICB0aGlzLiR0aGF0ID0gJCh0aGF0KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzQ2xvbmUgPSBzZXR0aW5ncztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGF0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgdmFsdWUgYW5kIHRoZSBzZWxlY3Rpb24gdmFsdWVzIGluc2lkZSB0aGUgQXV0b051bWVyaWNIb2xkZXIgb2JqZWN0LlxuICAgICAgICAgKiBUaGlzIGtlZXBzIHRyYWNrcyBvZiB0aGUgaW5wdXQgdmFsdWUsIGFzIHdlbGwgYXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBUaGlzIGFsc28gcmVzZXRzIHRoZSAncHJvY2Vzc2VkJyBhbmQgJ2Zvcm1hdHRlZCcgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgOiBUaG9zZSB0d28gY2FuIGNoYW5nZSBiZXR3ZWVuIHRoZSBrZXlkb3duLCBrZXlwcmVzcyBhbmQga2V5dXAgZXZlbnRzLCB0aGF0J3Mgd2h5XG4gICAgICAgICAqICAgICAgICB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZ2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBrZXljb2RlIG9mIHRoZSBrZXkgdGhhdCB0cmlnZ2VyZWQgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAgICAgKiBOb3RlIDogZS53aGljaCBpcyBzb21ldGltZXMgZGlmZmVyZW50IHRoYW4gZS5rZXlDb2RlIGR1cmluZyB0aGUga2V5cHJlc3MgZXZlbnQsIHdoZW4gZW50ZXJpbmcgYSBwcmludGFibGUgY2hhcmFjdGVyIGtleSAoaWUuICd0JykuIGBlLndoaWNoYCBlcXVhbHMgMCBmb3Igbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAvL1RPRE8gU3dpdGNoIHRvIHRoZSBub24tZGVwcmVjYXRlZCBlLmtleSBhdHRyaWJ1dGUsIGluc3RlYWQgb2YgaW5jb25zaXN0YW50IGUud2hpY2ggYW5kIGUua2V5Q29kZS5cbiAgICAgICAgICogZS5rZXkgZGVzY3JpYmUgdGhlIGtleSBuYW1lIHVzZWQgdG8gdHJpZ2dlciB0aGUgZXZlbnQuXG4gICAgICAgICAqIGUua2V5Q29kZSBiZWluZyBkZXByZWNhdGVkIDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5Q29kZVxuICAgICAgICAgICAgICogSG93IGUua2V5IHdvcmtzIDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5XG4gICAgICAgICAqIFRoZSBrZXkgbGlzdCBpcyBkZXNjcmliZWQgaGVyZVxuICAgICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkvS2V5X1ZhbHVlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJFdmVudEtleWNvZGUoZSkge1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlIGtleXByZXNzIGV2ZW50IG92ZXJ3cml0ZXMgbWVhbmluZ2Z1bCB2YWx1ZSBvZiBlLmtleUNvZGUsIGhlbmNlIHdlIGRvIG5vdCB1cGRhdGUgdGhhdCB2YWx1ZSBvbiAna2V5cHJlc3MnXG4gICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9IGtleUNvZGVOdW1iZXIoZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB0ZXh0IHNlbGVjdGlvbiBpbnNpZGUgdGhlIGlucHV0IHdpdGggdGhlIGdpdmVuIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gZW5kXG4gICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGJvb2xlYW59IHNldFJlYWxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCwgc2V0UmVhbCkge1xuICAgICAgICAgICAgLy9UT0RPIE1vZGlmeSBzZXRSZWFsIHRvIGJlIG1vcmUgZXhwbGljaXQgKGFuZCBhIGJvb2xlYW4pXG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgdGhpcy50aGF0LnZhbHVlLmxlbmd0aCk7IC8vVE9ETyBSZXBsYWNlIGB0aGlzLnRoYXQudmFsdWUubGVuZ3RoYCB3aXRoIGB0aGlzLnZhbHVlLmxlbmd0aGBcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHNldFJlYWwpIHx8IHNldFJlYWwpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjYXJldCBwb3NpdGlvbiBpbnNpZGUgdGhlIGlucHV0IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHBvc1xuICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxib29sZWFufSBzZXRSZWFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0Q2FyZXRQb3NpdGlvbihwb3MsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIC8vVE9ETyBNb2RpZnkgc2V0UmVhbCB0byBiZSBtb3JlIGV4cGxpY2l0IChhbmQgYSBib29sZWFuKVxuICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHBvcywgcG9zLCBzZXRSZWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaW5nIHBhcnRzIGxvY2F0ZWQgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbi5cbiAgICAgICAgICogVGhvc2UgcGFydHMgYXJlIGxlZnQgJ3VudG91Y2hlZCcsIGllLiBmb3JtYXR0ZWQgYnkgYXV0b051bWVyaWMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfSBUaGUgcGFydHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZhbHVlLnN1YnN0cmluZyh0aGlzLnNlbGVjdGlvbi5lbmQsIHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgcGFydHMgbG9jYXRlZCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uLlxuICAgICAgICAgKiBUaG9zZSBwYXJ0cyBhcmUgdW5mb3JtYXR0ZWQgKHN0cmlwcGVkKSBvZiBhbnkgbm9uLW51bWJlcnMgY2hhcmFjdGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IFRoZSBwYXJ0cyBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbiwgdW5mb3JtYXR0ZWQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBpZiBjaGFuZ2luZyB0aGUgc2lnbiBhbmQgbGVmdCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIHplcm8gLSBwcmV2ZW50cyBzdHJpcHBpbmcgdGhlIGxlYWRpbmcgemVyb3NcbiAgICAgICAgICAgIGxldCBzdHJpcFplcm9zID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5IeXBoZW4gJiYgTnVtYmVyKGxlZnQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaXBaZXJvcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVmdCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LCB0aGlzLnNldHRpbmdzQ2xvbmUsIHN0cmlwWmVyb3MpO1xuXG4gICAgICAgICAgICByaWdodCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhyaWdodCwgdGhpcy5zZXR0aW5nc0Nsb25lLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGxlZnQsICctJykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcbiAgICAgICAgICAgICAgICByaWdodCA9IChyaWdodCA9PT0gJy0nKSA/ICcnIDogcmlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpcCBwYXJ0cyBmcm9tIGV4Y2VzcyBjaGFyYWN0ZXJzIGFuZCBsZWFkaW5nIHplcm9zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVmdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRcbiAgICAgICAgICogQHJldHVybnMge1sqLCpdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX25vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAvLyBpZiBjaGFuZ2luZyB0aGUgc2lnbiBhbmQgbGVmdCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIHplcm8gLSBwcmV2ZW50cyBzdHJpcHBpbmcgdGhlIGxlYWRpbmcgemVyb3NcbiAgICAgICAgICAgIGxldCBzdHJpcFplcm9zID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5IeXBoZW4gJiYgTnVtYmVyKGxlZnQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaXBaZXJvcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVmdCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LCBzZXR0aW5nc0Nsb25lLCBzdHJpcFplcm9zKTtcblxuICAgICAgICAgICAgLy8gSWYgcmlnaHQgaXMgbm90IGVtcHR5IGFuZCBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGRlY2ltYWxDaGFyYWN0ZXJcbiAgICAgICAgICAgIHJpZ2h0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnRzIG11bHRpcGxlIGxlYWRpbmcgemVyb3MgZnJvbSBiZWluZyBlbnRlcmVkXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5sZWFkaW5nWmVybyA9PT0gJ2RlbnknICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bTAgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUubnVtcGFkMCkgJiZcbiAgICAgICAgICAgICAgICBOdW1iZXIobGVmdCkgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAhY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSAgJiYgcmlnaHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGxlZnQsICctJykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5zZXJ0IHplcm8gaWYgaGFzIGxlYWRpbmcgZG90XG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLm5ld1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzQ2xvbmUuYU5lZ1JlZ0F1dG9TdHJpcH1cXFxcJHtzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXJ9YCkpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UobVsxXSwgbVsxXSArICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgcGFydCBvZiBudW1iZXIgdG8gdmFsdWUgd2hpbGUga2VlcGluZyB0aGUgY3Vyc29yIHBvc2l0aW9uLiAvL1RPRE8gV2hhdCBhYm91dCB0aGUgY3Vyc29yIHNlbGVjdGlvbj9cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQYXN0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBpc1Bhc3RlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMuX25vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xuXG4gICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHRydW5jYXRlRGVjaW1hbCh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lLCBpc1Bhc3RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0VmFsdWUgPSAoY29udGFpbnModGhpcy5uZXdWYWx1ZSwgJywnKSkgPyB0aGlzLm5ld1ZhbHVlLnJlcGxhY2UoJywnLCAnLicpIDogdGhpcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gdGVzdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMubmV3VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5uZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdoZW4gdGhlIHVzZXIgZW50ZXIgYSAnMCcgb24gdGhlIGZhciBsZWZ0IHdpdGggYSBsZWFkaW5nIHplcm8gb3B0aW9uIHNldCB0byAnZGVueScsIHRoYXQgdGhlIGNhcmV0IGRvZXMgbm90IG1vdmVzIHNpbmNlIHRoZSBpbnB1dCBpcyBkcm9wcGVkIChmaXggaXNzdWUgIzI4MylcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDEgJiYgcGFydHNbMF0gPT09ICcwJyAmJiBzZXR0aW5nc0Nsb25lLmxlYWRpbmdaZXJvID09PSAnZGVueScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZW50ZXIgYDBgLCB0aGVuIHRoZSBjYXJldCBpcyBwdXQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgaXQgKEZpeCBpc3N1ZSAjMjk5KVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNbMV0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHBvc2l0aW9uLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYF9leHBhbmRTZWxlY3Rpb25PblNpZ24oKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBTaWduIHBvc2l0aW9uIG9mIGEgZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0U2lnblBvc2l0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sID0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzLnRoYXQ7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sTGVuID0gY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTmVnID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgdGhhdC52YWx1ZSAmJiB0aGF0LnZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNOZWcgPyBbMSwgY3VycmVuY3lTeW1ib2xMZW4gKyAxXSA6IFswLCBjdXJyZW5jeVN5bWJvbExlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTGVuID0gdGhhdC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZUxlbiAtIGN1cnJlbmN5U3ltYm9sTGVuLCB2YWx1ZUxlbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbMTAwMCwgLTFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cGFuZHMgc2VsZWN0aW9uIHRvIGNvdmVyIHdob2xlIHNpZ25cbiAgICAgICAgICogUHJldmVudHMgcGFydGlhbCBkZWxldGlvbi9jb3B5aW5nL292ZXJ3cml0aW5nIG9mIGEgc2lnblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxib29sZWFufSBzZXRSZWFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZXhwYW5kU2VsZWN0aW9uT25TaWduKHNldFJlYWwpIHtcbiAgICAgICAgICAgIC8vVE9ETyBNb2RpZnkgc2V0UmVhbCB0byBiZSBtb3JlIGV4cGxpY2l0IChhbmQgYSBib29sZWFuIG9ubHkpXG4gICAgICAgICAgICAvL1RPRE8gVXNlIGFycmF5IGRlc3RydWN0dXJpbmcgaGVyZSB0byBzZXQgc2lnblBvc2l0aW9uIHRvIG1vcmUgZXhwbGljaXQgdmFyaWFibGVzXG4gICAgICAgICAgICBjb25zdCBzaWduUG9zaXRpb24gPSB0aGlzLl9nZXRTaWduUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBJZiBzZWxlY3Rpb24gY2F0Y2hlcyBzb21ldGhpbmcgZXhjZXB0IHNpZ24gYW5kIGNhdGNoZXMgb25seSBzcGFjZSBmcm9tIHNpZ25cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMV0gJiYgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZW4gc2VsZWN0IHdpdGhvdXQgZW1wdHkgc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAoKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSB8fCBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzFdKSAmJiB0aGlzLnZhbHVlLnN1YnN0cmluZyhNYXRoLm1heChzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWluKHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSkpLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0sIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNpZ25Qb3NpdGlvblsxXSwgc2VsZWN0aW9uLmVuZCwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIHNlbGVjdCB3aXRoIHdob2xlIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKE1hdGgubWluKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdKSwgTWF0aC5tYXgoc2VsZWN0aW9uLmVuZCwgc2lnblBvc2l0aW9uWzFdKSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyeSB0byBzdHJpcCBwYXN0ZWQgdmFsdWUgdG8gZGlnaXRzXG4gICAgICAgICAqL1xuICAgICAgICBfY2hlY2tQYXN0ZSgpIHtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFydHMgPSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHN0cmlwIHRoZSBwYXN0ZWQgdmFsdWUgZmlyc3RcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdC5zdWJzdHIoMCwgb2xkUGFydHNbMF0ubGVuZ3RoKSArIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LnN1YnN0cihvbGRQYXJ0c1swXS5sZW5ndGgpLCB0aGlzLnNldHRpbmdzQ2xvbmUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2V0VmFsdWVQYXJ0cyhtb2RpZmllZExlZnRQYXJ0LCByaWdodCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9sZFBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9jZXNzIHBhc3RpbmcsIGN1cnNvciBtb3ZpbmcgYW5kIHNraXBwaW5nIG9mIG5vdCBpbnRlcmVzdGluZyBrZXlzLlxuICAgICAgICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgVFJVRSwgdGhlbiBmdXJ0aGVyIHByb2Nlc3NpbmcgaXMgbm90IHBlcmZvcm1lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9za2lwQWx3YXlzKGUpIHtcbiAgICAgICAgICAgIC8vIENhdGNoIHRoZSBjdHJsIHVwIG9uIGN0cmwtdlxuICAgICAgICAgICAgaWYgKCgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgZS50eXBlID09PSAna2V5dXAnICYmICFpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHx8IChlLnNoaWZ0S2V5ICYmIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkpIHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gTW92ZSB0aGlzIHRlc3QgaW5zaWRlIHRoZSBgb25LZXl1cGAgaGFuZGxlclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFzdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNraXAgYWxsIGZ1bmN0aW9uIGtleXMgKEYxLUYxMiksIFdpbmRvd3Mga2V5cywgdGFiIGFuZCBvdGhlciBzcGVjaWFsIGtleXNcbiAgICAgICAgICAgIGlmICgodGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5GMSAmJiB0aGlzLmV2ZW50S2V5Q29kZSA8PSBrZXlDb2RlLkYxMikgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5XaW5kb3dzICYmIHRoaXMuZXZlbnRLZXlDb2RlIDw9IGtleUNvZGUuUmlnaHRDbGljaykgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5ldmVudEtleUNvZGUgPj0ga2V5Q29kZS5UYWIgJiYgdGhpcy5ldmVudEtleUNvZGUgPCBrZXlDb2RlLlNwYWNlKSB8fFxuICAgICAgICAgICAgICAgIC8vIGBlLndoaWNoYCBpcyBzb21ldGltZXMgZGlmZmVyZW50IHRoYW4gYHRoaXMuZXZlbnRLZXlDb2RlYCBkdXJpbmcgdGhlIGtleXByZXNzIGV2ZW50IHdoZW4gZW50ZXJpbmcgYSBwcmludGFibGUgY2hhcmFjdGVyIGtleSAoaWUuICd0JykuIEFsc28sIGBlLndoaWNoYCBlcXVhbHMgMCBmb3Igbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICh0aGlzLmV2ZW50S2V5Q29kZSA8IGtleUNvZGUuQmFja3NwYWNlICYmXG4gICAgICAgICAgICAgICAgKGUud2hpY2ggPT09IDAgfHwgZS53aGljaCA9PT0gdGhpcy5ldmVudEtleUNvZGUpKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLk51bUxvY2sgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5TY3JvbGxMb2NrIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuSW5zZXJ0IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIFwiU2VsZWN0IGFsbFwiIGtleWJvYXJkIHNob3J0Y3V0IGlzIGRldGVjdGVkIChjdHJsICsgYSlcbiAgICAgICAgICAgIGlmICgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdE51bWJlck9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGlzIHVzZWQgaGVyZSB0byBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGZpcnN0IHNlbGVjdCBhbGwgdGhlIGlucHV0IHRleHQgKGluY2x1ZGluZyB0aGUgY3VycmVuY3kgc2lnbiksIG90aGVyd2lzZSB3ZSB3b3VsZCBzZWUgdGhhdCB3aG9sZSBzZWxlY3Rpb24gZmlyc3QgaW4gYSBmbGFzaCwgdGhlbiB0aGUgc2VsZWN0aW9uIHdpdGggb25seSB0aGUgbnVtYmVyIHBhcnQgd2l0aG91dCB0aGUgY3VycmVuY3kgc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoaXMudGhhdC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sTGVuID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghY29udGFpbnModGhpcy50aGF0LnZhbHVlLCAnLScpKT8wOjE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeFRleHRMZW4gPSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnICYmIG5lZ0xlbiA9PT0gMSAmJiBjdXJyZW5jeVN5bWJvbExlbiA+IDApP2N1cnJlbmN5U3ltYm9sTGVuICsgMTpjdXJyZW5jeVN5bWJvbExlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIHN1ZmZpeFRleHRMZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKHN1ZmZpeFRleHRMZW4gKyBjdXJyZW5jeVN5bWJvbExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoY3VycmVuY3lTeW1ib2xMZW4gPiAwKT92YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIG5lZ0xlbiArIHN1ZmZpeFRleHRMZW4pOnZhbHVlTGVuIC0gKGN1cnJlbmN5U3ltYm9sTGVuICsgc3VmZml4VGV4dExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIHN1ZmZpeFRleHRMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIFwiQ29weVwiLCBcIlBhc3RlXCIgb3IgXCJDdXRcIiBrZXlib2FyZCBzaG9ydGN1dCBpcyBkZXRlY3RlZCAocmVzcGVjdGl2ZWx5ICdjdHJsICsgYycsICdjdHJsICsgdicgb3IgJ2N0cmwgKyB4JylcbiAgICAgICAgICAgIGlmICgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLmMgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUudiB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS54KSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRTZWxlY3Rpb25PblNpZ24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcHJldmVudCB3cm9uZyBwYXN0ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS52IHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUgPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEp1bXAgb3ZlciB0aG91c2FuZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIC8vVE9ETyBNb3ZlIHRoaXMgdGVzdCBpbnNpZGUgdGhlIGBvbktleWRvd25gIGhhbmRsZXJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdykge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuTGVmdEFycm93ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDIpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDIpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24odGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCArIDEpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCArIDEpID09PSB0aGlzLnNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24odGhpcy5zZWxlY3Rpb24uc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRLZXlDb2RlID49IGtleUNvZGUuUGFnZURvd24gJiYgdGhpcy5ldmVudEtleUNvZGUgPD0ga2V5Q29kZS5Eb3duQXJyb3c7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdGhlIG1pbnVzIHNpZ24gaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBudW1lcmljIGNoYXJhY3RlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0IFRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0IFRoZSBwYXJ0IG9uIHRoZSByaWdodCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24oW2xlZnQsIHJpZ2h0XSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpICYmIHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5sZW5ndGggLSBzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgJiYgc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkgKyBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgJy0nKSAmJiB0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1RPRE8gTWVyZ2UgdGhlIHR3byBmb2xsb3dpbmcgJ2lmJyBibG9ja3MgaW50byBvbmUgYGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtgIGFuZCBhIHN3aXRjaCBvbiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgKCh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB8fCAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmIHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIC0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnJyAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9jZXNzIHRoZSBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG5cbiAgICAgICAgICAgIGxldCBsZWZ0O1xuICAgICAgICAgICAgbGV0IHJpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgoKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcgfHwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3InKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLnZhbHVlLCAnLScpKSB7IC8vVE9ETyBDaGFuZ2UgYHRoaXMudmFsdWVgIHRvIGB0aGlzLnRoYXQudmFsdWVgP1xuICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uSWZUcmFpbGluZ05lZ2F0aXZlU2lnbihbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZFNlbGVjdGlvbk9uU2lnbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGRlY2lkZXMgaWYgdGhlIGtleSBwcmVzc2VkIHNob3VsZCBiZSBkcm9wcGVkIG9yIGFjY2VwdGVkLCBhbmQgbW9kaWZ5IHRoZSB2YWx1ZSAnb24tdGhlLWZseScgYWNjb3JkaW5nbHkuXG4gICAgICAgICAqIFJldHVybnMgVFJVRSBpZiB0aGUga2V5Y29kZSBpcyBhbGxvd2VkLlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9ucyBhbHNvIG1vZGlmeSB0aGUgdmFsdWUgb24tdGhlLWZseS4gLy9GSVhNRSBUaGlzIHNob3VsZCB1c2UgYW5vdGhlciBmdW5jdGlvbiBpbiBvcmRlciB0byBzZXBhcmF0ZSB0aGUgdGVzdCBhbmQgdGhlIG1vZGlmaWNhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24oZSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBTdGFydCBydWxlcyB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBrZXkgaXMgcHJlc3NlZCBhbHdheXMgdXNlIG51bWVyaWMgcGFkIGRvdCB0byBpbnNlcnQgZGVjaW1hbCBzZXBhcmF0b3JcbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBpZiBubyBkZWNpbWFsIHBhcnQgYWxsb3dlZFxuICAgICAgICAgICAgaWYgKGUua2V5ID09PSBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIgfHxcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgJiYgZS5rZXkgPT09IHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSB8fFxuICAgICAgICAgICAgICAgICgoZS5rZXkgPT09ICcuJyB8fCBlLmtleSA9PT0gJywnKSAmJiB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5Eb3ROdW1wYWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lLmRlY2ltYWxQbGFjZXNPdmVycmlkZSB8fCAhc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBiZWZvcmUgbmVnYXRpdmVTaWduQ2hhcmFjdGVyIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBpZiBvdGhlciBkZWNpbWFsIGNoYXJhY3RlciBwcmVzZW50XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQgKyBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIsIHJpZ2h0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG1pbnVzIGlmIG5vdCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoKGUua2V5ID09PSAnLScgfHwgZS5rZXkgPT09ICcrJykgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPT09ICctJykge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYXJldCBpcyBhbHdheXMgYWZ0ZXIgbWludXNcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHx8IChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gJ3AnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSBudW1iZXIgc2lnbiwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNoYXJBdCgwKSA9PT0gJy0nIHx8IGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoZS5rZXkgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGxlZnQgOiBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgbnVtYmVyIHNpZ24sIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChlLmtleSA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdCA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciB0cmllcyB0byBpbnNlcnQgZGlnaXQgYmVmb3JlIG1pbnVzIHNpZ25cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TnVtYmVyID0gTnVtYmVyKGUua2V5KTtcbiAgICAgICAgICAgIGlmIChldmVudE51bWJlciA+PSAwICYmIGV2ZW50TnVtYmVyIDw9IDkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgbGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubWF4aW11bVZhbHVlIDw9IDAgJiYgc2V0dGluZ3NDbG9uZS5taW5pbXVtVmFsdWUgPCBzZXR0aW5nc0Nsb25lLm1heGltdW1WYWx1ZSAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICYmIGUua2V5ICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQgKyBlLmtleSwgcmlnaHQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgYW55IG90aGVyIGNoYXJhY3RlclxuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JtYXR0aW5nIG9mIGp1c3QgcHJvY2Vzc2VkIHZhbHVlIHdoaWxlIGtlZXBpbmcgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZm9ybWF0VmFsdWUoZSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRMZW5ndGggPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgbGV0IFtsZWZ0XSA9IHRoaXMuX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBObyBncm91cGluZyBzZXBhcmF0b3IgYW5kIG5vIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yICA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciAhPT0gJycgICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IpKSkgJiZcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IFtzdWJQYXJ0c10gPSBsZWZ0TGVuZ3RoLnNwbGl0KHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHN1YlBhcnRzLCAnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5TaWduID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICBzdWJQYXJ0cyA9IHN1YlBhcnRzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50UG9zICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludE5lZyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxlZnQgPSBuU2lnbiArIGxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYWRkR3JvdXBTZXBhcmF0b3JzKHRoaXMudmFsdWUsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIHJlZ2V4cCB3aGljaCBzZWFyY2hlcyBmb3IgY3Vyc29yIHBvc2l0aW9uIGZyb20gdW5mb3JtYXR0ZWQgbGVmdCBwYXJ0XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEFyID0gbGVmdC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXhlcyBjYXJldCBwb3NpdGlvbiB3aXRoIHRyYWlsaW5nIG1pbnVzIHNpZ25cbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJyB8fCAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJykpICYmXG4gICAgICAgICAgICAgICAgICAgIGxlZnRBclswXSA9PT0gJy0nICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0QXIuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25QYXJ0cyA9IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZUNociA9IFsnXFxcXCcsICdeJywgJyQnLCAnLicsICd8JywgJz8nLCAnKicsICcrJywgJygnLCAnKScsICdbJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlZFBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNpZ25QYXJ0cywgKGksIG1pbmlQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pUGFydHMgPSBzaWduUGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkobWluaVBhcnRzLCBlc2NhcGVDaHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnXFxcXCcgKyBtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2gobWluaVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2hpbmcgdGhlIGVzY2FwZWQgc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWZ0QXJbaV0ubWF0Y2goJ1xcXFxkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBcltpXSA9ICdcXFxcJyArIGxlZnRBcltpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSZWcgPSBuZXcgUmVnRXhwKCdeLio/JyArIGxlZnRBci5qb2luKCcuKj8nKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggY3Vyc29yIHBvc2l0aW9uIGluIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSB2YWx1ZS5tYXRjaChsZWZ0UmVnKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ld0xlZnRbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBqdXN0IGJlZm9yZSB0aGUgc2lnbiB3aGljaCBpcyBpbiBwcmVmaXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgocG9zaXRpb24gPT09IDAgJiYgdmFsdWUuY2hhckF0KDApICE9PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgfHwgKHBvc2l0aW9uID09PSAxICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCArICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJyA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeCBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHZhbHVlIGlmIGl0IGhhcyBjaGFuZ2VkLiBUaGlzIHByZXZlbnRzIG1vZGlmeWluZyB0aGUgc2VsZWN0aW9uLCBpZiBhbnkuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudGhhdC52YWx1ZSB8fFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSB0aGlzLnRoYXQudmFsdWUgJiYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bTAgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUubnVtcGFkMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSB0cnVlOyAvL1RPRE8gUmVuYW1lIGB0aGlzLmZvcm1hdHRlZGAgdG8gYHRoaXMuX2Zvcm1hdEV4ZWN1dGVkYCwgc2luY2UgaXQncyBwb3NzaWJsZSB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG5lZWQgdG8gZm9ybWF0IGFueXRoaW5nIChpbiB0aGUgY2FzZSB3aGVyZSB0aGUga2V5Y29kZSBpcyBkcm9wcGVkIGZvciBpbnN0YW5jZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZmFjdG9yaXNlIHRoZSBgZ2V0U3RyaW5nKClgIGFuZCBgZ2V0QXJyYXkoKWAgZnVuY3Rpb25zIHNpbmNlIHRoZXkgc2hhcmUgcXVpdGUgYSBsb3Qgb2YgY29kZS5cbiAgICAgKlxuICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICogVGhlIFwiZ2V0QXJyYXlcIiBtZXRob2Qgb24gdGhlIG90aGVyIGhhbmQgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplQXJyYXkoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9yIG9iamVjdHMgdGhhdCBjYW4gYmUgZW5jb2RlZCBhcyBhIEpTT04gc3RyaW5nLlxuICAgICAqXG4gICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiLCBvciBldmVuIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdldEFycmF5QmVoYXZpb3IgLSBJZiBzZXQgdG8gVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIGJlaGF2ZSBsaWtlIGBnZXRBcnJheSgpYCwgb3RoZXJ3aXNlIGlmIHNldCB0byBGQUxTRSwgaXQgYmVoYXZlIGxpa2UgYGdldFN0cmluZygpYFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldFN0cmluZ09yQXJyYXkoZ2V0QXJyYXlCZWhhdmlvciA9IHRydWUsIHRoYXQpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGF0KTtcbiAgICAgICAgY29uc3QgZm9ybUluZGV4ID0gJCgnZm9ybScpLmluZGV4KCR0aGlzKTtcbiAgICAgICAgY29uc3QgYWxsRm9ybUVsZW1lbnRzID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pYClbMF07XG4gICAgICAgIGNvbnN0IGFpSW5kZXggPSBbXTtcblxuICAgICAgICAvLyBhbGwgaW5wdXQgaW5kZXhcbiAgICAgICAgY29uc3Qgc2NJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgY29udHJvbCBpbmRleFxuICAgICAgICBjb25zdCByU3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByU3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByQ2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pO1xuICAgICAgICBjb25zdCByTm9uQXV0b051bWVyaWNUeXBlcyA9IC9eKD86YnV0dG9ufGNoZWNrYm94fGNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8ZmlsZXxpbWFnZXxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFkaW98cmFuZ2V8cmVzZXR8c2VhcmNofHN1Ym1pdHx0aW1lfHVybHx3ZWVrKS9pO1xuXG4gICAgICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICAgICAgLy8gaW5kZXggb2Ygc3VjY2Vzc2Z1bCBlbGVtZW50c1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lICE9PSAnJyAmJiByU3VibWl0dGFibGUudGVzdChmaWVsZC5sb2NhbE5hbWUpICYmICFyU3VibWl0dGVyVHlwZXMudGVzdChmaWVsZC50eXBlKSAmJiAhZmllbGQuZGlzYWJsZWQgJiYgKGZpZWxkLmNoZWNrZWQgfHwgIXJDaGVja2FibGVUeXBlLnRlc3QoZmllbGQudHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpbmRleCBvZiBhbGwgaW5wdXRzIHRhZ3MgZXhjZXB0IGNoZWNrYm94XG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIChmaWVsZC50eXBlID09PSAnJyB8fCBmaWVsZC50eXBlID09PSAndGV4dCcgfHwgZmllbGQudHlwZSA9PT0gJ2hpZGRlbicgfHwgZmllbGQudHlwZSA9PT0gJ3RlbCcpKSB7XG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgck5vbkF1dG9OdW1lcmljVHlwZXMudGVzdChmaWVsZC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGdldEFycmF5QmVoYXZpb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemVBcnJheSgpO1xuXG4gICAgICAgICAgICAkLmVhY2goZm9ybUZpZWxkcywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gc2NJbmRleC5pbmRleE9mKGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbnB1dCA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KSBpbnB1dDplcSgke2FpSW5kZXhbc2NFbGVtZW50XX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtRmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2V0U3RyaW5nKCkgYmVoYXZpb3JcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1QYXJ0cyA9IGZvcm1GaWVsZHMuc3BsaXQoJyYnKTtcblxuICAgICAgICAgICAgJC5lYWNoKGZvcm1QYXJ0cywgaSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2lucHV0TmFtZSwgaW5wdXRWYWx1ZV0gPSBmb3JtUGFydHNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSBzY0luZGV4LmluZGV4T2YoaSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIGEgdmFsaWQgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkSW5wdXRWYWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtUGFydHNbaV0gPSBgJHtpbnB1dE5hbWV9PSR7bW9kaWZpZWRJbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1QYXJ0cy5qb2luKCcmJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNpbicgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSkge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdmb2N1c2luJyB8fCBlLnR5cGUgPT09ICdtb3VzZWVudGVyJyAmJiAhJHRoaXMuaXMoJzpmb2N1cycpICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICR0aGlzLnZhbCh0b2dnbGVOZWdhdGl2ZUJyYWNrZXQoZS50YXJnZXQudmFsdWUsIHNldHRpbmdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAvL1RPRE8gRG8gbm90IHJlcGVhdCB5b3Vyc2VsZiB3aXRoIHRoZSBgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHNldHRpbmdzLnJhd1ZhbHVlKTtgIGxpbmVcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cztcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5vRGVjO1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5vU2VwYXJhdG9yT25Gb2N1cykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgPSAnJztcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCA9ICcnO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnN1ZmZpeFRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgocmVzdWx0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGUudGFyZ2V0LnZhbHVlLCBzZXR0aW5ncywgdHJ1ZSkpICE9PSBzZXR0aW5ncy5yYXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBzZW5kIGEgJ25hdGl2ZScgY2hhbmdlIGV2ZW50IHdoZW4gYmx1cnJpbmcgdGhlIGlucHV0LCB3ZSBuZWVkIHRvIGZpcnN0IHN0b3JlIHRoZSBpbml0aWFsIGlucHV0IHZhbHVlIG9uIGZvY3VzLlxuICAgICAgICAgICAgaG9sZGVyLnZhbHVlT25Gb2N1cyA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBob2xkZXIudmFsdWVPbkZvY3VzO1xuICAgICAgICAgICAgY29uc3Qgb25FbXB0eSA9IGNoZWNrRW1wdHkoaG9sZGVyLnZhbHVlT25Gb2N1cywgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgaWYgKChvbkVtcHR5ICE9PSBudWxsICYmIG9uRW1wdHkgIT09ICcnKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy52YWwob25FbXB0eSk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRW1wdHkgPT09IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2tleWRvd24nIGV2ZW50cy5cbiAgICAgKiBUaGUgdXNlciBqdXN0IHN0YXJ0ZWQgcHVzaGluZyBhbnkga2V5LCBoZW5jZSBvbmUgZXZlbnQgaXMgc2VudC5cbiAgICAgKlxuICAgICAqIE5vdGUgOlxuICAgICAqIEJ5IGRlZmF1bHQgYSAnbm9ybWFsJyBpbnB1dCBvdXRwdXQgdGhvc2UgZXZlbnRzIGluIHRoZSByaWdodCBvcmRlciB3aGVuIGlucHV0dGluZyBhIGNoYXJhY3RlciBrZXkgKGllLiAnYScpIDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXByZXNzXG4gICAgICogLSBpbnB1dFxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIC4uLndoZW4gaW5wdXR0aW5nIGEgbW9kaWZpZXIga2V5IChpZS4gJ2N0cmwnKSA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogSWYgJ2RlbGV0ZScgb3IgJ2JhY2tzcGFjZScgaXMgZW50ZXJlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0gaW5wdXRcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZW50ZXInIGlzIGVudGVyZWQgYW5kIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXByZXNzXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogSWYgJ2VudGVyJyBpcyBlbnRlcmVkIGFuZCB0aGUgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGNoYW5nZVxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIFdoZW4gYSBwYXN0ZSBpcyBkb25lLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBpbnB1dCAoaWYgcGFzdGUgaXMgZG9uZSB3aXRoIHRoZSBtb3VzZSlcbiAgICAgKlxuICAgICAqIC0ga2V5ZG93biAoaWYgcGFzdGUgaXMgZG9uZSB3aXRoIGN0cmwrdilcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGlucHV0XG4gICAgICogLSBrZXl1cFxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleWRvd24oaG9sZGVyLCBlKSB7XG4gICAgICAgIC8vVE9ETyBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHJpZXZlIHRoZSBlbGVtZW50IHZhbHVlIChlaXRoZXIgYnkgdXNpbmcgYGUudGFyZ2V0LnZhbHVlYCB3aGVuIHRoZSBlbGVtZW50IGlzIGFuIDxpbnB1dD4sIG9yIGJ5IHVzaW5nIGBlbGVtZW50LnRleHRDb250ZW50YCB3aGVuIHRoZSBlbGVtZW50IGFzIGl0cyBgY29udGVudGVkaXRhYmxlYCBzZXQgdG8gdHJ1ZSlcbiAgICAgICAgaG9sZGVyLl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZShlKTtcbiAgICAgICAgaG9sZGVyLmluaXRpYWxWYWx1ZU9uS2V5ZG93biA9IGUudGFyZ2V0LnZhbHVlOyAvLyBUaGlzIGlzIG5lZWRlZCBpbiBgb25LZXl1cCgpYCB0byBjaGVjayBpZiB0aGUgdmFsdWUgYXMgY2hhbmdlZCBkdXJpbmcgdGhlIGtleSBwcmVzc1xuXG4gICAgICAgIGlmIChob2xkZXIudGhhdC5yZWFkT25seSkge1xuICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBcImVudGVyXCIga2V5IHRocm93cyBhIGBjaGFuZ2VgIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgYGZvY3VzYCBldmVudFxuICAgICAgICBpZiAoaG9sZGVyLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5FbnRlciAmJiBob2xkZXIudmFsdWVPbkZvY3VzICE9PSBlLnRhcmdldC52YWx1ZSkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdjaGFuZ2UnLCBlLnRhcmdldCk7XG4gICAgICAgICAgICBob2xkZXIudmFsdWVPbkZvY3VzID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBob2xkZXIuX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyhlKTtcblxuICAgICAgICBpZiAoaG9sZGVyLl9za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtleSBpcyBhIGRlbGV0ZS9iYWNrc3BhY2Uga2V5XG4gICAgICAgIGlmIChob2xkZXIuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBob2xkZXIuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkge1xuICAgICAgICAgICAgaG9sZGVyLl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24oKTsgLy8gQmVjYXVzZSBiYWNrc3BhY2UgYW5kIGRlbGV0ZSBvbmx5IHRyaWdnZXJzIGtleWRvd24gYW5kIGtleXVwIGV2ZW50cywgbm90IGtleXByZXNzXG4gICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0VmFsdWUoZSk7XG5cbiAgICAgICAgICAgIC8vIElmIGFuZCBvbmx5IGlmIHRoZSByZXN1bHRpbmcgdmFsdWUgaGFzIGNoYW5nZWQgYWZ0ZXIgdGhhdCBiYWNrc3BhY2UvZGVsZXRlLCB0aGVuIHdlIGhhdmUgdG8gc2VuZCBhbiAnaW5wdXQnIGV2ZW50IGxpa2UgYnJvd3NlcnMgbm9ybWFsbHkgZG8uXG4gICAgICAgICAgICBpZiAoKGUudGFyZ2V0LnZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgIC8vIFRocm93IGFuIGlucHV0IGV2ZW50IHdoZW4gYSBjaGFyYWN0ZXIgZGVsZXRpb24gaXMgZGV0ZWN0ZWRcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2lucHV0JywgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gLi4uYW5kIGltbWVkaWF0ZWx5IHByZXZlbnQgdGhlIGJyb3dzZXIgdG8gZGVsZXRlIGEgc2Vjb25kIGNoYXJhY3RlclxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTsgLy9UT0RPIElzIHRoaXMgbGluZSBuZWVkZWQ/XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2tleXByZXNzJyBldmVudHMuXG4gICAgICogVGhlIHVzZXIgaXMgc3RpbGwgcHJlc3NpbmcgdGhlIGtleSwgd2hpY2ggd2lsbCBvdXRwdXQgYSBjaGFyYWN0ZXIgKGllLiAnMicpIGNvbnRpbnVvdXNseSB1bnRpbCBpdCByZWxlYXNlcyB0aGUga2V5LlxuICAgICAqIE5vdGU6ICdrZXlwcmVzcycgZXZlbnRzIGFyZSBub3Qgc2VudCBmb3IgZGVsZXRlIGtleXMgbGlrZSBCYWNrc3BhY2UvRGVsZXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5cHJlc3MoaG9sZGVyLCBlKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZ2VuZXJhdGUgYSAna2V5cHJlc3MnIGV2ZW50IChlLmtleUNvZGUgPT09IDApIGZvciB0aGUga2V5cyB0aGF0IGRvIG5vdCBwcmludCBhIGNoYXJhY3RlciAoaWUuICdJbnNlcnQnLCAnRGVsZXRlJywgJ0ZuJyBrZXlzLCAnUGFnZVVwJywgJ1BhZ2VEb3duJyBldGMuKS4gJ1NoaWZ0JyBvbiB0aGUgb3RoZXIgaGFuZCBkb2VzIG5vdCBnZW5lcmF0ZSBhIGtleXByZXNzIGV2ZW50LlxuICAgICAgICBpZiAoZS5rZXkgPT09IGtleU5hbWUuSW5zZXJ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBob2xkZXIucHJvY2Vzc2VkO1xuICAgICAgICBob2xkZXIuX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyhlKTtcblxuICAgICAgICBpZiAoaG9sZGVyLl9za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCA9IGhvbGRlci5fcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbihlKTtcbiAgICAgICAgaWYgKGlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRWYWx1ZShlKTtcbiAgICAgICAgICAgIGlmICgoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGlucHV0IGV2ZW50IG9uIGFkZGluZyBhIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnaW5wdXQnLCBlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBhZGQgYSBzZWNvbmQgY2hhcmFjdGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLCB3ZSBkbyBub3QgYWxsb3cgdGhlIGlucHV0IGV2ZW50IHRvIGJlIHNlbnRcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5dXAnIGV2ZW50cy5cbiAgICAgKiBUaGUgdXNlciBqdXN0IHJlbGVhc2VkIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5dXAoaG9sZGVyLCBzZXR0aW5ncywgZSkge1xuICAgICAgICBob2xkZXIuX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcyhlKTtcblxuICAgICAgICBjb25zdCBza2lwID0gaG9sZGVyLl9za2lwQWx3YXlzKGUpO1xuICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgaWYgKHNraXAgfHwgZS50YXJnZXQudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGRlZCB0byBwcm9wZXJseSBwbGFjZSB0aGUgY2FyZXQgd2hlbiBvbmx5IHRoZSBjdXJyZW5jeSBzaWduIGlzIHByZXNlbnRcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkge1xuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoLCBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuVGFiKSB7XG4gICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgfHxcbiAgICAgICAgICAgIChob2xkZXIuc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9PT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQgIT09ICcnKSkge1xuICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCB0byBwcmVzZXJ2ZSB0aGUgZGF0YSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlXG4gICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoZS50YXJnZXQsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhvbGRlci5mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0VmFsdWUoZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgdmFsdWUgaGFzIGNoYW5nZWQgZHVyaW5nIHRoZSBrZXkgcHJlc3MgZXZlbnQgY2hhaW4sIGFuIGV2ZW50IGlzIHNlbnQgdG8gYWxlcnQgdGhhdCBhIGZvcm1hdHRpbmcgaGFzIGJlZW4gZG9uZSAoY2YuIElzc3VlICMxODcpXG4gICAgICAgIGlmIChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmluaXRpYWxWYWx1ZU9uS2V5ZG93bikge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdhdXRvTnVtZXJpYzpmb3JtYXR0ZWQnLCBlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNvdXQnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKSB7XG4gICAgICAgIGlmICghJHRoaXMuaXMoJzpmb2N1cycpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShlLnRhcmdldCwgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5vU2VwYXJhdG9yT25Gb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgPSBzZXR0aW5ncy5vU2VwO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sID0gc2V0dGluZ3Mub1NpZ247XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3VmZml4VGV4dCA9IHNldHRpbmdzLm9TdWZmaXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3Mub0RlYztcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nID0gc2V0dGluZ3Mub1BhZDtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciA9IHNldHRpbmdzLm9CcmFja2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh2YWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRW1wdHkodmFsdWUsIHNldHRpbmdzLCBmYWxzZSkgPT09IG51bGwgJiYgbWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHNldHRpbmdzLnNjYWxlRGl2aXNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzKSA/ICtzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMgOiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ3plcm8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUoJzAnLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBncm91cGVkVmFsdWUgPSBjaGVja0VtcHR5KHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IGFkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBvcmlnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSAoc2V0dGluZ3Muc2NhbGVTeW1ib2wpID8gZ3JvdXBlZFZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgJHRoaXMudmFsKGdyb3VwZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IGhvbGRlci52YWx1ZU9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlT25Gb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdwYXN0ZScgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUGFzdGUoJHRoaXMsIGhvbGRlciwgZSkge1xuICAgICAgICAvL1RPRE8gVXNpbmcgY3RybCt6IGFmdGVyIGEgcGFzdGUgc2hvdWxkIGNhbmNlbCBpdCAtPiBIb3cgd291bGQgdGhhdCBhZmZlY3Qgb3RoZXIgZnJhbWV3b3Jrcy9jb21wb25lbnQgYnVpbHQgd2l0aCB0aGF0IGZlYXR1cmUgaW4gbWluZCB0aG91Z2g/XG4gICAgICAgIC8vRklYTUUgV2hlbiBwYXN0aW5nICcwMDAnIG9uIGEgdGhvdXNhbmQgZ3JvdXAgc2VsZWN0aW9uLCB0aGUgd2hvbGUgc2VsZWN0aW9uIGdldHMgZGVsZXRlZCwgYW5kIG9ubHkgb25lICcwJyBpcyBwYXN0ZWQgKGNmLiBpc3N1ZSAjMzAyKVxuICAgICAgICAvLyBUaGUgZXZlbnQgaXMgcHJldmVudGVkIGJ5IGRlZmF1bHQsIHNpbmNlIG90aGVyd2lzZSB0aGUgdXNlciB3b3VsZCBiZSBhYmxlIHRvIHBhc3RlIGludmFsaWQgY2hhcmFjdGVycyBpbnRvIHRoZSBpbnB1dFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbGV0IHJhd1Bhc3RlZFRleHQgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXG4gICAgICAgIC8vIDAuIFNwZWNpYWwgY2FzZSBpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgYWxsIHRoZSBpbnB1dCB0ZXh0IGJlZm9yZSBwYXN0aW5nXG4gICAgICAgIGNvbnN0IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvbkVuZCB8fCAwO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TaXplID0gc2VsZWN0aW9uRW5kIC0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGxldCBpc0FsbElucHV0VGV4dFNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvblNpemUgPT09IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gQ2hlY2sgaWYgdGhlIHBhc3RlIGhhcyBhIG5lZ2F0aXZlIHNpZ24gKG9ubHkgaWYgaXQncyB0aGUgZmlyc3QgY2hhcmFjdGVyKSwgYW5kIHN0b3JlIHRoYXQgaW5mb3JtYXRpb24gZm9yIGxhdGVyIHVzZVxuICAgICAgICBjb25zdCBpc1Bhc3RlTmVnYXRpdmUgPSBpc05lZ2F0aXZlKHJhd1Bhc3RlZFRleHQpO1xuICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAvLyAxYS4gUmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduIGZyb20gdGhlIHBhc3RlZCB0ZXh0XG4gICAgICAgICAgICByYXdQYXN0ZWRUZXh0ID0gcmF3UGFzdGVkVGV4dC5zbGljZSgxLCByYXdQYXN0ZWRUZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3UGFzdGVkVGV4dFNpemUgPSByYXdQYXN0ZWRUZXh0Lmxlbmd0aDsgLy8gVGhpcyB1c2UgdGhlICdjbGVhbmVkJyBwYXN0ZSB0ZXh0XG5cbiAgICAgICAgLy8gMi4gU3RyaXAgYWxsIHRob3VzYW5kIHNlcGFyYXRvcnMsIGJyYWNrZXRzIGFuZCBjdXJyZW5jeSBzaWduLCBhbmQgY29udmVydCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgdG8gYSBkb3RcbiAgICAgICAgY29uc3QgcGFzdGVkVGV4dCA9IHByZXBhcmVQYXN0ZWRUZXh0KHJhd1Bhc3RlZFRleHQsIGhvbGRlcik7XG5cbiAgICAgICAgLy8gMy4gVGVzdCBpZiB0aGUgcGFzdGUgaXMgdmFsaWQgKG9ubHkgaGFzIG51bWJlcnMgYW5kIGV2ZW50dWFsbHkgYSBkZWNpbWFsIGNoYXJhY3RlcikuIElmIGl0J3Mgbm90IHZhbGlkLCBzdG9wIGhlcmUuXG4gICAgICAgIGlmICghaXNOdW1iZXIocGFzdGVkVGV4dCkgfHwgcGFzdGVkVGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gU2hvdWxkIHdlIHNlbmQgYSB3YXJuaW5nIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3I/XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgaXMgbm90IGEgdmFsaWQgcGFzdGUgY29udGVudC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4gQ2FsY3VsYXRlIHRoZSBwYXN0ZSByZXN1bHRcbiAgICAgICAgbGV0IGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nO1xuICAgICAgICBsZXQgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyO1xuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBhdXRvTnVtZXJpYyAnZ2V0JyByZXR1cm5zICcwLjAwJyBpZiB0aGUgaW5wdXQgaXMgZW1wdHksIGhlbmNlIHdlIG5lZWQgdG8gc3RvcmUgdGhlICdyZWFsJyBlbXB0eSBpbml0aWFsIHZhbHVlIHdoZW4gbmVlZGVkXG4gICAgICAgICAgICBpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRpYWxVbmZvcm1hdHRlZE51bWJlciA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IGlzTmVnYXRpdmUoaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyKTtcbiAgICAgICAgbGV0IGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmU7XG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgLy8gSWYgdGhlIHBhc3RlZCBjb250ZW50IGlzIG5lZ2F0aXZlLCB0aGVuIHRoZSByZXN1bHQgd2lsbCBiZSBuZWdhdGl2ZSB0b29cbiAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZSAmJiAhaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyID0gYC0ke2luaXRpYWxVbmZvcm1hdHRlZE51bWJlcn1gO1xuICAgICAgICAgICAgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAvKiA0YS4gVHJ1bmNhdGUgcGFzdGUgYmVoYXZpb3I6XG4gICAgICAgICAgICAgKiBJbnNlcnQgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIG9uIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgdGhlIGNhcmV0IGZyb20gdGhlIHBhc3RlZCB0ZXh0IGNvbnRlbnQsIHVudGlsIHRoZSBpbnB1dCByZWFjaCBpdHMgcmFuZ2UgbGltaXQuXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSBpcyBtb3JlIGNoYXJhY3RlcnMgaW4gdGhlIGNsaXBib2FyZCBvbmNlIGEgbGltaXQgaXMgcmVhY2hlZCwgZHJvcCB0aGUgZXh0cmFuZW91cyBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlIHBhc3RlIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgY2xpcGJvYXJkLlxuICAgICAgICAgICAgICogV2hpbGUgZG9pbmcgc28sIHdlIGNoZWNrIGlmIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBhbGxvd2VkLCBhbmQgc3RvcCBhcyBzb29uIGFzIHdlIGVuY291bnRlciBvbmUgb2YgdGhvc2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogNGIuIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3I6XG4gICAgICAgICAgICAgKiBJZGVtIHRoYW4gdGhlICd0cnVuY2F0ZScgcGFzdGUgYmVoYXZpb3IsIGV4Y2VwdCB0aGF0IHdoZW4gYSByYW5nZSBsaW1pdCBpcyBoaXQsIHdlIHRyeSB0byByZXBsYWNlIHRoZSBzdWJzZXF1ZW50IGluaXRpYWwgbnVtYmVycyB3aXRoIHRoZSBwYXN0ZWQgb25lcywgdW50aWwgd2UgaGl0IHRoZSByYW5nZSBsaW1pdCBhIHNlY29uZCAoYW5kIGxhc3QpIHRpbWUsIG9yIHdlIHJ1biBvdXQgb2YgbnVtYmVycyB0byBwYXN0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tY2FzZS1kZWNsYXJhdGlvbnM6IDAgKi9cbiAgICAgICAgICAgIGNhc2UgJ3RydW5jYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRGb3JtYXR0ZWRQYXJ0ID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEZvcm1hdHRlZFBhcnQgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2Uoc2VsZWN0aW9uRW5kLCBpbml0aWFsRm9ybWF0dGVkVmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEuIElmIHRoZXJlIGlzIGEgc2VsZWN0aW9uLCByZW1vdmUgdGhlIHNlbGVjdGVkIHBhcnQsIGFuZCByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJlcGFyZVBhc3RlZFRleHQobGVmdEZvcm1hdHRlZFBhcnQgKyByaWdodEZvcm1hdHRlZFBhcnQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYi4gRWxzZSBpZiB0aGlzIGlzIG9ubHkgb25lIGNhcmV0IChhbmQgdGhlcmVmb3JlIG5vIHNlbGVjdGlvbiksIHRoZW4gcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVQYXN0ZWRUZXh0KGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXRSYXdOZWdhdGl2ZVNpZ24ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHBhc3RlIGlzIG5lZ2F0aXZlIGFuZCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBub3QsIHRoZW4gSSBtdXN0IG9mZnNldCB0aGUgY2FyZXQgcG9zaXRpb24gYnkgb25lIHBsYWNlIHRvIHRoZSByaWdodCB0byB0YWtlIHRoZSBhZGRpdGlvbmFsIGh5cGhlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFF1aWQgaWYgdGhlIG5lZ2F0aXZlIHNpZ24gaXMgbm90IG9uIHRoZSBsZWZ0IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBhbmQgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpP1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRQYXJ0ID0gcmVzdWx0LnNsaWNlKDAsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodFBhcnQgPSByZXN1bHQuc2xpY2UoY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIC0tIEhlcmUsIHdlIGFyZSBnb29kIHRvIGdvIHRvIGNvbnRpbnVlIG9uIHRoZSBzYW1lIGJhc2lzXG5cbiAgICAgICAgICAgICAgICAvLyBjLiBBZGQgbnVtYmVycyBvbmUgYnkgb25lIGF0IHRoZSBjYXJldCBwb3NpdGlvbiwgd2hpbGUgdGVzdGluZyBpZiB0aGUgcmVzdWx0IGlzIHZhbGlkIGFuZCB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gICAgQ29udGludWUgdW50aWwgeW91IGVpdGhlciBydW4gb3V0IG9mIG51bWJlcnMgdG8gcGFzdGUsIG9yIHRoYXQgeW91IGdldCBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0c1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pblBhcnNlID0gcGFyc2VTdHIoaG9sZGVyLnNldHRpbmdzLm1pbmltdW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihob2xkZXIuc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDsgLy8gVGhpcyBpcyBzZXQgYXMgdGhlIGRlZmF1bHQsIGluIGNhc2Ugd2UgZG8gbm90IGFkZCBldmVuIG9uZSBudW1iZXJcbiAgICAgICAgICAgICAgICBsZXQgcGFzdGVkVGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnRQYXJ0O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhc3RlZFRleHRJbmRleCA8IHBhc3RlZFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgcmVzdWx0IHdpdGggYW5vdGhlciBwYXN0ZWQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkTGVmdFBhcnQgKz0gcGFzdGVkVGV4dFtwYXN0ZWRUZXh0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtb2RpZmllZExlZnRQYXJ0ICsgcmlnaHRQYXJ0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByYW5nZSBsaW1pdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja0lmSW5SYW5nZShyZXN1bHQsIG1pblBhcnNlLCBtYXhQYXJzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMsIHN0b3AgdGhlIGxvb3AgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGdvb2Qga25vd24gcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHQgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhbCB2YXJpYWJsZXMgZm9yIHRoZSBuZXh0IGxvb3BcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVkVGV4dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRvIGluc2VydCBhIG5ldyBudW1iZXJcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyArPSBwYXN0ZWRUZXh0SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvL1hYWCBIZXJlIHdlIGhhdmUgdGhlIHJlc3VsdCBmb3IgdGhlIGB0cnVuY2F0ZWAgb3B0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSA9PT0gJ3RydW5jYXRlJykge1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gSWYgdGhlIHVzZXIgYXMgZGVmaW5lZCBhIHRydW5jYXRlIGNhbGxiYWNrIGFuZCB0aGVyZSBhcmUgc3RpbGwgc29tZSBudW1iZXJzICh0aGF0IHdpbGwgYmUgZHJvcHBlZCksIHRoZW4gY2FsbCB0aGlzIGNhbGxiYWNrIHdpdGggdGhlIGluaXRpYWwgcGFzdGUgYXMgd2VsbCBhcyB0aGUgcmVtYWluaW5nIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFzdEdvb2RLbm93blJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vWFhYIC4uLmVsc2Ugd2UgbmVlZCB0byBjb250aW51ZSBtb2RpZnlpbmcgdGhlIHJlc3VsdCBmb3IgdGhlICdyZXBsYWNlJyBvcHRpb25cblxuICAgICAgICAgICAgICAgIC8vIGQuIFVudGlsIHRoZXJlIGFyZSBudW1iZXJzIHRvIHBhc3RlLCByZXBsYWNlIHRoZSBpbml0aWFsIG51bWJlcnMgb25lIGJ5IG9uZSwgYW5kIHN0aWxsIGRvIHRoZSByYW5nZSB0ZXN0LlxuICAgICAgICAgICAgICAgIC8vICAgIFN0b3Agd2hlbiB5b3UgaGF2ZSBubyBtb3JlIG51bWJlcnMgdG8gcGFzdGUsIG9yIGlmIHlvdSBhcmUgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMuXG4gICAgICAgICAgICAgICAgLy8gICAgSWYgeW91IGRvIGdldCB0byB0aGUgcmFuZ2UgbGltaXRzLCB1c2UgdGhlIHByZXZpb3VzIGtub3duIGdvb2QgdmFsdWUgd2l0aGluIHRob3NlIGxpbWl0cy5cbiAgICAgICAgICAgICAgICAvLyAgICBOb3RlOiBUaGUgbnVtYmVycyBhcmUgcmVwbGFjZWQgb25lIGJ5IG9uZSwgaW4gdGhlIGludGVnZXIgdGhlbiBkZWNpbWFsIHBhcnQsIHdoaWxlIGlnbm9yaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vVE9ETyBXaGF0IHNob3VsZCBoYXBwZW4gaWYgdGhlIHVzZXIgdHJ5IHRvIHBhc3RlIGEgZGVjaW1hbCBudW1iZXI/IFNob3VsZCB3ZSBvdmVycmlkZSB0aGUgY3VycmVudCBpbml0aWFsIGRlY2ltYWwgY2hhcmFjdGVyIGluIGZhdm9yIG9mIHRoaXMgbmV3IG9uZT8gSWYgd2UgZG8sIHRoZW4gd2UgaGF2ZSB0byByZWNhbGN1bGF0ZSB0aGUgdk1pbi92TWF4IGZyb20gdGhlIHN0YXJ0IGluIG9yZGVyIHRvIHRha2UgaW50byBhY2NvdW50IHRoaXMgbmV3IGRlY2ltYWwgY2hhcmFjdGVyIHBvc2l0aW9uLi5cbiAgICAgICAgICAgICAgICBsZXQgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4ID0gY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3Rpbmc7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEdvb2RLbm93blJlc3VsdFNpemUgPSBsYXN0R29vZEtub3duUmVzdWx0Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXN0ZWRUZXh0SW5kZXggPCBwYXN0ZWRUZXh0Lmxlbmd0aCAmJiBsYXN0R29vZEtub3duUmVzdWx0SW5kZXggPCBsYXN0R29vZEtub3duUmVzdWx0U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEdvb2RLbm93blJlc3VsdFtsYXN0R29vZEtub3duUmVzdWx0SW5kZXhdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNraXAgdGhlIGRlY2ltYWwgY2hhcmFjdGVyICdyZXBsYWNlbWVudCcuIFRoYXQgd2F5LCB3ZSBkbyBub3QgY2hhbmdlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBwb3NpdGlvbiByZWdhcmRpbmcgdGhlIHJlbWFpbmluZyBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVwbGFjZSBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlQ2hhckF0KGxhc3RHb29kS25vd25SZXN1bHQsIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCwgcGFzdGVkVGV4dFtwYXN0ZWRUZXh0SW5kZXhdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmFuZ2UgbGltaXRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tJZkluUmFuZ2UocmVzdWx0LCBtaW5QYXJzZSwgbWF4UGFyc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzLCBzdG9wIHRoZSBsb29wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCBnb29kIGtub3duIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0ID0gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYWwgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBsb29wXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlZFRleHRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgY2FyZXQgcG9zaXRpb24gd2hlcmUgdG8gaW5zZXJ0IGEgbmV3IG51bWJlclxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gbGFzdEdvb2RLbm93blJlc3VsdEluZGV4O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFzdEdvb2RLbm93blJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogNGMuIE5vcm1hbCBwYXN0ZSBiZWhhdmlvcjpcbiAgICAgICAgICAgICAqIEluc2VydCB0aGUgcGFzdGVkIG51bWJlciBpbnNpZGUgdGhlIGN1cnJlbnQgdW5mb3JtYXR0ZWQgdGV4dCwgYXQgdGhlIHJpZ2h0IGNhcmV0IHBvc2l0aW9uIG9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGlmIHRoZXJlIGlzIGEgc2VsZWN0aW9uIGluIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHNlbGVjdGlvbiwgYW5kIHRoaXMgaXMgdGhlIGNhcmV0IHBvc2l0aW9uIDogSW5zZXJ0IHRoZSBwYXN0ZSBpbnRvIHRoZSBlbGVtZW50LnZhbHVlIGF0IHRoYXQgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4V2hlcmVUb0luc2VydFRoZVBhc3RlZFRleHQgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFzdGVkIHZhbHVlIGhhcyBhICctJyBzaWduLCBidXQgdGhlIGluaXRpYWwgdmFsdWUgZG9lcyBub3QsIG9mZnNldCB0aGUgaW5kZXggYnkgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFdoZXJlVG9JbnNlcnRUaGVQYXN0ZWRUZXh0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnNlcnRDaGFyQXRQb3NpdGlvbihpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIsIHBhc3RlZFRleHQsIGluZGV4V2hlcmVUb0luc2VydFRoZVBhc3RlZFRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gaW5kZXhXaGVyZVRvSW5zZXJ0VGhlUGFzdGVkVGV4dCArIHJhd1Bhc3RlZFRleHRTaXplIC0gY291bnREb3RzSW5UZXh0KHJhd1Bhc3RlZFRleHQpOyAvLyBJIG11c3Qgbm90IGNvdW50IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFzdGVkIHRleHQgKGllLiAnLicpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBzZWxlY3Rpb24gOiByZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgcGFzdGUgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBlLnRhcmdldC52YWx1ZS5zbGljZSgwLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gZS50YXJnZXQudmFsdWUuc2xpY2Uoc2VsZWN0aW9uRW5kLCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdFBhcnQgKyBwYXN0ZWRUZXh0ICsgbGFzdFBhcnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWxseSwgcmVtb3ZlIGFueSB1bndhbnRlZCBub24tbnVtYmVyIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0UGFydCAhPT0gJycgfHwgbGFzdFBhcnQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGJlZW4gc2VsZWN0ZWQgcHJpb3IgdG8gcGFzdGluZywgdGhlbiBmaXJzdFBhcnQgYW5kIGxhc3RQYXJ0IGFyZSBlbXB0eSwgaGVuY2Ugd2Ugb25seSB1c2UgdGhlIHBhc3RlZFRleHQgdmFyaWFibGUsIG90aGVyd2lzZSB3ZSByZW1vdmUgdGhlIHBvdGVudGlhbCBkZWNpbWFsIGNoYXJhY3RlciBpbiB0aGUgcmVzdWx0IHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlUGFzdGVkVGV4dChyZXN1bHQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNldFJhd05lZ2F0aXZlU2lnbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIGFsbCB0aGUgaW5wdXQgdGV4dCBpcyBzZWxlY3RlZCBiZWZvcmUgcGFzdGluZywgd2hpY2ggbWVhbnMgd2UnbGwgY29tcGxldGVseSBlcmFzZSBpdHMgY29udGVudCBhbmQgcGFzdGUgb25seSB0aGUgY2xpcGJvYXJkIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvbkVuZCwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFzdGVkIHZhbHVlIGhhcyBhICctJyBzaWduLCBidXQgdGhlIGluaXRpYWwgdmFsdWUgZG9lcyBub3QsIG9mZnNldCB0aGUgaW5kZXggYnkgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgSSBtdXN0IG5vdCBjb3VudCB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhc3RlZCB0ZXh0IChpZS4gJy4nKSwgb3IgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMgaW4gdGhlIGluaXRpYWwgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gZS50YXJnZXQudmFsdWUuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGluZGV4U2VsZWN0aW9uRW5kSW5SYXdWYWx1ZSAtIHNlbGVjdGlvblNpemUgKyBjb3VudENoYXJJblRleHQoaG9sZGVyLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IsIHNlbGVjdGVkVGV4dCkgKyByYXdQYXN0ZWRUZXh0U2l6ZSAtIGNvdW50RG90c0luVGV4dChyYXdQYXN0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuIENoZWNrIGlmIHRoZSByZXN1bHQgaXMgYSB2YWxpZCBudW1iZXIsIGlmIG5vdCwgZHJvcCB0aGUgcGFzdGUgYW5kIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmICghaXNOdW1iZXIocmVzdWx0KSB8fCByZXN1bHQgPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgd291bGQgcmVzdWx0IGludG8gYW4gaW52YWxpZCBjb250ZW50ICcke3Jlc3VsdH0nLmApOyAvL1RPRE8gU2hvdWxkIHdlIHNlbmQgYSB3YXJuaW5nIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3I/XG4gICAgICAgICAgICAgICAgLy9UT0RPIFRoaXMgaXMgbm90IERSWSA7IHJlZmFjdG9yIHdpdGggYWJvdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuIElmIGl0J3MgYSB2YWxpZCBudW1iZXIsIGNoZWNrIGlmIGl0IGZhbGxzIGluc2lkZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS4gSWYgdGhpcyBmYWlscywgbW9kaWZ5IHRoZSB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBwcm9jZWR1cmUgOlxuICAgICAgICAvKlxuICAgICAgICAgKiBJZiAnZXJyb3InICh0aGlzIGlzIHRoZSBkZWZhdWx0KSA6XG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCB0aGVuIHRocm93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlLlxuICAgICAgICAgKiAgICAgIC0gRG8gbm90IGNoYW5nZSB0aGUgaW5wdXQgdmFsdWUsIGRvIG5vdCBjaGFuZ2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBJZiAnaWdub3JlJyA6XG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCBkbyBub3RoaW5nIG1vcmUuXG4gICAgICAgICAqICAgICAgLSBEbyBub3QgY2hhbmdlIHRoZSBpbnB1dCB2YWx1ZSwgZG8gbm90IGNoYW5nZSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqIElmICdjbGFtcCcgOlxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgc2V0IHRoZSB2YWx1ZSB0byB0aGUgbWluaW11bSBvciBtYXhpbXVtIGxpbWl0LCB3aGljaGV2ZXIgaXMgY2xvc2VzdCB0byB0aGVcbiAgICAgICAgICogICAgICAgIHBhc3RlIHJlc3VsdC5cbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGRlY2ltYWwgY2hhcmFjdGVyLlxuICAgICAgICAgKiBJZiAndHJ1bmNhdGUnIDpcbiAgICAgICAgICogICAgICAtIFRydW5jYXRlIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCB1bnRpbCBpdCBmYWlscyAoaWYgdGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIG1pbiBhbmQgbWF4IHZhbHVlIGxpbWl0cykuXG4gICAgICAgICAqICAgICAgLSBEcm9wIHRoZSByZW1haW5pbmcgbm9uLXBhc3RlZCBudW1iZXJzLCBhbmQga2VlcCB0aGUgbGFzdCBrbm93biBub24tZmFpbGluZyByZXN1bHQuXG4gICAgICAgICAqICAgICAgLSBDaGFuZ2UgdGhlIGNhcmV0IHBvc2l0aW9uIHRvIGJlIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGxhc3QgcGFzdGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICogSWYgJ3JlcGxhY2UnIDpcbiAgICAgICAgICogICAgICAtIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIHVudGlsIGl0IGZhaWxzIChpZiB0aGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgbWluIGFuZCBtYXggdmFsdWUgbGltaXRzKS5cbiAgICAgICAgICAqICAgICAtIFRoZW4gdHJ5IHRvIHJlcGxhY2UgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIHdpdGggdGhlIHBhc3RlZCBvbmVzLiBPbmNlIGl0IGZhaWxzLCBrZWVwIHRoZSBsYXN0IGtub3duIG5vbi1mYWlsaW5nIHJlc3VsdC5cbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBhZnRlciB0aGUgbGFzdCBwYXN0ZWQgY2hhcmFjdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHZhbHVlSGFzQmVlblNldCA9IGZhbHNlO1xuICAgICAgICBsZXQgdmFsdWVIYXNCZWVuQ2xhbXBlZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHJlc3VsdCk7XG4gICAgICAgICAgICB2YWx1ZUhhc0JlZW5TZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbGV0IGNsYW1wZWRWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxuICAgICAgICAgICAgICAgICAgICBjbGFtcGVkVmFsdWUgPSBjbGFtcFRvUmFuZ2VMaW1pdHMocmVzdWx0LCBob2xkZXIuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGNsYW1wZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBGYXRhbCBlcnJvcjogVW5hYmxlIHRvIHNldCB0aGUgY2xhbXBlZCB2YWx1ZSAnJHtjbGFtcGVkVmFsdWV9Jy5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzQmVlbkNsYW1wZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0JlZW5TZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjbGFtcGVkVmFsdWU7IC8vIFRoaXMgaXMgdXNlZCBvbmx5IGZvciBzZXR0aW5nIHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIHJlc3VsdHMgaW4gYSB2YWx1ZSAnJHtyZXN1bHR9JyB0aGF0IGlzIG91dHNpZGUgb2YgdGhlIG1pbmltdW0gWyR7aG9sZGVyLnNldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtIFske2hvbGRlci5zZXR0aW5ncy5tYXhpbXVtVmFsdWV9XSB2YWx1ZSByYW5nZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIC4uLmFuZCBub3RoaW5nIGVsc2Ugc2hvdWxkIGJlIGNoYW5nZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDcuIFRoZW4gbGFzdGx5LCBzZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGF0IHRoZSByaWdodCBsb2dpY2FsIHBsYWNlXG4gICAgICAgIGxldCBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXI7XG4gICAgICAgIGlmICh2YWx1ZUhhc0JlZW5TZXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVIYXNCZWVuQ2xhbXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgZS50YXJnZXQudmFsdWUubGVuZ3RoIC0gaG9sZGVyLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCk7IC8vIFRoaXMgcHV0cyB0aGUgY2FyZXQgb24gdGhlIHJpZ2h0IG9mIHRoZSBsYXN0IGRlY2ltYWwgcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgZS50YXJnZXQudmFsdWUubGVuZ3RoKTsgLy8gLi5hbmQgdGhpcyBvbiB0aGUgZmFyIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2UgaWYgdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjbGFtcGVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyB1c2VkLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0cnVuY2F0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW5ldmVyIG9uZSBvciBtdWx0aXBsZSBjaGFyYWN0ZXJzIGFyZSBwYXN0ZWQsIHRoaXMgbWVhbnMgd2UgaGF2ZSB0byBtYW5hZ2UgdGhlIHBvdGVudGlhbCB0aG91c2FuZCBzZXBhcmF0b3JzIHRoYXQgY291bGQgYmUgYWRkZWQgYnkgdGhlIGZvcm1hdHRpbmdcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyID0gZmluZENhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcihyZXN1bHQsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLCBlLnRhcmdldC52YWx1ZSwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gOC4gV2UgbWFrZSBzdXJlIHdlIHNlbmQgYW4gaW5wdXQgZXZlbnQgb25seSBpZiB0aGUgcmVzdWx0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSBpbml0aWFsIHZhbHVlIGJlZm9yZSB0aGUgcGFzdGVcbiAgICAgICAgaWYgKHZhbHVlSGFzQmVlblNldCAmJiBpbml0aWFsRm9ybWF0dGVkVmFsdWUgIT09IGUudGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICAvLyBPbiBhICdub3JtYWwnIG5vbi1hdXRvTnVtZXJpYyBpbnB1dCwgYW4gYGlucHV0YCBldmVudCBpcyBzZW50IHdoZW4gYSBwYXN0ZSBpcyBkb25lLiBXZSBtaW1pYyB0aGF0LlxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gZm9jdXNpbmcgb3V0IG9mIHRoZSBpbnB1dCwgd2UgY2hlY2sgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLCB0aGVuIHdlIHNlbmQgYSBgY2hhbmdlYCBldmVudCAoc2luY2UgdGhlIG5hdGl2ZSBvbmUgd291bGQgaGF2ZSBiZWVuIHByZXZlbnRlZCBieSBgZS5wcmV2ZW50RGVmYXVsdCgpYCBjYWxsZWQgaW4gdGhlIG90aGVyIGV2ZW50IGxpc3RlbmVycykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25CbHVyKGhvbGRlciwgZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci52YWx1ZU9uRm9jdXMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnY2hhbmdlJywgZS50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBzZW5kIGEgc2Vjb25kIGNoYW5nZSBldmVudCAodGhhdCBzb21laG93IGdldHMgcGlja2VkIHVwIGJ5IGpRdWVyeSwgYnV0IG5vdCBieSBgYWRkRXZlbnRMaXN0ZW5lcigpYCAvL0ZJWE1FIEtOT1dOIEJVRyA6IFRoaXMgZG9lcyBub3QgcHJldmVudCB0aGUgc2Vjb25kIGNoYW5nZSBldmVudCB0byBiZSBwaWNrZWQgdXAgYnkgalF1ZXJ5LCB3aGljaCBhZGRzICcuMDAnIGF0IHRoZSBlbmQgb2YgYW4gaW50ZWdlclxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ3N1Ym1pdCcgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25TdWJtaXQoJHRoaXMsIGhvbGRlcikge1xuICAgICAgICAkdGhpcy5jbG9zZXN0KCdmb3JtJykub24oJ3N1Ym1pdC5hdXRvTnVtZXJpYycsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MudW5mb3JtYXRPblN1Ym1pdCkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgalF1ZXJ5IHNlbGVjdGVkIGlucHV0IGlmIHRoZSB0YWcgYW5kIHR5cGUgYXJlIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnwqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKCR0aGlzKSB7XG4gICAgICAgIC8vIFN1cHBvcnRlZCBpbnB1dCB0eXBlXG4gICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcblxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgaW5wdXQgdHlwZXNcbiAgICAgICAgaWYgKCEkaW5wdXQgJiYgJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBpbnB1dCB0eXBlIFwiJHskdGhpcy5wcm9wKCd0eXBlJyl9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGZvciBub24tc3VwcG9ydGVkIHRhZ3NcbiAgICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRUYWcgPSAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VGFnICE9PSAnaW5wdXQnICYmICFpc0luQXJyYXkoY3VycmVudEVsZW1lbnRUYWcsIGFsbG93ZWRUYWdMaXN0KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIDwke2N1cnJlbnRFbGVtZW50VGFnfT4gdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkaW5wdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91dGluZSB0byBmb3JtYXQgdGhlIGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJGlucHV0IGpRdWVyeS1zZWxlY3RlZCA8aW5wdXQ+IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChzZXR0aW5ncywgJGlucHV0LCAkdGhpcykge1xuICAgICAgICBsZXQgc2V0VmFsdWUgPSB0cnVlO1xuXG4gICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBoYXMgYmVlbiBzZXQgYnkgdGhlIGRldiwgYnV0IG5vdCBkaXJlY3RseSBhcyBhbiBhdHRyaWJ1dGUgaW4gdGhlIGh0bWwsIHRoZW4gaXQgdGFrZXNcbiAgICAgICAgICAgICAqIHByZWNlZGVuY2UgYW5kIHNob3VsZCBnZXQgZm9ybWF0dGVkIG9uIGluaXQgKGlmIHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXG4gICAgICAgICAgICAgKiBkZXZlbG9wZXIgd2FudHMgaXQgZm9ybWF0dGVkIG9uIGluaXQgKGNmLiBgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZGApKS5cbiAgICAgICAgICAgICAqIE5vdGU7IHRoaXMgaXMgdHJ1ZSB3aGF0ZXZlciB0aGUgZGV2ZWxvcGVyIGhhcyBzZXQgZm9yIGBkYXRhLWFuLWRlZmF1bHRgIGluIHRoZSBodG1sIChhc3AubmV0IHVzZXJzKS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvdGhlciB3b3JkcyA6IGlmIGBkZWZhdWx0VmFsdWVPdmVycmlkZWAgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBkZXZlbG9wZXIgaXMgdHJ5aW5nIHRvIHByZXZlbnQgcG9zdGJhY2sgcHJvYmxlbXMuXG4gICAgICAgICAgICAgKiBCdXQgaWYgYGlucHV0LnZhbHVlYCBpcyBzZXQgdG8gYSBudW1iZXIsIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCwgdGhlbiBpdCBtZWFucyB0aGUgZGV2IGhhc1xuICAgICAgICAgICAgICogY2hhbmdlZCB0aGUgaW5wdXQgdmFsdWUsIGFuZCB0aGVuIGl0IG1lYW5zIHdlIHNob3VsZCBub3Qgb3ZlcndyaXRlIGhpcyBvd24gZGVjaXNpb24gdG8gZG8gc28uXG4gICAgICAgICAgICAgKiBIZW5jZSwgaWYgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBpcyBub3QgbnVsbCwgYnV0IGBpbnB1dC52YWx1ZWAgaXMgYSBudW1iZXIgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LFxuICAgICAgICAgICAgICogd2Ugc2hvdWxkIGlnbm9yZSBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGFsdG9nZXRoZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgaXNVbmRlZmluZWRPck51bGxPckVtcHR5KCR0aGlzLmF0dHIoJ3ZhbHVlJykpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGB2YWx1ZWAgaXMgdmFsaWQgb3Igbm90XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdGVkQ3VycmVudFZhbHVlID0gcGFyc2VGbG9hdChjdXJyZW50VmFsdWUucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAgICAgICAgIC8vVE9ETyBSZXBsYWNlIHdoYXRldmVyIGxvY2FsZSBjaGFyYWN0ZXIgaXMgdXNlZCBieSBhICcuJywgYW5kIG5vdCBvbmx5IHRoZSBjb21tYSAnLCdcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHRlc3RlZEN1cnJlbnRWYWx1ZSkgJiYgSW5maW5pdHkgIT09IHRlc3RlZEN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgdGVzdGVkQ3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QsIGluZm9ybSB0aGUgZGV2ZWxvcGVyIHRoYXQgbm90aGluZyB1c2FibGUgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2N1cnJlbnRWYWx1ZX1dIHVzZWQgaW4gdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIHZhbHVlIGF1dG9OdW1lcmljIGNhbiB3b3JrIHdpdGguYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBDaGVja3MgZm9yIDpcbiAgICAgICAgICAgICAgICAgKiAtIHBhZ2UgcmVsb2FkIGZyb20gYmFjayBidXR0b24sIGFuZFxuICAgICAgICAgICAgICAgICAqIC0gQVNQLm5ldCBmb3JtIHBvc3QgYmFja1xuICAgICAgICAgICAgICAgICAqICAgICAgVGhlIGZvbGxvd2luZyBIVE1MIGRhdGEgYXR0cmlidXRlIGlzIFJFUVVJUkVEIChkYXRhLWFuLWRlZmF1bHQ9XCJzYW1lIHZhbHVlIGFzIHRoZSB2YWx1ZSBhdHRyaWJ1dGVcIilcbiAgICAgICAgICAgICAgICAgKiAgICAgIGV4YW1wbGU6IDxhc3A6VGV4dEJveCBydW5hdD1cInNlcnZlclwiIGlkPVwic29tZUlEXCIgdGV4dD1cIjEyMzQuNTZcIiBkYXRhLWFuLWRlZmF1bHQ9XCIxMjM0LjU2XCI+XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy9UT0RPIFJlcGxhY2Ugd2hhdGV2ZXIgbG9jYWxlIGNoYXJhY3RlciBpcyB1c2VkIGJ5IGEgJy4nLCBhbmQgbm90IG9ubHkgdGhlIGNvbW1hICcsJywgYmFzZWQgb24gdGhlIGxvY2FsZSB1c2VkIGJ5IHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZS50b1N0cmluZygpICE9PSBjdXJyZW50VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSA9PT0gbnVsbCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGN1cnJlbnRWYWx1ZSAhPT0gJHRoaXMuYXR0cigndmFsdWUnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgJHRoaXMuYXR0cigndHlwZScpID09PSAnaGlkZGVuJyAmJiAhaXNOdW1iZXIoY3VycmVudFZhbHVlLnJlcGxhY2UoJywnLCAnLicpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmIHNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB2YWx1ZSBzaG91bGQgTk9UIGJlIHNhdmVkIGluIHNlc3Npb25TdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvU3RyaXA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQoY3VycmVudFZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gKChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8IChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnICYmIGNvbnRhaW5zKGN1cnJlbnRWYWx1ZSwgJy0nKSk/Jy0nICsgc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHRvU3RyaXAsIHNldHRpbmdzLCB0cnVlKTpzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModG9TdHJpcCwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhbHdheXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnemVybyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXRWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpICYmICR0aGlzLnRleHQoKSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSA9PT0gJHRoaXMudGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlIHRoZSB1c2VyIGV4cGVyaWVuY2UgYnkgbW9kaWZ5aW5nIHRoZSBkZWZhdWx0IGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGRlcGVuZGluZyBvbiBgY3VycmVuY3lTeW1ib2xgIGFuZCBgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogSWYgdGhlIHVzZXIgaGFzIG5vdCBzZXQgdGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiAoYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCksIGJ1dCBoYXMgc2V0IGEgY3VycmVuY3kgc3ltYm9sIChgY3VycmVuY3lTeW1ib2xgKSxcbiAgICAgKiB0aGVuIHdlIG1vZGlmeSB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIGluIG9yZGVyIHRvIGtlZXAgdGhlIHJlc3VsdGluZyBvdXRwdXQgbG9naWNhbCBieSBkZWZhdWx0IDpcbiAgICAgKiAtIFwiJC0xLDIzNC41NlwiIGluc3RlYWQgb2YgXCItJDEsMjM0LjU2XCIgKHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInJcIn0pXG4gICAgICogLSBcIi0xLDIzNC41NiRcIiBpbnN0ZWFkIG9mIFwiMSwyMzQuNTYtJFwiICh7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3RQTmVnT3B0aW9uKG9wdGlvbnMsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vVE9ETyBNZXJnZSB0aGUgb3B0aW9ucyBhbmQgc2V0dGluZ3MgcGFyYW1ldGVyIHRvIHVzZSBvbmx5IGBzZXR0aW5nc2BcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChvcHRpb25zKSAmJiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkob3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkgJiYgb3B0aW9ucy5jdXJyZW5jeVN5bWJvbCAhPT0gJycpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSAncCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9ICdyJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5emUgYW5kIHNhdmUgdGhlIG1pbmltdW1WYWx1ZSBhbmQgbWF4aW11bVZhbHVlIGludGVnZXIgc2l6ZSBmb3IgbGF0ZXIgdXNlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMoc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IFttYXhpbXVtVmFsdWVJbnRlZ2VyUGFydF0gPSBzZXR0aW5ncy5tYXhpbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBsZXQgW21pbmltdW1WYWx1ZUludGVnZXJQYXJ0XSA9ICghc2V0dGluZ3MubWluaW11bVZhbHVlICYmIHNldHRpbmdzLm1pbmltdW1WYWx1ZSAhPT0gMCk/W106c2V0dGluZ3MubWluaW11bVZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgbWF4aW11bVZhbHVlSW50ZWdlclBhcnQgPSBtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydC5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICBtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydCA9IG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0LnJlcGxhY2UoJy0nLCAnJyk7XG5cbiAgICAgICAgc2V0dGluZ3MubUludFBvcyA9IE1hdGgubWF4KG1heGltdW1WYWx1ZUludGVnZXJQYXJ0Lmxlbmd0aCwgMSk7XG4gICAgICAgIHNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heChtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSBgZGVjaW1hbFBsYWNlc092ZXJyaWRlYCBhcyBuZWVkZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3RNRGVjT3B0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgIGlmICghaXNOdWxsKHNldHRpbmdzLnNjYWxlRGl2aXNvcikgJiYgIWlzTnVsbChzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpKSB7XG4gICAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgd2l0aCB0aGUgb25lIGRlZmluZWQgd2l0aCB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzIHRvIHNob3cgd2hlbiBub3QgaW4gZm9jdXMsIGlmIHNldFxuICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKHNldHRpbmdzLm1pbmltdW1WYWx1ZSwgc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy5vRGVjID0gU3RyaW5nKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG5cbiAgICAgICAgLy8gTW9zdCBjYWxjdWx1cyBhc3N1bWUgYGRlY2ltYWxQbGFjZXNPdmVycmlkZWAgaXMgYW4gaW50ZWdlciwgdGhlIGZvbGxvd2luZyBzdGF0ZW1lbnQgbWFrZXMgaXQgY2xlYXIgKG90aGVyd2lzZSBoYXZpbmcgaXQgYXMgYSBzdHJpbmcgbGVhZHMgdG8gcHJvYmxlbXMgaW4gcm91bmRpbmcgZm9yIGluc3RhbmNlKVxuICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBOdW1iZXIoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRzQWx0ZXJuYXRpdmVEZWNpbWFsU2VwYXJhdG9yQ2hhcmFjdGVyKHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJiBOdW1iZXIoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSA+IDApIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyID09PSAnLicgJiYgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciAhPT0gJywnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlID0gJywnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyID09PSAnLCcgJiYgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlID0gJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVzIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnMoc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgYU5lZ1JlZyA9IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcj9gKFstXFxcXCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfV0/KWA6JygtPyknO1xuICAgICAgICBzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwID0gYU5lZ1JlZztcbiAgICAgICAgc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfVteLSR7KHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcj9gXFxcXCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfWA6JycpfVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9XFxcXGRdLio/KFxcXFxkfFxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9XFxcXGQpYCk7XG4gICAgICAgIHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgKFxcXFxkXFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0/KVteXFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1cXFxcZF1cXFxcRCokYCk7XG5cbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9YDtcbiAgICAgICAgc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZ2knKTtcbiAgICAgICAgc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfSg/OlxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9PyhcXFxcZCtcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfVxcXFxkKyl8KFxcXFxkKig/OlxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9XFxcXGQqKT8pKWApO1xuXG4gICAgICAgIC8vIFVzaW5nIHRoaXMgcmVnZXggdmVyc2lvbiBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZHwkKWAgZW50aXJlbHkgY2xlYXIgdGhlIGlucHV0IG9uIGJsdXJcbiAgICAgICAgc2V0dGluZ3Muc3RyaXBSZWcgPSBuZXcgUmVnRXhwKGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKFxcXFxkKWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgdXNlciBzZXR0aW5ncyB0byBtYWtlIHRoZW0gJ2V4cGxvaXRhYmxlJyBsYXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcyhzZXR0aW5ncykge1xuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgJ3RydWUnIGFuZCAnZmFsc2UnIHRvIHJlYWwgQm9vbGVhblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUgPT09ICd0cnVlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydCBudW1iZXJzIGluIG9wdGlvbnMgdG8gc3RyaW5nc1xuICAgICAgICAgICAgLy9UT0RPIGlmIGEgdmFsdWUgaXMgYWxyZWFkeSBvZiB0eXBlICdOdW1iZXInLCBzaG91bGRuJ3Qgd2Uga2VlcCBpdCBhcyBhIG51bWJlciBmb3IgZnVydGhlciBtYW5pcHVsYXRpb24sIGluc3RlYWQgb2YgdXNpbmcgYSBzdHJpbmc/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBrZXkgIT09ICdhU2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIG9sZCBzZXR0aW5ncyBvcHRpb25zIG5hbWUgdG8gbmV3IG9uZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKG9wdGlvbnMpIHtcbiAgICAgICAgLy9UT0RPIERlbGV0ZSB0aGlzIGZ1bmN0aW9uIG9uY2UgdGhlIG9sZCBvcHRpb25zIGFyZSBub3QgdXNlZCBhbnltb3JlXG4gICAgICAgIGNvbnN0IG9sZE9wdGlvbnNDb252ZXJ0ZXIgPSB7XG4gICAgICAgICAgICAvLyBPbGQgb3B0aW9uIG5hbWUsIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBuZXcgb3B0aW9uXG4gICAgICAgICAgICBhU2VwICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RpZ2l0R3JvdXBTZXBhcmF0b3InLFxuICAgICAgICAgICAgblNlcCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdub1NlcGFyYXRvck9uRm9jdXMnLFxuICAgICAgICAgICAgZEdyb3VwICAgICAgICAgICAgICAgICAgICAgICA6ICdkaWdpdGFsR3JvdXBTcGFjaW5nJyxcbiAgICAgICAgICAgIGFEZWMgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbENoYXJhY3RlcicsXG4gICAgICAgICAgICBhbHREZWMgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZScsXG4gICAgICAgICAgICBhU2lnbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ2N1cnJlbmN5U3ltYm9sJyxcbiAgICAgICAgICAgIHBTaWduICAgICAgICAgICAgICAgICAgICAgICAgOiAnY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQnLFxuICAgICAgICAgICAgcE5lZyAgICAgICAgICAgICAgICAgICAgICAgICA6ICduZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCcsXG4gICAgICAgICAgICBhU3VmZml4ICAgICAgICAgICAgICAgICAgICAgIDogJ3N1ZmZpeFRleHQnLFxuICAgICAgICAgICAgb0xpbWl0cyAgICAgICAgICAgICAgICAgICAgICA6ICdvdmVycmlkZU1pbk1heExpbWl0cycsXG4gICAgICAgICAgICB2TWF4ICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21heGltdW1WYWx1ZScsXG4gICAgICAgICAgICB2TWluICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21pbmltdW1WYWx1ZScsXG4gICAgICAgICAgICBtRGVjICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScsXG4gICAgICAgICAgICBlRGVjICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnLFxuICAgICAgICAgICAgc2NhbGVEZWNpbWFsICAgICAgICAgICAgICAgICA6ICdzY2FsZURlY2ltYWxQbGFjZXMnLFxuICAgICAgICAgICAgYVN0b3IgICAgICAgICAgICAgICAgICAgICAgICA6ICdzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlJyxcbiAgICAgICAgICAgIG1Sb3VuZCAgICAgICAgICAgICAgICAgICAgICAgOiAncm91bmRpbmdNZXRob2QnLFxuICAgICAgICAgICAgYVBhZCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdhbGxvd0RlY2ltYWxQYWRkaW5nJyxcbiAgICAgICAgICAgIG5CcmFja2V0ICAgICAgICAgICAgICAgICAgICAgOiAnbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXInLFxuICAgICAgICAgICAgd0VtcHR5ICAgICAgICAgICAgICAgICAgICAgICA6ICdlbXB0eUlucHV0QmVoYXZpb3InLFxuICAgICAgICAgICAgbFplcm8gICAgICAgICAgICAgICAgICAgICAgICA6ICdsZWFkaW5nWmVybycsXG4gICAgICAgICAgICBhRm9ybSAgICAgICAgICAgICAgICAgICAgICAgIDogJ2Zvcm1hdE9uUGFnZUxvYWQnLFxuICAgICAgICAgICAgc051bWJlciAgICAgICAgICAgICAgICAgICAgICA6ICdzZWxlY3ROdW1iZXJPbmx5JyxcbiAgICAgICAgICAgIGFuRGVmYXVsdCAgICAgICAgICAgICAgICAgICAgOiAnZGVmYXVsdFZhbHVlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgdW5TZXRPblN1Ym1pdCAgICAgICAgICAgICAgICA6ICd1bmZvcm1hdE9uU3VibWl0JyxcbiAgICAgICAgICAgIG91dHB1dFR5cGUgICAgICAgICAgICAgICAgICAgOiAnb3V0cHV0Rm9ybWF0JyxcbiAgICAgICAgICAgIGRlYnVnICAgICAgICAgICAgICAgICAgICAgICAgOiAnc2hvd1dhcm5pbmdzJyxcbiAgICAgICAgICAgIC8vIEN1cnJlbnQgb3B0aW9ucyA6XG4gICAgICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5vU2VwYXJhdG9yT25Gb2N1cyAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGlnaXRhbEdyb3VwU3BhY2luZyAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgOiB0cnVlLFxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiB0cnVlLFxuICAgICAgICAgICAgc3VmZml4VGV4dCAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvdmVycmlkZU1pbk1heExpbWl0cyAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGVEaXZpc29yICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzY2FsZURlY2ltYWxQbGFjZXMgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNjYWxlU3ltYm9sICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSAgICA6IHRydWUsXG4gICAgICAgICAgICBvbkludmFsaWRQYXN0ZSAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dEZWNpbWFsUGFkZGluZyAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGVtcHR5SW5wdXRCZWhhdmlvciAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBmb3JtYXRPblBhZ2VMb2FkICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlT3ZlcnJpZGUgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICB1bmZvcm1hdE9uU3VibWl0ICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdCAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2hvd1dhcm5pbmdzICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBmYWlsT25Vbmtub3duT3B0aW9uICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIC8vRklYTUUgRmluZCBhIHdheSB0byBleGNsdWRlIHRob3NlIGludGVybmFsIGRhdGEgZnJvbSB0aGUgc2V0dGluZ3Mgb2JqZWN0IChpZGVhbGx5IGJ5IHVzaW5nIGFub3RoZXIgb2JqZWN0LCBvciBiZXR0ZXIgeWV0LCBjbGFzcyBhdHRyaWJ1dGVzKSAtLT5cbiAgICAgICAgICAgIG9uT2ZmICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHJ1bk9uY2UgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHJhd1ZhbHVlICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHRyYWlsaW5nTmVnYXRpdmUgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGNhcmV0Rml4ICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHRocm93SW5wdXQgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmlwICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnbkNoYXJhY3RlcjogdHJ1ZSxcbiAgICAgICAgICAgIG1JbnRQb3MgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG1JbnROZWcgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9EZWMgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9QYWQgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9CcmFja2V0ICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9TZXAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9TaWduICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9TdWZmaXggICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGFOZWdSZWdBdXRvU3RyaXAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNraXBGaXJzdEF1dG9TdHJpcCAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNraXBMYXN0QXV0b1N0cmlwICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93ZWRBdXRvU3RyaXAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG51bVJlZ0F1dG9TdHJpcCAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmlwUmVnICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGhvbGRlciAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW9uIGlzIGEgJ25ldycgb3B0aW9uLCB3ZSBjb250aW51ZSBsb29waW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvbGRPcHRpb25zQ29udmVydGVyLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSB3ZSBoYXZlIGFuICdvbGQnIG9wdGlvbiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmcoYFlvdSBhcmUgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgb3B0aW9uIG5hbWUgJyR7b3B0aW9ufScuIFBsZWFzZSB1c2UgJyR7b2xkT3B0aW9uc0NvbnZlcnRlcltvcHRpb25dfScgaW5zdGVhZCBmcm9tIG5vdyBvbi4gVGhlIG9sZCBvcHRpb24gbmFtZSB3aWxsIGJlIGRyb3BwZWQgc29vbi5gLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIHdlIG1vZGlmeSB0aGUgaW5pdGlhbCBvcHRpb24gb2JqZWN0IHRvIHVzZSB0aGUgbmV3IG9wdGlvbnMgaW5zdGVhZCBvZiB0aGUgb2xkIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl1dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLm9yIHRoZSBvcHRpb24gbmFtZSBpcyB1bmtub3duLiBUaGlzIG1lYW5zIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBvcHRpb25zIG9iamVjdCwgdGhlcmVmb3JlIHdlIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBPcHRpb24gbmFtZSAnJHtvcHRpb259JyBpcyB1bmtub3duLiBQbGVhc2UgZml4IHRoZSBvcHRpb25zIHBhc3NlZCB0byBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5c2UgdGhlIHNldHRpbmdzL29wdGlvbnMgcGFzc2VkIGJ5IHRoZSB1c2VyLCB2YWxpZGF0ZSBhbmQgY2xlYW4gdGhlbSwgdGhlbiByZXR1cm4gdGhlbS5cbiAgICAgKiBOb3RlOiBUaGlzIHJldHVybnMgYG51bGxgIGlmIHNvbWVob3cgdGhlIHNldHRpbmdzIHJldHVybmVkIGJ5IGpRdWVyeSBpcyBub3QgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSB1cGRhdGUgLSBJZiBUUlVFLCB0aGVuIHRoZSBzZXR0aW5ncyBhbHJlYWR5IGV4aXN0cyBhbmQgdGhpcyBmdW5jdGlvbiBvbmx5IHVwZGF0ZXMgdGhlbSBpbnN0ZWFkIG9mIHJlY3JlYXRpbmcgdGhlbSBmcm9tIHNjcmF0Y2hcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzLCB1cGRhdGUgPSBmYWxzZSkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgXCJhdXRvTnVtZXJpY1wiIHNldHRpbmdzLiBJZiB0aGV5IGRvIG5vdCBleGlzdCwgaXQgcmV0dXJucyBcInVuZGVmaW5lZFwiLlxuICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHVzZWQgb2xkIG9wdGlvbnMsIHdlIGNvbnZlcnQgdGhlbSB0byBuZXcgb25lc1xuICAgICAgICBpZiAodXBkYXRlIHx8ICFpc051bGwob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZSB8fCBpc1VuZGVmaW5lZChzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHNldHRpbmdzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgZ3JhYiBhbnkgc2V0dGluZ3MgY3JlYXRlIHRoZW0gZnJvbSB0aGUgZGVmYXVsdCBvbmVzIGFuZCBjb21iaW5lIHRoZW0gd2l0aCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIGdlbmVyYXRlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgSFRNTDUgZGF0YSwgaWYgaXQgZG9lc24ndCBleGlzdCwgd2UnbGwgZ2V0IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdEYXRhID0gJHRoaXMuZGF0YSgpO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgdGFnRGF0YSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBvbk9mZiAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuT25jZSAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJhd1ZhbHVlICAgICAgICA6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ05lZ2F0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRGaXggICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRocm93SW5wdXQgICAgICA6IHRydWUsIC8vIFRocm93IGlucHV0IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHN0cmlwICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICA6IGFsbG93ZWRUYWdMaXN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHVzZXIgc2V0dGluZ3MgdG8gbWFrZSB0aGVtICdleHBsb2l0YWJsZSdcbiAgICAgICAgICAgIHRyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcyhzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIEltcHJvdmUgdGhlIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGlmIG5lZWRlZFxuICAgICAgICAgICAgY29ycmVjdFBOZWdPcHRpb24ob3B0aW9ucywgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIG5lZ2F0aXZlIHNpZ24gaWYgbmVlZGVkXG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSBzZXR0aW5ncy5taW5pbXVtVmFsdWUgPCAwID8gJy0nIDogJyc7XG5cbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgY2hhbmdlcyB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IChmcm9tIHRoZSBvcmlnaW5hbCBhdXRvQ29kZSgpIGZ1bmN0aW9uKVxuICAgICAgICAgICAgcnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0KCR0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBjYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcyhzZXR0aW5ncyk7XG4gICAgICAgICAgICBjb3JyZWN0TURlY09wdGlvbihzZXR0aW5ncyk7XG4gICAgICAgICAgICBzZXRzQWx0ZXJuYXRpdmVEZWNpbWFsU2VwYXJhdG9yQ2hhcmFjdGVyKHNldHRpbmdzKTtcbiAgICAgICAgICAgIGNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzKTtcblxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNldHRpbmdzXG4gICAgICAgICAgICB2YWxpZGF0ZShzZXR0aW5ncywgZmFsc2UpOyAvLyBUaHJvd3MgaWYgbmVjZXNzYXJ5XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzLCBzY2FsZURpdmlzb3IgJiBub1NlcGFyYXRvck9uRm9jdXMgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxuICAgICAgICAgICAga2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkoc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBuZXcgc2V0dGluZ3NcbiAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZHMgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljXG4gICAgICovXG4gICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBpbml0aWF0ZSBhdXRvTnVtZXJpYyBhbmQgYXR0YWNoIHRoZSBzZXR0aW5ncyAob3B0aW9ucyBjYW4gYmUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyKVxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2RpZ2l0R3JvdXBTZXBhcmF0b3I6IFwiLlwiLCBkZWNpbWFsQ2hhcmFjdGVyOiBcIixcIiwgY3VycmVuY3lTeW1ib2w6ICfigqwgJ30pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcpOyAgICAgICAgICAgIC8vIEluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCk7ICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnLCB7b3B0aW9uc30pOyAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKHtvcHRpb25zfSk7ICAgICAgICAgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHsqfHtzdGF0ZW1lbnRzLCBicmFuY2hlcywgbGluZXMsIGZ1bmN0aW9ucywgZXhjbHVkZXMsIG92ZXJyaWRlc318e3N0YXRlbWVudHMsIGJyYW5jaGVzLCBsaW5lcywgZnVuY3Rpb25zLCBleGNsdWRlc318e3N0YXRlbWVudHMsIGxpbmVzLCBicmFuY2hlcywgZnVuY3Rpb25zLCBleGNsdWRlc319XG4gICAgICAgICAqL1xuICAgICAgICBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9IGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKCR0aGlzKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QgdGhhdCBzdG9yZSB0aGUgZmllbGQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvbGRlciA9IGdldEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5ydW5PbmNlICYmIHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChzZXR0aW5ncywgJGlucHV0LCAkdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucnVuT25jZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGV2ZW50cyBsaXN0ZW5lcnMgdG8gc3VwcG9ydGVkIGlucHV0IHR5cGVzIChcInRleHRcIiwgXCJoaWRkZW5cIiwgXCJ0ZWxcIiBhbmQgbm8gdHlwZSlcbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGUgPT4geyBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGUgPT4geyBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBlID0+IHsgb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZSA9PiB7IG9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4geyBvbktleWRvd24oaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZSA9PiB7IG9uS2V5cHJlc3MoaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZSA9PiB7IG9uS2V5dXAoaG9sZGVyLCBzZXR0aW5ncywgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZSA9PiB7IG9uQmx1cihob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBlID0+IHsgb25QYXN0ZSgkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBvblN1Ym1pdCgkdGhpcywgaG9sZGVyKTsgLy9UT0RPIFN3aXRjaCB0byBgYWRkRXZlbnRMaXN0ZW5lcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHN0b3AgYW5kIHJlbW92ZSBhdXRvTnVtZXJpYyBmb3IgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgICAgICogTm90ZTogdGhpcyBkb2VzIG5vdCByZW1vdmUgdGhlIGZvcm1hdHRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcImRlc3Ryb3lcIik7IC8vIERlc3Ryb3lzIGF1dG9OdW1lcmljIG9uIHRoaXMgc2VsZWN0ZWQgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlRGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub2ZmKCcuYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGNsZWFyIHRoZSB2YWx1ZSBmcm9tIHNlc3Npb25TdG9yYWdlIChvciBjb29raWUsIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwid2lwZVwiKTsgLy8gUmVtb3ZlcyBzZXNzaW9uIHN0b3JhZ2UgYW5kIGNvb2tpZXMgZnJvbSBtZW1vcnlcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgd2lwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICd3aXBlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0aGF0IHVwZGF0ZXMgdGhlIGF1dG9OdW1lcmljIHNldHRpbmdzLlxuICAgICAgICAgKiBJdCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGlmIG5lZWRlZC5cbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHtkaWdpdEdyb3VwU2VwYXJhdG9yOiBcIi5cIiwgZGVjaW1hbENoYXJhY3RlcjogXCIsXCIsIGN1cnJlbmN5U3ltYm9sOiAn4oKsICd9KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwidXBkYXRlXCIsIHtvcHRpb25zfSk7IC8vIFVwZGF0ZXMgdGhlIHNldHRpbmdzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QgdGhhdCBzdG9yZSB0aGUgZmllbGQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIGdldEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJHRoaXMudmFsKCkgIT09ICcnIHx8ICR0aGlzLnRleHQoKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzdHJpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBmb3JtYXQgdGhlIHZhbHVlIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICAgICAgICogSWYgdGhlIHZhbHVlIGlzIHBhc3NlZCBhcyBhIHN0cmluZywgaXQgY2FuIGJlIGFuIGludGVnZXIgJzEyMzQnIG9yIGEgZG91YmxlICcxMjM0LjU2Nzg5J1xuICAgICAgICAgKiBhbmQgbXVzdCBjb250YWluIG9ubHkgbnVtYmVycyBhbmQgb25lIGRlY2ltYWwgKHBlcmlvZCkgY2hhcmFjdGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnc2V0JywgJ3ZhbHVlJyk7IC8vIEZvcm1hdHMgdGhlIHZhbHVlIGJlaW5nIHBhc3NlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyp9IG5ld1ZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IG51bGwgfHwgaXNVbmRlZmluZWQobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1RPRE8gVGhpcyBsb29rcyBhIGxvdCBsaWtlIGBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgpYC4gSXMgdGhhdCBuZWNlc3Nhcnk/IENhbiB0aGUgaW5wdXQgZWxlbWVudCBiZSBjaGFuZ2VkIHNpbmNlIGF1dG9OdW1lcmljIGhhcyBiZWVuIGluaXRpYWxpemVkP1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcInNldFwiIG1ldGhvZGApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFsbG93cyBsb2NhbGUgZGVjaW1hbCBzZXBhcmF0b3IgdG8gYmUgYSBjb21tYSAtIG5vIHRob3VzYW5kIHNlcGFyYXRvciBhbGxvd2VkXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmcm9tTG9jYWxlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgYmVpbmcgc2V0IGlzIG5vdCBudW1lcmljXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihOdW1iZXIodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nIFwic2V0XCIgaXMgbm90IG51bWVyaWMgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgdXNlZCBhcHByb3ByaWF0ZWx5LmAsIHNldHRpbmdzLnNob3dXYXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCAmJiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2tzIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiBtYXggcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQgfHwgaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgIXNldHRpbmdzLm9uT2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gKHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykgPyBzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMgOiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgPT09IG51bGwgJiYgc2V0dGluZ3Muc2NhbGVEaXZpc29yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSAmJiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2F0dGVtcHRlZFZhbHVlfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgb2YgdGhlIG1pbmltdW1WYWx1ZSBbJHtzZXR0aW5ncy5taW5pbXVtVmFsdWV9XSBhbmQgbWF4aW11bVZhbHVlIFske3NldHRpbmdzLm1heGltdW1WYWx1ZX1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5zY2FsZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2w7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byB1bi1mb3JtYXQgaW5wdXRzLlxuICAgICAgICAgKiBUaGlzIGlzIGhhbmR5IHRvIHVzZSByaWdodCBiZWZvcmUgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB2YWx1ZXMgYXJlIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZ3MgKGllLiBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIpLCB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2QuXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiLCBvciBldmVuIHBsYWluIG51bWJlcnMuXG4gICAgICAgICAqIFBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHVuU2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkdGhpcy5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gcmUtZm9ybWF0IGlucHV0cy5cbiAgICAgICAgICogVGhpcyBpcyBoYW5keSB0byB1c2UgcmlnaHQgYWZ0ZXIgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgJ3VuU2V0JyBtZXRob2QgdG8gcmVmb3JtYXQgdGhlIGlucHV0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygncmVTZXQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgcmVTZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy52YWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgLy9UT0RPIFdoeSB3b3VsZCB3ZSBuZWVkIHRvIGdldCBhIG5ldyByZWZlcmVuY2UgdG8gJHRoaXMgc2luY2UgaXQgaGFzIGJlZW4gZG9uZSBpbiBgaW5pdCgpYD9cbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAvL1RPRE8gVGhpcyBsb29rcyBhIGxvdCBsaWtlIGBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgpYC4gSXMgdGhhdCBuZWNlc3Nhcnk/IENhbiB0aGUgaW5wdXQgZWxlbWVudCBiZSBjaGFuZ2VkIHNpbmNlIGF1dG9OdW1lcmljIGhhcyBiZWVuIGluaXRpYWxpemVkP1xuICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJnZXRcIiBtZXRob2QuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAkdGhpcy5lcSgwKS52YWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudGV4dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgXCI8JHskdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKX0+XCIgdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKC9cXGQvKS50ZXN0KHZhbHVlKSB8fCBOdW1iZXIodmFsdWUpID09PSAwKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ydW5PbmNlIHx8IHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiBhIG51bWVyaWMgc3RyaW5nXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHZhbHVlLCBidXQgZm9sbG93aW5nIHRoZSBgb3V0cHV0Rm9ybWF0YCBzZXR0aW5nLCB3aGljaCBtZWFucyB0aGUgb3V0cHV0IGNhbiBlaXRoZXIgYmUgOlxuICAgICAgICAgKiAtIGEgc3RyaW5nICh0aGF0IGNvdWxkIG9yIGNvdWxkIG5vdCByZXByZXNlbnQgYSBudW1iZXIgKGllLiBcIjEyMzQ1LDY3LVwiKSksIG9yXG4gICAgICAgICAqIC0gYSBwbGFpbiBudW1iZXIgKGlmIHRoZSBzZXR0aW5nICdudW1iZXInIGlzIHVzZWQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoZSByZXR1cm5lZCB2YWx1ZXMgYXJlIGFuIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kLlxuICAgICAgICAgKiBDaGVjayB0aGUgXCJvdXRwdXRGb3JtYXRcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExvY2FsaXplZCgpIHtcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgIGlmIChOdW1iZXIodmFsdWUpID09PSAwICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSAna2VlcCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5vdXRwdXRGb3JtYXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGlucHV0IHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgbnVtYmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TnVtYmVyKCkge1xuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdG9Mb2NhbGUodmFsdWUsICdudW1iZXInKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBjdXJyZW50IGZvcm1hdHRlZCB2YWx1ZSBvZiB0aGUgYXV0b051bWVyaWMgZWxlbWVudC5cbiAgICAgICAgICogQHVzYWdlIGFOSW5wdXQuYXV0b051bWVyaWMoJ2dldEZvcm1hdHRlZCcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Rm9ybWF0dGVkKCkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGB0aGlzWzBdYCBleGlzdHMgYXMgd2VsbCBhcyBgLnZhbHVlYCBiZWZvcmUgdHJ5aW5nIHRvIGFjY2VzcyB0aGF0IHByb3BlcnR5XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJzAnKSB8fCAhKCd2YWx1ZScgaW4gdGhpc1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKCdVbmFibGUgdG8gZ2V0IHRoZSBmb3JtYXR0ZWQgc3RyaW5nIGZyb20gdGhlIGVsZW1lbnQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLnZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXG4gICAgICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiBvciBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIGRldGFpbHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldFN0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheShmYWxzZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgb3IgcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dEZvcm1hdFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHt7fXxbXX1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRTdHJpbmdPckFycmF5KHRydWUsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgJ2dldFNldHRpbmdzJyBmdW5jdGlvbiByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgY3VycmVudCBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRTZXR0aW5ncycpO1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJykuZGVjaW1hbENoYXJhY3RlcjsgLy8gUmV0dXJuIHRoZSBkZWNpbWFsQ2hhcmFjdGVyIHNldHRpbmcgYXMgYSBzdHJpbmcgLSBhbnkgdmFsaWQgb3B0aW9uIG5hbWUgY2FuIGJlIHVzZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICAgICAgLy9UT0RPIEFkZCBhbiBvcHRpb24gYXJndW1lbnQgYG9wdGlvbk5hbWVgIHRvIHRoaXMgZnVuY3Rpb24gc28gdGhhdCBpdCByZXR1cm4gb25seSB0aGUgdmFsdWUgb2YgdGhhdCBvcHRpb24sIG5vdCB0aGUgZW50aXJlIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF1dG9OdW1lcmljIGZ1bmN0aW9uIGFjY2VwdHMgbWV0aG9kcyBuYW1lcyAoaW4gc3RyaW5nIGZvcm1hdCkgYW5kIHRob3NlIG1ldGhvZCBwYXJhbWV0ZXJzIGlmIG5lZWRlZC5cbiAgICAgKiBJdCBpbml0aWFsaXplIGF1dG9OdW1lcmljIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgbWV0aG9kIG5hbWUgKGllLiAnc2V0JywgJ2dldCcsIGV0Yy4pXG4gICAgICogQHBhcmFtIHsqfSBhcmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgJC5mbi5hdXRvTnVtZXJpYyA9IGZ1bmN0aW9uKG1ldGhvZCwgLi4uYXJncykge1xuICAgICAgICBpZiAobWV0aG9kc1ttZXRob2RdKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnIHx8ICFtZXRob2QpIHtcbiAgICAgICAgICAgIC8vIFRoZSBvcHRpb25zIGhhdmUgYmVlbiBwYXNzZWQgZGlyZWN0bHksIHdpdGhvdXQgdXNpbmcgYSBuYW1lZCBtZXRob2RcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgW21ldGhvZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dFcnJvcihgTWV0aG9kIFwiJHttZXRob2R9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRlZmF1bHQgYXV0b051bWVyaWMgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldERlZmF1bHRDb25maWcgPSAoKSA9PiBkZWZhdWx0U2V0dGluZ3M7XG5cbiAgICAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzID0gZGVmYXVsdFNldHRpbmdzOyAvLyBNYWtlIHRob3NlIHNldHRpbmdzIHB1YmxpYyB2aWEgalF1ZXJ5IHRvby5cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyBmb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudCB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBhdXRvRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbGlkaXR5IG9mIHRoZSBgdmFsdWVgIHBhcmFtZXRlclxuICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgQSBudW1iZXIgaXMgbmVlZGVkIHRvIGJlIGFibGUgdG8gZm9ybWF0IGl0LCBbJHt2YWx1ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhdGUgYSB2ZXJ5IGJhc2ljIHNldHRpbmdzIG9iamVjdFxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgdmFsdWVTdHJpbmcgPSBmcm9tTG9jYWxlKHZhbHVlU3RyaW5nKTtcblxuICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBzZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFzaWMgdGVzdHMgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlU3RyaW5nIGlzIHZhbGlkXG4gICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHZhbHVlU3RyaW5nLCBzZXR0aW5ncyk7XG4gICAgICAgIGlmICghbWluVGVzdCB8fCAhbWF4VGVzdCkge1xuICAgICAgICAgICAgLy8gVGhyb3cgYSBjdXN0b20gZXZlbnRcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnYXV0b0Zvcm1hdC5hdXRvTnVtZXJpYycsIGRvY3VtZW50LCBgUmFuZ2UgdGVzdCBmYWlsZWRgKTtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHt2YWx1ZVN0cmluZ31dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIG9mIHRoZSBtaW5pbXVtVmFsdWUgWyR7c2V0dGluZ3MubWluaW11bVZhbHVlfV0gYW5kIG1heGltdW1WYWx1ZSBbJHtzZXR0aW5ncy5tYXhpbXVtVmFsdWV9XSByYW5nZSBzZXQgZm9yIHRoaXMgZWxlbWVudGApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXZlcnl0aGluZyBpcyBvaywgcHJvY2VlZCB0byByb3VuZGluZywgZm9ybWF0dGluZyBhbmQgZ3JvdXBpbmdcbiAgICAgICAgdmFsdWVTdHJpbmcgPSByb3VuZFZhbHVlKHZhbHVlU3RyaW5nLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlU3RyaW5nID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlKHZhbHVlU3RyaW5nLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlU3RyaW5nID0gYWRkR3JvdXBTZXBhcmF0b3JzKHZhbHVlU3RyaW5nLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyaW5nO1xuICAgIH07XG5cbiAgICAkLmZuLmF1dG9Gb3JtYXQgPSBhdXRvRm9ybWF0OyAvLyBUaGUgalF1ZXJ5IGV4cG9ydFxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHVuZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBhdXRvVW5Gb3JtYXQgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHaXZpbmcgYW4gdW5mb3JtYXR0ZWQgdmFsdWUgc2hvdWxkIHJldHVybiB0aGUgc2FtZSB1bmZvcm1hdHRlZCB2YWx1ZSwgd2hhdGV2ZXIgdGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gICAgICAgIGlmIChpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkgeyAvL1RPRE8gQ29tcGxldGUgdGhlIHRlc3QgdG8gdGhyb3cgd2hlbiBnaXZlbiBhIHdyb25nbHkgZm9ybWF0dGVkIG51bWJlciAoaWUuICdmb29iYXInKVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbGlkaXR5IG9mIHRoZSBgdmFsdWVgIHBhcmFtZXRlclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgQSBudW1iZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgbnVtYmVyIGlzIG5lZWRlZCB0byBiZSBhYmxlIHRvIHVuZm9ybWF0IGl0LCBbJHt2YWx1ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9YDtcbiAgICAgICAgY29uc3QgYXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgJiYgc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuc3BsaXQoJywnKVswXSA9PT0gdmFsdWUuY2hhckF0KDApKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XG4gICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGF1dG9TdHJpcCwgJycpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5vdXRwdXRGb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvVW5mb3JtYXQgPSBhdXRvVW5Gb3JtYXQ7IC8vIFRoZSBqUXVlcnkgZXhwb3J0XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gb3B0aW9uIG9iamVjdC5cbiAgICAgKiBJZiB0aGUgb3B0aW9ucyBhcmUgdmFsaWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBub3RoaW5nLCBvdGhlcndpc2UgaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQsIHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogVGhpcyB0ZXN0cyBpZiB0aGUgb3B0aW9ucyBhcmUgbm90IGNvbmZsaWN0aW5nIGFuZCBhcmUgd2VsbCBmb3JtYXR0ZWQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsZW5pZW50IHNpbmNlIGl0IG9ubHkgdGVzdHMgdGhlIHNldHRpbmdzIHByb3BlcnRpZXMgOyBpdCBpZ25vcmVzIGFueSBvdGhlciBwcm9wZXJ0aWVzIHRoZSBvcHRpb25zIG9iamVjdCBjb3VsZCBoYXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB1c2VyT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMgSWYgVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgZXh0ZW5kcyB0aGUgYHVzZXJPcHRpb25zYCBwYXNzZWQgYnkgdGhlIHVzZXIsIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICovXG4gICAgdmFsaWRhdGUgPSAodXNlck9wdGlvbnMsIHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHVzZXJPcHRpb25zKSB8fCAhaXNPYmplY3QodXNlck9wdGlvbnMpIHx8IGlzRW1wdHlPYmoodXNlck9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdXNlck9wdGlvbnMgYXJlIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSB2YWxpZCBvYmplY3QsIFske3VzZXJPcHRpb25zfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdXNlciB1c2VkIG9sZCBvcHRpb25zLCB3ZSBjb252ZXJ0IHRoZW0gdG8gbmV3IG9uZXNcbiAgICAgICAgaWYgKCFpc051bGwodXNlck9wdGlvbnMpKSB7XG4gICAgICAgICAgICBjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyh1c2VyT3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdXNlciBjYW4gY2hvb3NlIGlmIHRoZSBgdXNlck9wdGlvbnNgIGhhcyBhbHJlYWR5IGJlZW4gZXh0ZW5kZWQgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLCBvciBub3RcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0IHRoaW5ncyBmaXJzdCwgd2UgdGVzdCB0aGF0IHRoZSBgc2hvd1dhcm5pbmdzYCBvcHRpb24gaXMgdmFsaWRcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2hvd1dhcm5pbmdzKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2hvd1dhcm5pbmdzKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnc2hvd1dhcm5pbmdzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zaG93V2FybmluZ3N9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSB0aGUgcmVndWxhciBleHByZXNzaW9ucyBuZWVkZWQgZm9yIHRoZSBmb2xsb3dpbmcgdGVzdHNcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlSW50ZWdlciA9IC9eWzAtOV0rJC87XG4gICAgICAgIGNvbnN0IHRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzID0gL1swLTldKy87XG4gICAgICAgIC8vIGNvbnN0IHRlc3RGbG9hdEFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKSQvO1xuICAgICAgICBjb25zdCB0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKyk/JC87XG4gICAgICAgIGNvbnN0IHRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyID0gL15bMC05XSsoXFwuP1swLTldKyk/JC87XG5cbiAgICAgICAgLy8gVGhlbiB0ZXN0cyB0aGUgb3B0aW9ucyBpbmRpdmlkdWFsbHlcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLCBbJywnLCAnLicsICcgJywgJycsIFwiJ1wiXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnZGlnaXRHcm91cFNlcGFyYXRvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLCcsICcuJywgJyAnLCBcIidcIiBvciBlbXB0eSAoJycpLCBbJHtvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3J9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1cykgJiYgIWlzQm9vbGVhbihvcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1cykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSAnbm9TZXBhcmF0b3JPbkZvY3VzJyBvcHRpb24gaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMubm9TZXBhcmF0b3JPbkZvY3VzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmcpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlnaXRhbCBncm91cGluZyBmb3IgdGhvdXNhbmQgc2VwYXJhdG9yIG9wdGlvbiAnZGlnaXRhbEdyb3VwU3BhY2luZycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZ31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLCBbJywnLCAnLiddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RlY2ltYWxDaGFyYWN0ZXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJy4nIG9yICcsJywgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kIGNoYXJhY3RlcnMgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgJ2RlY2ltYWxDaGFyYWN0ZXInIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3Rlcn1dIGFuZCB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yICdkaWdpdEdyb3VwU2VwYXJhdG9yJyBbJHtvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3J9XSBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpICYmICFpc1N0cmluZyhvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhbHRlcm5hdGUgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmICFpc1N0cmluZyhvcHRpb25zLmN1cnJlbmN5U3ltYm9sKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGN1cnJlbmN5IHN5bWJvbCBvcHRpb24gJ2N1cnJlbmN5U3ltYm9sJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLmN1cnJlbmN5U3ltYm9sfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LCBbJ3AnLCAncyddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgY3VycmVuY3kgc2lnbiBvcHRpb24gJ2N1cnJlbmN5U3ltYm9sUGxhY2VtZW50JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCkgb3IgJ3MnIChzdWZmaXgpLCBbJHtvcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LCBbJ3AnLCAncycsICdsJywgJ3InXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gb3B0aW9uICduZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ3AnIChwcmVmaXgpLCAncycgKHN1ZmZpeCksICdsJyAobGVmdCkgb3IgJ3InIChyaWdodCksIFske29wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5zdWZmaXhUZXh0KSB8fCAob3B0aW9ucy5zdWZmaXhUZXh0ICE9PSAnJyAmJiAoY29udGFpbnMob3B0aW9ucy5zdWZmaXhUZXh0LCAnLScpIHx8IHRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzLnRlc3Qob3B0aW9ucy5zdWZmaXhUZXh0KSkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWRkaXRpb25hbCBzdWZmaXggb3B0aW9uICdzdWZmaXhUZXh0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIG5vdCBjb250YWlucyB0aGUgbmVnYXRpdmUgc2lnbiAnLScgbm9yIGFueSBudW1lcmljYWwgY2hhcmFjdGVycywgWyR7b3B0aW9ucy5zdWZmaXhUZXh0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzKSAmJiAhaXNJbkFycmF5KG9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMsIFsnY2VpbGluZycsICdmbG9vcicsICdpZ25vcmUnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBvdmVycmlkZSBtaW4gJiBtYXggbGltaXRzIG9wdGlvbiAnb3ZlcnJpZGVNaW5NYXhMaW1pdHMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdjZWlsaW5nJywgJ2Zsb29yJyBvciAnaWdub3JlJywgWyR7b3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLm1heGltdW1WYWx1ZSkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5tYXhpbXVtVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ21heGltdW1WYWx1ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMubWluaW11bVZhbHVlKSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLm1pbmltdW1WYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAnbWluaW11bVZhbHVlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KG9wdGlvbnMubWluaW11bVZhbHVlKSA+IHBhcnNlRmxvYXQob3B0aW9ucy5tYXhpbXVtVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiA7ICdtaW5pbXVtVmFsdWUnIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiAnbWF4aW11bVZhbHVlJyBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB8fFxuICAgICAgICAgICAgKGlzSW50KG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiBvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA+PSAwKSB8fCAvLyBJZiBpbnRlZ2VyIG9wdGlvblxuICAgICAgICAgICAgKGlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiB0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSkgIC8vIElmIHN0cmluZyBvcHRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JpdGUgYSB3YXJuaW5nIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgaWYgdGhlIG51bWJlciBvZiBkZWNpbWFsIGluIG1pbmltdW1WYWx1ZS9tYXhpbXVtVmFsdWUgaXMgb3ZlcnJpZGRlbiBieSBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgKGFuZCBub3QgaWYgZGVjaW1hbFBsYWNlc092ZXJyaWRlIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZGVjaW1hbCB1c2VkIGluIG1pbmltdW1WYWx1ZS9tYXhpbXVtVmFsdWUpXG4gICAgICAgIGNvbnN0IHZNaW5BbmRWTWF4TWF4aW11bURlY2ltYWxQbGFjZXMgPSBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKG9wdGlvbnMubWluaW11bVZhbHVlLCBvcHRpb25zLm1heGltdW1WYWx1ZSk7XG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiB2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzICE9PSBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIHRvIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0gd2lsbCBvdmVycmlkZSB0aGUgZGVjaW1hbHMgZGVjbGFyZWQgaW4gJ21pbmltdW1WYWx1ZScgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9XSBhbmQgJ21heGltdW1WYWx1ZScgWyR7b3B0aW9ucy5tYXhpbXVtVmFsdWV9XS5gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZyAmJiAhaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xuICAgICAgICAgICAgd2FybmluZyhgU2V0dGluZyAnYWxsb3dEZWNpbWFsUGFkZGluZycgdG8gW2ZhbHNlXSB3aWxsIG92ZXJyaWRlIHRoZSBjdXJyZW50ICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIHNldHRpbmcgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XS5gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpICYmICghaXNTdHJpbmcob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSB8fCAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbnVtYmVyIG9mIGV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyBcImRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNcIiBpcyBncmVhdGVyIHRoYW4gdGhlIG5vcm1hbCBkZWNpbWFsIHBsYWNlcyBcImRlY2ltYWxQbGFjZXNPdmVycmlkZVwiXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykgJiYgIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgTnVtYmVyKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSA+IE51bWJlcihvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBUaGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c31dIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gdGhlICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0gdmFsdWUuIEN1cnJlbnRseSwgdGhpcyB3aWxsIGxpbWl0IHRoZSBhYmlsaXR5IG9mIHlvdXIgY2xpZW50IHRvIG1hbnVhbGx5IGNoYW5nZSBzb21lIG9mIHRoZSBkZWNpbWFsIHBsYWNlcy4gRG8geW91IHJlYWxseSB3YW50IHRvIGRvIHRoYXQ/YCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURpdmlzb3IpICYmICF0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlci50ZXN0KG9wdGlvbnMuc2NhbGVEaXZpc29yKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIGRpdmlzb3Igb3B0aW9uICdzY2FsZURpdmlzb3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIsIHByZWZlcmFibHkgYW4gaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURpdmlzb3J9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVEZWNpbWFsUGxhY2VzKSAmJiAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuc2NhbGVEZWNpbWFsUGxhY2VzKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIG51bWJlciBvZiBkZWNpbWFscyBvcHRpb24gJ3NjYWxlRGVjaW1hbFBsYWNlcycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuc2NhbGVEZWNpbWFsUGxhY2VzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlU3ltYm9sKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5zY2FsZVN5bWJvbCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBzeW1ib2wgb3B0aW9uICdzY2FsZVN5bWJvbCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5zY2FsZVN5bWJvbH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkgJiYgIWlzQm9vbGVhbihvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2F2ZSB0byBzZXNzaW9uIHN0b3JhZ2Ugb3B0aW9uICdzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm9uSW52YWxpZFBhc3RlLCBbXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgJ2lnbm9yZScsXG4gICAgICAgICAgICAnY2xhbXAnLFxuICAgICAgICAgICAgJ3RydW5jYXRlJyxcbiAgICAgICAgICAgICdyZXBsYWNlJyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZSBiZWhhdmlvciBvcHRpb24gJ29uSW52YWxpZFBhc3RlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnZXJyb3InLCAnaWdub3JlJywgJ2NsYW1wJywgJ3RydW5jYXRlJyBvciAncmVwbGFjZScgKGNmLiBkb2N1bWVudGF0aW9uKSwgWyR7b3B0aW9ucy5vbkludmFsaWRQYXN0ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5yb3VuZGluZ01ldGhvZCwgW1xuICAgICAgICAgICAgJ1MnLFxuICAgICAgICAgICAgJ0EnLFxuICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgJ0InLFxuICAgICAgICAgICAgJ1UnLFxuICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgJ0MnLFxuICAgICAgICAgICAgJ0YnLFxuICAgICAgICAgICAgJ04wNScsXG4gICAgICAgICAgICAnQ0hGJyxcbiAgICAgICAgICAgICdVMDUnLFxuICAgICAgICAgICAgJ0QwNScsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcm91bmRpbmcgbWV0aG9kIG9wdGlvbiAncm91bmRpbmdNZXRob2QnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdTJywgJ0EnLCAncycsICdhJywgJ0InLCAnVScsICdEJywgJ0MnLCAnRicsICdOMDUnLCAnQ0hGJywgJ1UwNScgb3IgJ0QwNScgKGNmLiBkb2N1bWVudGF0aW9uKSwgWyR7b3B0aW9ucy5yb3VuZGluZ01ldGhvZH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZykgJiYgIWlzQm9vbGVhbihvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY29udHJvbCBkZWNpbWFsIHBhZGRpbmcgb3B0aW9uICdhbGxvd0RlY2ltYWxQYWRkaW5nJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyKSAmJiAhaXNJbkFycmF5KG9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIsIFsnKCwpJywgJ1ssXScsICc8LD4nLCAneyx9J10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYnJhY2tldHMgZm9yIG5lZ2F0aXZlIHZhbHVlcyBvcHRpb24gJ25lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnKCwpJywgJ1ssXScsICc8LD4nIG9yICd7LH0nLCBbJHtvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvciwgWydmb2N1cycsICdwcmVzcycsICdhbHdheXMnLCAnemVybyddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRpc3BsYXkgb24gZW1wdHkgc3RyaW5nIG9wdGlvbiAnZW1wdHlJbnB1dEJlaGF2aW9yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnZm9jdXMnLCAncHJlc3MnLCAnYWx3YXlzJyBvciAnemVybycsIFske29wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmxlYWRpbmdaZXJvLCBbJ2FsbG93JywgJ2RlbnknLCAna2VlcCddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGxlYWRpbmcgemVybyBiZWhhdmlvciBvcHRpb24gJ2xlYWRpbmdaZXJvJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnYWxsb3cnLCAnZGVueScgb3IgJ2tlZXAnLCBbJHtvcHRpb25zLmxlYWRpbmdaZXJvfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5mb3JtYXRPblBhZ2VMb2FkKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBmb3JtYXQgb24gaW5pdGlhbGl6YXRpb24gb3B0aW9uICdmb3JtYXRPblBhZ2VMb2FkJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5mb3JtYXRPblBhZ2VMb2FkfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zZWxlY3ROdW1iZXJPbmx5KSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2VsZWN0TnVtYmVyT25seSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzZWxlY3QgbnVtYmVyIG9ubHkgb3B0aW9uICdzZWxlY3ROdW1iZXJPbmx5JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zZWxlY3ROdW1iZXJPbmx5fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlZmF1bHRWYWx1ZU92ZXJyaWRlKSAmJiAob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSAhPT0gJycgJiYgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZSBvcHRpb24gJ2RlZmF1bHRWYWx1ZU92ZXJyaWRlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMudW5mb3JtYXRPblN1Ym1pdCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLnVuZm9ybWF0T25TdWJtaXQpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcmVtb3ZlIGZvcm1hdHRpbmcgb24gc3VibWl0IG9wdGlvbiAndW5mb3JtYXRPblN1Ym1pdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMudW5mb3JtYXRPblN1Ym1pdH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5vdXRwdXRGb3JtYXQpICYmICFpc0luQXJyYXkob3B0aW9ucy5vdXRwdXRGb3JtYXQsIFtcbiAgICAgICAgICAgICdzdHJpbmcnLFxuICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAnLicsXG4gICAgICAgICAgICAnLS4nLFxuICAgICAgICAgICAgJywnLFxuICAgICAgICAgICAgJy0sJyxcbiAgICAgICAgICAgICcuLScsXG4gICAgICAgICAgICAnLC0nLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGN1c3RvbSBsb2NhbGUgZm9ybWF0IG9wdGlvbiAnb3V0cHV0Rm9ybWF0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSBudWxsLCAnc3RyaW5nJywgJ251bWJlcicsICcuJywgJy0uJywgJywnLCAnLSwnLCAnLi0nIG9yICcsLScsIFske29wdGlvbnMub3V0cHV0Rm9ybWF0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9uKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWJ1ZyBvcHRpb24gJ2ZhaWxPblVua25vd25PcHRpb24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmZhaWxPblVua25vd25PcHRpb259XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLmF1dG9WYWxpZGF0ZSA9IHZhbGlkYXRlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHNldHRpbmdzL29wdGlvbnMgYXJlIHZhbGlkLCBGQUxTRSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGFyZVNldHRpbmdzVmFsaWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgc2VudCBpdCBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIG5vIGVsZW1lbnQgaXMgZ2l2ZW4sIHRoZSBldmVudCBpcyB0aHJvd24gZnJvbSBgZG9jdW1lbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkZXRhaWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBlbGVtZW50ID0gZG9jdW1lbnQsIGRldGFpbCA9IG51bGwpIHtcbiAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsLCBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfSk7IC8vIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBkZWZhdWx0IGJ5IElFIDsgV2UgdXNlIHRoZSBwb2x5ZmlsbCBmb3IgSUU5IGFuZCBsYXRlci5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlLCB7IGRldGFpbCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnQgZm9yIG9ic29sZXRlIGJyb3dzZXJzIChJRSlcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdm9pZCgwKSB9O1xuICAgICAgICAgICAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfVxuXG4gICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuICAgIH0pKCk7XG59KSk7XG5cbi8qKlxuICogVGhpcyBleHBvcnRzIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBhdXRvTnVtZXJpYyBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGZvcm1hdCAgOiBhdXRvRm9ybWF0LFxuICAgIHVuRm9ybWF0OiBhdXRvVW5Gb3JtYXQsXG4gICAgZ2V0RGVmYXVsdENvbmZpZyxcbiAgICB2YWxpZGF0ZSwgLy8gYW4udmFsaWRhdGUob3B0aW9ucykgOiB0aHJvd3MgaWYgbmVjZXNzYXJ5XG4gICAgYXJlU2V0dGluZ3NWYWxpZCwgLy9hbi5hcmVTZXR0aW5nc1ZhbGlkKG9wdGlvbnMpIDogcmV0dXJuIHRydWUgb3IgZmFsc2UgLy9UT0RPIElzIHRoaXMgcmVkdW5kYW50PyBTaG91bGQgd2UgbGV0IHRoZSBkZXZlbG9wZXJzIHdyYXAgZWFjaCBhdXRvTnVtZXJpYy52YWxpZGF0ZSgpIGNhbGxzIGluIHRyeS9jYXRjaCBibG9jaz8gT3Igc2hvdWxkIHdlIGp1c3QgZmFjaWxpdGF0ZSB0aGVpciBsaWZlIGJ5IGRvaW5nIGl0IGFscmVhZHk/XG5cbiAgICAvL1RPRE8gQ29tcGxldGUgdGhlIGludGVyZmFjZSB3aXRoIGZ1bmN0aW9ucyBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaWduYXR1cmVzIDpcbiAgICAvL2luaXQgICAgICAgICA6IGFuLmluaXQob3B0aW9ucywgaW5wdXQpXG4gICAgLy9nZXQgICAgICAgICAgOiBhbi5nZXQoaW5wdXQpXG4gICAgLy9zZXQgICAgICAgICAgOiBhbi5zZXQodmFsdWUsIGlucHV0KVxuICAgIC8vZm9ybVN0cmluZyAgIDogYW4uZm9ybVN0cmluZyhmb3JtKVxuICAgIC8vZm9ybUFycmF5ICAgIDogYW4uZm9ybUFycmF5KGZvcm0pXG4gICAgLy9nZXRGb3JtYXR0ZWQgOiBhbi5nZXRGb3JtYXR0ZWQoaW5wdXQpXG4gICAgLy91bnNldCAgICAgICAgOiBhbi51bnNldChpbnB1dCkgLy90byByZW5hbWUgdG8gJ3VuZm9ybWF0Jz8gKGFuZCBtZXJnZSB3aXRoIGF1dG9VbkZvcm1hdC91bkZvcm1hdD8pXG4gICAgLy9yZWZvcm1hdCAgICAgOiBhbi5yZWZvcm1hdChpbnB1dCkgLy8gJ3JlU2V0JyBpcyB2ZXJ5IHRvIGNsb3NlIHRvICdyZXNldCcgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgcmVuYW1lZC4gV2UgY291bGQgc3RpbGwgZXhwb3NlICdyZVNldCcsIGJ1dCBhZGQgYSBAZGVwcmVjYXRlZCB0YWcgb24gaXRzIGRlY2xhcmF0aW9uLlxuICAgIC8vc2V0dGluZ3MgICAgIDogYW4uc2V0dGluZ3MoaW5wdXQpXG4gICAgLy91cGRhdGUgICAgICAgOiBhbi51cGRhdGUob3B0aW9ucywgaW5wdXQpXG4gICAgLy93aXBlICAgICAgICAgOiBhbi53aXBlKGlucHV0KVxuICAgIC8vZGVzdHJveSAgICAgIDogYW4uZGVzdHJveShpbnB1dClcblxuICAgIC8vcmF3ICAgICAgICAgIDogYW4ucmF3KGlucHV0KSAvLyBSZXR1cm4gdGhlIHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgc3RyaW5nXG4gICAgLy9udW1iZXIgICAgICAgOiBhbi5udW1iZXIoaW5wdXQpIC8vIFJldHVybiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSBudW1iZXIgKFdhcm5pbmc6IFRoaXMgY2FuIGxlYWQgdG8gcHJlY2lzaW9uIHByb2JsZW1zIHdpdGggYmlnIG51bWJlcnMpXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;
