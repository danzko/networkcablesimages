"use strict";function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function typeIsObject(x){return"object"===("undefined"==typeof x?"undefined":_typeof(x))&&null!==x||"function"==typeof x}function createDataProperty(o,p,v){assert$1(typeIsObject(o)),Object.defineProperty(o,p,{value:v,writable:!0,enumerable:!0,configurable:!0})}function createArrayFromList(elements){return elements.slice()}function ArrayBufferCopy(dest,destOffset,src,srcOffset,n){new Uint8Array(dest).set(new Uint8Array(src,srcOffset,n),destOffset)}function CreateIterResultObject(value,done){assert$1("boolean"==typeof done);var obj={};return Object.defineProperty(obj,"value",{value:value,enumerable:!0,writable:!0,configurable:!0}),Object.defineProperty(obj,"done",{value:done,enumerable:!0,writable:!0,configurable:!0}),obj}function IsFiniteNonNegativeNumber(v){return Number.isNaN(v)?!1:v===+(1/0)?!1:!(0>v)}function InvokeOrNoop(O,P,args){var method=O[P];if(void 0!==method)return method.apply(O,args)}function PromiseInvokeOrNoop(O,P,args){var method=void 0;try{method=O[P]}catch(methodE){return Promise.reject(methodE)}if(void 0===method)return Promise.resolve(void 0);try{return Promise.resolve(method.apply(O,args))}catch(e){return Promise.reject(e)}}function PromiseInvokeOrFallbackOrNoop(O,P1,args1,P2,args2){var method=void 0;try{method=O[P1]}catch(methodE){return Promise.reject(methodE)}if(void 0===method)return PromiseInvokeOrNoop(O,P2,args2);try{return Promise.resolve(method.apply(O,args1))}catch(e){return Promise.reject(e)}}function TransferArrayBuffer(buffer){return buffer}function ValidateAndNormalizeHighWaterMark(highWaterMark){if(highWaterMark=Number(highWaterMark),Number.isNaN(highWaterMark))throw new TypeError("highWaterMark property of a queuing strategy must be convertible to a non-NaN number");if(0>highWaterMark)throw new RangeError("highWaterMark property of a queuing strategy must be nonnegative");return highWaterMark}function ValidateAndNormalizeQueuingStrategy(size,highWaterMark){if(void 0!==size&&"function"!=typeof size)throw new TypeError("size property of a queuing strategy must be a function");return highWaterMark=ValidateAndNormalizeHighWaterMark(highWaterMark),{size:size,highWaterMark:highWaterMark}}function rethrowAssertionErrorRejection(e){e&&e.constructor===assert$2.AssertionError&&setTimeout(function(){throw e},0)}function DequeueValue(queue){assert$3(queue.length>0,"Spec-level failure: should never dequeue from an empty queue.");var pair=queue.shift();return pair.value}function EnqueueValueWithSize(queue,value,size){if(size=Number(size),!IsFiniteNonNegativeNumber(size))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");queue.push({value:value,size:size})}function GetTotalQueueSize(queue){var totalSize=0;return queue.forEach(function(pair){assert$3("number"==typeof pair.size&&!Number.isNaN(pair.size)&&pair.size!==+(1/0)&&pair.size!==-(1/0),"Spec-level failure: should never find an invalid size in the queue."),totalSize+=pair.size}),totalSize}function PeekQueueValue(queue){assert$3(queue.length>0,"Spec-level failure: should never peek at an empty queue.");var pair=queue[0];return pair.value}function AcquireReadableStreamBYOBReader(stream){return new ReadableStreamBYOBReader(stream)}function AcquireReadableStreamDefaultReader(stream){return new ReadableStreamDefaultReader(stream)}function IsReadableStream(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_readableStreamController"):!1}function IsReadableStreamLocked(stream){return assert(IsReadableStream(stream)===!0,"IsReadableStreamLocked should only be used on known readable streams"),void 0!==stream._reader}function ReadableStreamTee(stream,shouldClone){assert(IsReadableStream(stream)===!0),assert("boolean"==typeof shouldClone);var reader=AcquireReadableStreamDefaultReader(stream),teeState={closedOrErrored:!1,canceled1:!1,canceled2:!1,reason1:void 0,reason2:void 0};teeState.promise=new Promise(function(resolve){return teeState._resolve=resolve});var pull=create_ReadableStreamTeePullFunction();pull._reader=reader,pull._teeState=teeState,pull._shouldClone=shouldClone;var cancel1=create_ReadableStreamTeeBranch1CancelFunction();cancel1._stream=stream,cancel1._teeState=teeState;var cancel2=create_ReadableStreamTeeBranch2CancelFunction();cancel2._stream=stream,cancel2._teeState=teeState;var underlyingSource1=Object.create(Object.prototype);createDataProperty(underlyingSource1,"pull",pull),createDataProperty(underlyingSource1,"cancel",cancel1);var branch1Stream=new ReadableStream(underlyingSource1),underlyingSource2=Object.create(Object.prototype);createDataProperty(underlyingSource2,"pull",pull),createDataProperty(underlyingSource2,"cancel",cancel2);var branch2Stream=new ReadableStream(underlyingSource2);return pull._branch1=branch1Stream._readableStreamController,pull._branch2=branch2Stream._readableStreamController,reader._closedPromise["catch"](function(r){teeState.closedOrErrored!==!0&&(ReadableStreamDefaultControllerError(pull._branch1,r),ReadableStreamDefaultControllerError(pull._branch2,r),teeState.closedOrErrored=!0)}),[branch1Stream,branch2Stream]}function create_ReadableStreamTeePullFunction(){var f=function f(){var reader=f._reader,branch1=f._branch1,branch2=f._branch2,teeState=f._teeState;f._shouldClone;return ReadableStreamDefaultReaderRead(reader).then(function(result){assert(typeIsObject(result));var value=result.value,done=result.done;if(assert("boolean"==typeof done),done===!0&&teeState.closedOrErrored===!1&&(teeState.canceled1===!1&&ReadableStreamDefaultControllerClose(branch1),teeState.canceled2===!1&&ReadableStreamDefaultControllerClose(branch2),teeState.closedOrErrored=!0),teeState.closedOrErrored!==!0){if(teeState.canceled1===!1){var value1=value;ReadableStreamDefaultControllerEnqueue(branch1,value1)}if(teeState.canceled2===!1){var value2=value;ReadableStreamDefaultControllerEnqueue(branch2,value2)}}})};return f}function create_ReadableStreamTeeBranch1CancelFunction(){var f=function f(reason){var stream=f._stream,teeState=f._teeState;if(teeState.canceled1=!0,teeState.reason1=reason,teeState.canceled2===!0){var compositeReason=createArrayFromList([teeState.reason1,teeState.reason2]),cancelResult=ReadableStreamCancel(stream,compositeReason);teeState._resolve(cancelResult)}return teeState.promise};return f}function create_ReadableStreamTeeBranch2CancelFunction(){var f=function f(reason){var stream=f._stream,teeState=f._teeState;if(teeState.canceled2=!0,teeState.reason2=reason,teeState.canceled1===!0){var compositeReason=createArrayFromList([teeState.reason1,teeState.reason2]),cancelResult=ReadableStreamCancel(stream,compositeReason);teeState._resolve(cancelResult)}return teeState.promise};return f}function ReadableStreamAddReadIntoRequest(stream){assert(IsReadableStreamBYOBReader(stream._reader)===!0);var promise=new Promise(function(resolve,reject){var readIntoRequest={_resolve:resolve,_reject:reject};stream._reader._readIntoRequests.push(readIntoRequest)});return promise}function ReadableStreamAddReadRequest(stream){assert(IsReadableStreamDefaultReader(stream._reader)===!0);var promise=new Promise(function(resolve,reject){var readRequest={_resolve:resolve,_reject:reject};stream._reader._readRequests.push(readRequest)});return promise}function ReadableStreamCancel(stream,reason){if(assert(void 0!==stream),stream._disturbed=!0,"closed"===stream._state)return Promise.resolve(void 0);if("errored"===stream._state)return Promise.reject(stream._storedError);ReadableStreamClose(stream);var sourceCancelPromise=stream._readableStreamController[InternalCancel](reason);return sourceCancelPromise.then(function(){})}function ReadableStreamClose(stream){assert("readable"===stream._state),stream._state="closed";var reader=stream._reader;if(void 0!==reader){if(IsReadableStreamDefaultReader(reader)===!0){var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _step,_iterator=reader._readRequests[Symbol.iterator]();!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var _resolve=_step.value._resolve;_resolve(CreateIterResultObject(void 0,!0))}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator["return"]&&_iterator["return"]()}finally{if(_didIteratorError)throw _iteratorError}}reader._readRequests=[]}reader._closedPromise_resolve(void 0),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0}}function ReadableStreamError(stream,e){assert(IsReadableStream(stream)===!0,"stream must be ReadableStream"),assert("readable"===stream._state,"state must be readable"),stream._state="errored",stream._storedError=e;var reader=stream._reader;if(void 0!==reader){if(IsReadableStreamDefaultReader(reader)===!0){var _iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _step2,_iterator2=reader._readRequests[Symbol.iterator]();!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0){var readRequest=_step2.value;readRequest._reject(e)}}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{!_iteratorNormalCompletion2&&_iterator2["return"]&&_iterator2["return"]()}finally{if(_didIteratorError2)throw _iteratorError2}}reader._readRequests=[]}else{assert(IsReadableStreamBYOBReader(reader),"reader must be ReadableStreamBYOBReader");var _iteratorNormalCompletion3=!0,_didIteratorError3=!1,_iteratorError3=void 0;try{for(var _step3,_iterator3=reader._readIntoRequests[Symbol.iterator]();!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=!0){var readIntoRequest=_step3.value;readIntoRequest._reject(e)}}catch(err){_didIteratorError3=!0,_iteratorError3=err}finally{try{!_iteratorNormalCompletion3&&_iterator3["return"]&&_iterator3["return"]()}finally{if(_didIteratorError3)throw _iteratorError3}}reader._readIntoRequests=[]}reader._closedPromise_reject(e),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0}}function ReadableStreamFulfillReadIntoRequest(stream,chunk,done){var reader=stream._reader;assert(reader._readIntoRequests.length>0);var readIntoRequest=reader._readIntoRequests.shift();readIntoRequest._resolve(CreateIterResultObject(chunk,done))}function ReadableStreamFulfillReadRequest(stream,chunk,done){var reader=stream._reader;assert(reader._readRequests.length>0);var readRequest=reader._readRequests.shift();readRequest._resolve(CreateIterResultObject(chunk,done))}function ReadableStreamGetNumReadIntoRequests(stream){return stream._reader._readIntoRequests.length}function ReadableStreamGetNumReadRequests(stream){return stream._reader._readRequests.length}function ReadableStreamHasBYOBReader(stream){var reader=stream._reader;return void 0===reader?!1:IsReadableStreamBYOBReader(reader)!==!1}function ReadableStreamHasReader(stream){var reader=stream._reader;return void 0===reader?!1:IsReadableStreamDefaultReader(reader)!==!1}function IsReadableStreamBYOBReader(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_readIntoRequests"):!1}function IsReadableStreamDefaultReader(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_readRequests"):!1}function ReadableStreamReaderGenericInitialize(reader,stream){reader._ownerReadableStream=stream,stream._reader=reader,"readable"===stream._state?reader._closedPromise=new Promise(function(resolve,reject){reader._closedPromise_resolve=resolve,reader._closedPromise_reject=reject}):"closed"===stream._state?(reader._closedPromise=Promise.resolve(void 0),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0):(assert("errored"===stream._state,"state must be errored"),reader._closedPromise=Promise.reject(stream._storedError),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0)}function ReadableStreamReaderGenericCancel(reader,reason){return ReadableStreamCancel(reader._ownerReadableStream,reason)}function ReadableStreamReaderGenericRelease(reader){assert(void 0!==reader._ownerReadableStream._reader),assert(void 0!==reader._ownerReadableStream),"readable"===reader._ownerReadableStream._state?reader._closedPromise_reject(new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):reader._closedPromise=Promise.reject(new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),reader._ownerReadableStream._reader=void 0,reader._ownerReadableStream=void 0}function ReadableStreamBYOBReaderRead(reader,view){var stream=reader._ownerReadableStream;return assert(void 0!==stream),stream._disturbed=!0,"errored"===stream._state?Promise.reject(stream._storedError):ReadableStreamBYOBControllerPullInto(stream._readableStreamController,view)}function ReadableStreamDefaultReaderRead(reader){var stream=reader._ownerReadableStream;return assert(void 0!==stream),stream._disturbed=!0,"closed"===stream._state?Promise.resolve(CreateIterResultObject(void 0,!0)):"errored"===stream._state?Promise.reject(stream._storedError):(assert("readable"===stream._state),stream._readableStreamController[InternalPull]())}function IsReadableStreamDefaultController(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_underlyingSource"):!1}function ReadableStreamDefaultControllerCallPullIfNeeded(controller){var shouldPull=ReadableStreamDefaultControllerShouldPull(controller);if(shouldPull!==!1){if(controller._pulling===!0)return void(controller._pullAgain=!0);controller._pulling=!0;var stream=controller._controlledReadableStream,pullPromise=PromiseInvokeOrNoop(controller._underlyingSource,"pull",[controller]);pullPromise.then(function(){return controller._pulling=!1,controller._pullAgain===!0?(controller._pullAgain=!1,ReadableStreamDefaultControllerCallPullIfNeeded(controller)):void 0},function(e){return"readable"===stream._state?ReadableStreamDefaultControllerError(controller,e):void 0})["catch"](rethrowAssertionErrorRejection)}}function ReadableStreamDefaultControllerShouldPull(controller){var stream=controller._controlledReadableStream;if("closed"===stream._state||"errored"===stream._state)return!1;if(controller._closeRequested===!0)return!1;if(controller._started===!1)return!1;if(IsReadableStreamLocked(stream)===!0&&ReadableStreamGetNumReadRequests(stream)>0)return!0;var desiredSize=ReadableStreamDefaultControllerGetDesiredSize(controller);return desiredSize>0}function ReadableStreamDefaultControllerClose(controller){var stream=controller._controlledReadableStream;assert(controller._closeRequested===!1),assert("readable"===stream._state),controller._closeRequested=!0,0===controller._queue.length&&ReadableStreamClose(stream)}function ReadableStreamDefaultControllerEnqueue(controller,chunk){var stream=controller._controlledReadableStream;if(assert(controller._closeRequested===!1),assert("readable"===stream._state),IsReadableStreamLocked(stream)===!0&&ReadableStreamGetNumReadRequests(stream)>0)ReadableStreamFulfillReadRequest(stream,chunk,!1);else{var chunkSize=1;if(void 0!==controller._strategySize)try{chunkSize=controller._strategySize(chunk)}catch(chunkSizeE){throw"readable"===stream._state&&ReadableStreamDefaultControllerError(controller,chunkSizeE),chunkSizeE}try{EnqueueValueWithSize(controller._queue,chunk,chunkSize)}catch(enqueueE){throw"readable"===stream._state&&ReadableStreamDefaultControllerError(controller,enqueueE),enqueueE}}ReadableStreamDefaultControllerCallPullIfNeeded(controller)}function ReadableStreamDefaultControllerError(controller,e){var stream=controller._controlledReadableStream;assert("readable"===stream._state),controller._queue=[],ReadableStreamError(stream,e)}function ReadableStreamDefaultControllerGetDesiredSize(controller){var queueSize=GetTotalQueueSize(controller._queue);return controller._strategyHWM-queueSize}function IsReadableStreamBYOBController(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_underlyingByteSource"):!1}function IsReadableStreamBYOBRequest(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_associatedReadableStreamBYOBController"):!1}function ReadableStreamBYOBControllerCallPullIfNeeded(controller){var shouldPull=ReadableStreamBYOBControllerShouldCallPull(controller);if(shouldPull!==!1){if(controller._pulling===!0)return void(controller._pullAgain=!0);controller._pullAgain=!1,controller._pulling=!0;var pullPromise=PromiseInvokeOrNoop(controller._underlyingByteSource,"pull",[controller]);pullPromise.then(function(){controller._pulling=!1,controller._pullAgain===!0&&(controller._pullAgain=!1,ReadableStreamBYOBControllerCallPullIfNeeded(controller))},function(e){"readable"===controller._controlledReadableStream._state&&ReadableStreamBYOBControllerError(controller,e)})["catch"](rethrowAssertionErrorRejection)}}function ReadableStreamBYOBControllerClearPendingPullIntos(controller){void 0!==controller._byobRequest&&(controller._byobRequest._invalidate(),controller._byobRequest=void 0),controller._pendingPullIntos=[]}function ReadableStreamBYOBControllerCommitPullIntoDescriptor(stream,pullIntoDescriptor){assert("errored"!==stream._state,"state must not be errored");var done=!1;"closed"===stream._state&&(assert(0===pullIntoDescriptor.bytesFilled),done=!0);var filledView=ReadableStreamBYOBControllerConvertPullIntoDescriptor(pullIntoDescriptor);"default"===pullIntoDescriptor.readerType?ReadableStreamFulfillReadRequest(stream,filledView,done):(assert("byob"===pullIntoDescriptor.readerType),ReadableStreamFulfillReadIntoRequest(stream,filledView,done))}function ReadableStreamBYOBControllerConvertPullIntoDescriptor(pullIntoDescriptor){var bytesFilled=pullIntoDescriptor.bytesFilled,elementSize=pullIntoDescriptor.elementSize;return assert(bytesFilled<=pullIntoDescriptor.byteLength),assert(bytesFilled%elementSize===0),new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer,pullIntoDescriptor.byteOffset,bytesFilled/elementSize)}function ReadableStreamBYOBControllerEnqueueChunkToQueue(controller,buffer,byteOffset,byteLength){controller._queue.push({buffer:buffer,byteOffset:byteOffset,byteLength:byteLength}),controller._totalQueuedBytes+=byteLength}function ReadableStreamBYOBControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor){var elementSize=pullIntoDescriptor.elementSize,currentAlignedBytes=pullIntoDescriptor.bytesFilled-pullIntoDescriptor.bytesFilled%elementSize,maxBytesToCopy=Math.min(controller._totalQueuedBytes,pullIntoDescriptor.byteLength-pullIntoDescriptor.bytesFilled),maxBytesFilled=pullIntoDescriptor.bytesFilled+maxBytesToCopy,maxAlignedBytes=maxBytesFilled-maxBytesFilled%elementSize,totalBytesToCopyRemaining=maxBytesToCopy,ready=!1;maxAlignedBytes>currentAlignedBytes&&(totalBytesToCopyRemaining=maxAlignedBytes-pullIntoDescriptor.bytesFilled,ready=!0);for(var queue=controller._queue;totalBytesToCopyRemaining>0;){var headOfQueue=queue[0],bytesToCopy=Math.min(totalBytesToCopyRemaining,headOfQueue.byteLength),destStart=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled;ArrayBufferCopy(pullIntoDescriptor.buffer,destStart,headOfQueue.buffer,headOfQueue.byteOffset,bytesToCopy),headOfQueue.byteLength===bytesToCopy?queue.shift():(headOfQueue.byteOffset+=bytesToCopy,headOfQueue.byteLength-=bytesToCopy),controller._totalQueuedBytes-=bytesToCopy,ReadableStreamBYOBControllerFillHeadPullIntoDescriptor(controller,bytesToCopy,pullIntoDescriptor),totalBytesToCopyRemaining-=bytesToCopy}return ready===!1&&(assert(0===controller._totalQueuedBytes,"queue must be empty"),assert(pullIntoDescriptor.bytesFilled>0),assert(pullIntoDescriptor.bytesFilled<pullIntoDescriptor.elementSize)),ready}function ReadableStreamBYOBControllerFillHeadPullIntoDescriptor(controller,size,pullIntoDescriptor){assert(0===controller._pendingPullIntos.length||controller._pendingPullIntos[0]===pullIntoDescriptor),void 0!==controller._byobRequest&&(controller._byobRequest._invalidate(),controller._byobRequest=void 0),pullIntoDescriptor.bytesFilled+=size}function ReadableStreamBYOBControllerHandleQueueDrain(controller){assert("readable"===controller._controlledReadableStream._state),0===controller._totalQueuedBytes&&controller._closeRequested===!0?ReadableStreamClose(controller._controlledReadableStream):ReadableStreamBYOBControllerCallPullIfNeeded(controller)}function ReadableStreamBYOBControllerProcessPullIntoDescriptorsUsingQueue(controller){for(assert(controller._closeRequested===!1);controller._pendingPullIntos.length>0;){if(0===controller._totalQueuedBytes)return;var pullIntoDescriptor=controller._pendingPullIntos[0];ReadableStreamBYOBControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor)===!0&&(ReadableStreamBYOBControllerShiftPendingPullInto(controller),ReadableStreamBYOBControllerCommitPullIntoDescriptor(controller._controlledReadableStream,pullIntoDescriptor))}}function ReadableStreamBYOBControllerPullInto(controller,view){var stream=controller._controlledReadableStream,elementSize=1;view.constructor!==DataView&&(elementSize=view.constructor.BYTES_PER_ELEMENT);var ctor=view.constructor,pullIntoDescriptor={buffer:view.buffer,byteOffset:view.byteOffset,byteLength:view.byteLength,bytesFilled:0,elementSize:elementSize,ctor:ctor,readerType:"byob"};if(controller._pendingPullIntos.length>0)return pullIntoDescriptor.buffer=TransferArrayBuffer(pullIntoDescriptor.buffer),controller._pendingPullIntos.push(pullIntoDescriptor),ReadableStreamAddReadIntoRequest(stream);if("closed"===stream._state){var emptyView=new view.constructor(view.buffer,view.byteOffset,0);return Promise.resolve(CreateIterResultObject(emptyView,!0))}if(controller._totalQueuedBytes>0){if(ReadableStreamBYOBControllerFillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor)===!0){var filledView=ReadableStreamBYOBControllerConvertPullIntoDescriptor(pullIntoDescriptor);return ReadableStreamBYOBControllerHandleQueueDrain(controller),Promise.resolve(CreateIterResultObject(filledView,!1))}if(controller._closeRequested===!0){var e=new TypeError("Insufficient bytes to fill elements in the given buffer");return ReadableStreamBYOBControllerError(controller,e),Promise.reject(e)}}pullIntoDescriptor.buffer=TransferArrayBuffer(pullIntoDescriptor.buffer),controller._pendingPullIntos.push(pullIntoDescriptor);var promise=ReadableStreamAddReadIntoRequest(stream);return ReadableStreamBYOBControllerCallPullIfNeeded(controller),promise}function ReadableStreamBYOBControllerRespondInClosedState(controller,firstDescriptor){firstDescriptor.buffer=TransferArrayBuffer(firstDescriptor.buffer),assert(0===firstDescriptor.bytesFilled,"bytesFilled must be 0");for(var stream=controller._controlledReadableStream;ReadableStreamGetNumReadIntoRequests(stream)>0;){var pullIntoDescriptor=ReadableStreamBYOBControllerShiftPendingPullInto(controller);ReadableStreamBYOBControllerCommitPullIntoDescriptor(stream,pullIntoDescriptor)}}function ReadableStreamBYOBControllerRespondInReadableState(controller,bytesWritten,pullIntoDescriptor){if(pullIntoDescriptor.bytesFilled+bytesWritten>pullIntoDescriptor.byteLength)throw new RangeError("bytesWritten out of range");if(ReadableStreamBYOBControllerFillHeadPullIntoDescriptor(controller,bytesWritten,pullIntoDescriptor),!(pullIntoDescriptor.bytesFilled<pullIntoDescriptor.elementSize)){ReadableStreamBYOBControllerShiftPendingPullInto(controller);var remainderSize=pullIntoDescriptor.bytesFilled%pullIntoDescriptor.elementSize;if(remainderSize>0){var end=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled,remainder=pullIntoDescriptor.buffer.slice(end-remainderSize,end);ReadableStreamBYOBControllerEnqueueChunkToQueue(controller,remainder,0,remainder.byteLength)}pullIntoDescriptor.buffer=TransferArrayBuffer(pullIntoDescriptor.buffer),pullIntoDescriptor.bytesFilled-=remainderSize,ReadableStreamBYOBControllerCommitPullIntoDescriptor(controller._controlledReadableStream,pullIntoDescriptor),ReadableStreamBYOBControllerProcessPullIntoDescriptorsUsingQueue(controller)}}function ReadableStreamBYOBControllerRespondInternal(controller,bytesWritten){var firstDescriptor=controller._pendingPullIntos[0],stream=controller._controlledReadableStream;if("closed"===stream._state){if(0!==bytesWritten)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");ReadableStreamBYOBControllerRespondInClosedState(controller,firstDescriptor)}else assert("readable"===stream._state),ReadableStreamBYOBControllerRespondInReadableState(controller,bytesWritten,firstDescriptor)}function ReadableStreamBYOBControllerShiftPendingPullInto(controller){var descriptor=controller._pendingPullIntos.shift();return void 0!==controller._byobRequest&&(controller._byobRequest._invalidate(),controller._byobRequest=void 0),descriptor}function ReadableStreamBYOBControllerShouldCallPull(controller){var stream=controller._controlledReadableStream;if("readable"!==stream._state)return!1;if(controller._closeRequested===!0)return!1;if(controller._started===!1)return!1;if(ReadableStreamHasReader(stream)&&ReadableStreamGetNumReadRequests(stream)>0)return!0;if(ReadableStreamHasBYOBReader(stream)&&ReadableStreamGetNumReadIntoRequests(stream)>0)return!0;var desiredSize=ReadableStreamBYOBControllerGetDesiredSize(controller);return desiredSize>0}function ReadableStreamBYOBControllerClose(controller){var stream=controller._controlledReadableStream;if(assert(controller._closeRequested===!1),assert("readable"===stream._state),controller._totalQueuedBytes>0)return void(controller._closeRequested=!0);var firstPendingPullInto=controller._pendingPullIntos[0];if(ReadableStreamHasBYOBReader(stream)===!0&&controller._pendingPullIntos.length>0&&firstPendingPullInto.bytesFilled>0){var e=new TypeError("Insufficient bytes to fill elements in the given buffer");throw ReadableStreamBYOBControllerError(controller,e),e}ReadableStreamClose(stream)}function ReadableStreamBYOBControllerEnqueue(controller,chunk){var stream=controller._controlledReadableStream;assert(controller._closeRequested===!1),assert("readable"===stream._state);var buffer=chunk.buffer,byteOffset=chunk.byteOffset,byteLength=chunk.byteLength;if(ReadableStreamHasReader(stream)===!0)if(0===ReadableStreamGetNumReadRequests(stream)){var transferredBuffer=TransferArrayBuffer(buffer);ReadableStreamBYOBControllerEnqueueChunkToQueue(controller,transferredBuffer,byteOffset,byteLength)}else{assert(0===controller._queue.length);var transferredBuffer=TransferArrayBuffer(buffer),transferredView=new Uint8Array(transferredBuffer,byteOffset,byteLength);ReadableStreamFulfillReadRequest(stream,transferredView,!1)}else if(ReadableStreamHasBYOBReader(stream)===!0){var transferredBuffer=TransferArrayBuffer(buffer);ReadableStreamBYOBControllerEnqueueChunkToQueue(controller,transferredBuffer,byteOffset,byteLength),ReadableStreamBYOBControllerProcessPullIntoDescriptorsUsingQueue(controller)}else{assert(IsReadableStreamLocked(stream)===!1,"stream must not be locked");var transferredBuffer=TransferArrayBuffer(buffer);ReadableStreamBYOBControllerEnqueueChunkToQueue(controller,transferredBuffer,byteOffset,byteLength)}}function ReadableStreamBYOBControllerError(controller,e){var stream=controller._controlledReadableStream;assert("readable"===stream._state),ReadableStreamBYOBControllerClearPendingPullIntos(controller),controller._queue=[],ReadableStreamError(stream,e)}function ReadableStreamBYOBControllerGetDesiredSize(controller){return controller._strategyHWM-controller._totalQueuedBytes}function ReadableStreamBYOBControllerRespond(controller,bytesWritten){if(bytesWritten=Number(bytesWritten),IsFiniteNonNegativeNumber(bytesWritten)===!1)throw new RangeError("bytesWritten must be a finite");assert(controller._pendingPullIntos.length>0),ReadableStreamBYOBControllerRespondInternal(controller,bytesWritten)}function ReadableStreamBYOBControllerRespondWithNewView(controller,view){assert(controller._pendingPullIntos.length>0);var firstDescriptor=controller._pendingPullIntos[0];if(firstDescriptor.byteOffset+firstDescriptor.bytesFilled!==view.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(firstDescriptor.byteLength!==view.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");firstDescriptor.buffer=view.buffer,ReadableStreamBYOBControllerRespondInternal(controller,view.byteLength)}function closure_WritableStreamErrorFunction(){var f=function f(e){return ErrorWritableStream(f._stream,e)};return f}function CallOrScheduleWritableStreamAdvanceQueue(stream){return stream._started===!1?void stream._startedPromise.then(function(){WritableStreamAdvanceQueue(stream)})["catch"](rethrowAssertionErrorRejection):stream._started===!0?WritableStreamAdvanceQueue(stream):void 0}function CloseWritableStream(stream){assert$4("closing"===stream._state,"stream must be in closing state while calling CloseWritableStream");var sinkClosePromise=PromiseInvokeOrNoop(stream._underlyingSink,"close");sinkClosePromise.then(function(){"errored"!==stream._state&&(assert$4("closing"===stream._state),stream._closedPromise_resolve(void 0),stream._closedPromise_resolve=void 0,stream._closedPromise_reject=void 0,stream._state="closed")},function(r){return ErrorWritableStream(stream,r)})["catch"](rethrowAssertionErrorRejection)}function ErrorWritableStream(stream,e){if("closed"!==stream._state&&"errored"!==stream._state){for(;stream._queue.length>0;){var writeRecord=DequeueValue(stream._queue);"close"!==writeRecord&&writeRecord._reject(e)}stream._storedError=e,"waiting"===stream._state&&stream._readyPromise_resolve(void 0),stream._closedPromise_reject(e),stream._closedPromise_resolve=void 0,stream._closedPromise_reject=void 0,stream._state="errored"}}function IsWritableStream(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_underlyingSink"):!1}function SyncWritableStreamStateWithQueue(stream){if("closing"!==stream._state){assert$4("writable"===stream._state||"waiting"===stream._state,"stream must be in a writable or waiting state while calling SyncWritableStreamStateWithQueue");var queueSize=GetTotalQueueSize(stream._queue),shouldApplyBackpressure=queueSize>stream._strategyHWM;shouldApplyBackpressure===!0&&"writable"===stream._state&&(stream._state="waiting",stream._readyPromise=new Promise(function(resolve,reject){stream._readyPromise_resolve=resolve})),shouldApplyBackpressure===!1&&"waiting"===stream._state&&(stream._state="writable",stream._readyPromise_resolve(void 0))}}function WritableStreamAdvanceQueue(stream){if(0!==stream._queue.length&&stream._writing!==!0){var writeRecord=PeekQueueValue(stream._queue);return"close"===writeRecord?(assert$4("closing"===stream._state,"can't process final write record unless already closing"),DequeueValue(stream._queue),assert$4(0===stream._queue.length,"queue must be empty once the final write record is dequeued"),CloseWritableStream(stream)):(stream._writing=!0,void PromiseInvokeOrNoop(stream._underlyingSink,"write",[writeRecord.chunk]).then(function(){"errored"!==stream._state&&(stream._writing=!1,writeRecord._resolve(void 0),DequeueValue(stream._queue),SyncWritableStreamStateWithQueue(stream),WritableStreamAdvanceQueue(stream))},function(r){return ErrorWritableStream(stream,r)})["catch"](rethrowAssertionErrorRejection))}}function ReadableByteStreamControllerCallPull(controller){var stream=controller._controlledReadableByteStream;controller._pullAgain=!1,controller._pulling=!0;try{InvokeOrNoop(controller._underlyingByteSource,"pull",[])}catch(e){DestroyReadableByteStreamController(controller),"readable"===stream._state&&ErrorReadableByteStream(stream,e)}controller._pulling=!1}function ReadableByteStreamControllerCallPullInto(controller){controller._controlledReadableByteStream;assert$5(controller._pendingPullIntos.length>0);var pullIntoDescriptor=controller._pendingPullIntos[0];controller._pullAgain=!1,controller._pulling=!0;try{InvokeOrNoop(controller._underlyingByteSource,"pullInto",[new Uint8Array(pullIntoDescriptor.buffer,pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled,pullIntoDescriptor.byteLength-pullIntoDescriptor.bytesFilled)]);
}catch(e){DestroyReadableByteStreamController(controller);var _stream=controller._controlledReadableByteStream;"readable"===_stream._state&&ErrorReadableByteStream(_stream,e)}controller._pulling=!1}function ReadableByteStreamControllerCallPullOrPullIntoLaterIfNeeded(controller){controller._pullAgain=!0,controller._pulling||process.nextTick(ReadableByteStreamControllerCallPullOrPullIntoRepeatedlyIfNeeded.bind(void 0,controller))}function ReadableByteStreamControllerCallPullOrPullIntoRepeatedlyIfNeeded(controller){for(var stream=controller._controlledReadableByteStream;;){if(!controller._pullAgain)return;if(controller._closeRequested)return;if("readable"!==stream._state)return;var reader=stream._reader;if(void 0===reader)return;if(IsReadableByteStreamReader(reader)){if(0===reader._readRequests.length)return;ReadableByteStreamControllerCallPull(controller)}else{if(assert$5(IsReadableByteStreamByobReader(reader),"reader must be ReadableByteStreamByobReader"),0===reader._readIntoRequests.length)return;ReadableByteStreamControllerCallPullInto(controller)}}}function CancelReadableByteStream(stream,reason){if("closed"===stream._state)return Promise.resolve(void 0);if("errored"===stream._state)return Promise.reject(stream._storedError);CloseReadableByteStream(stream);var sourceCancelPromise=CancelReadableByteStreamController(stream._controller,reason);return sourceCancelPromise.then(function(){})}function CancelReadableByteStreamController(controller,reason){return controller._pendingPullIntos.length>0&&(controller._pendingPullIntos[0].bytesFilled=0),controller._queue=[],controller._totalQueuedBytes=0,PromiseInvokeOrNoop(controller._underlyingByteSource,"cancel",[reason])}function CloseReadableByteStream(stream){assert$5(IsReadableByteStream(stream),"stream must be ReadableByteStream"),assert$5("readable"===stream._state,"state must be readable"),stream._state="closed";var reader=stream._reader;if(void 0!==reader){if(IsReadableByteStreamReader(reader)){var _iteratorNormalCompletion4=!0,_didIteratorError4=!1,_iteratorError4=void 0;try{for(var _step4,_iterator4=reader._readRequests[Symbol.iterator]();!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=!0){var req=_step4.value;req.resolve(CreateIterResultObject(void 0,!0))}}catch(err){_didIteratorError4=!0,_iteratorError4=err}finally{try{!_iteratorNormalCompletion4&&_iterator4["return"]&&_iterator4["return"]()}finally{if(_didIteratorError4)throw _iteratorError4}}reader._readRequests=[],ReleaseReadableByteStreamReaderGeneric(reader)}else assert$5(IsReadableByteStreamByobReader(reader),"reader must be ReadableByteStreamByobReader"),0===reader._readIntoRequests.length&&ReleaseReadableByteStreamReaderGeneric(reader);CloseReadableByteStreamReaderGeneric(reader)}}function CloseReadableByteStreamReaderGeneric(reader){reader._state="closed",reader._closedPromise_resolve(void 0),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0}function DestroyReadableByteStreamController(controller){controller._pendingPullIntos=[],controller._queue=[]}function TransferArrayBuffer$1(buffer){return buffer}function ReleaseReadableByteStreamReaderGeneric(reader){assert$5(void 0!==reader._ownerReadableByteStream._reader),assert$5(void 0!==reader._ownerReadableByteStream),reader._ownerReadableByteStream._reader=void 0,reader._ownerReadableByteStream=void 0}function EnqueueInReadableByteStreamController(controller,buffer,byteOffset,byteLength){controller._queue.push({buffer:buffer,byteOffset:byteOffset,byteLength:byteLength}),controller._totalQueuedBytes+=byteLength}function ErrorReadableByteStream(stream,e){assert$5(IsReadableByteStream(stream),"stream must be ReadableByteStream"),assert$5("readable"===stream._state,"state must be readable"),stream._state="errored",stream._storedError=e;var reader=stream._reader;if(void 0!==reader){if(IsReadableByteStreamReader(reader)){var _iteratorNormalCompletion5=!0,_didIteratorError5=!1,_iteratorError5=void 0;try{for(var _step5,_iterator5=reader._readRequests[Symbol.iterator]();!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=!0){var req=_step5.value;req.reject(e)}}catch(err){_didIteratorError5=!0,_iteratorError5=err}finally{try{!_iteratorNormalCompletion5&&_iterator5["return"]&&_iterator5["return"]()}finally{if(_didIteratorError5)throw _iteratorError5}}reader._readRequests=[]}else{assert$5(IsReadableByteStreamByobReader(reader),"reader must be ReadableByteStreamByobReader");var _iteratorNormalCompletion6=!0,_didIteratorError6=!1,_iteratorError6=void 0;try{for(var _step6,_iterator6=reader._readIntoRequests[Symbol.iterator]();!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=!0){var req=_step6.value;req.reject(e)}}catch(err){_didIteratorError6=!0,_iteratorError6=err}finally{try{!_iteratorNormalCompletion6&&_iterator6["return"]&&_iterator6["return"]()}finally{if(_didIteratorError6)throw _iteratorError6}}reader._readIntoRequests=[]}ReleaseReadableByteStreamReaderGeneric(reader),reader._state="errored",reader._storedError=e,reader._closedPromise_reject(e),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0}}function FillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor){var elementSize=pullIntoDescriptor.elementSize,currentAlignedBytes=pullIntoDescriptor.bytesFilled-pullIntoDescriptor.bytesFilled%elementSize,maxBytesToCopy=Math.min(controller._totalQueuedBytes,pullIntoDescriptor.byteLength-pullIntoDescriptor.bytesFilled),maxBytesFilled=pullIntoDescriptor.bytesFilled+maxBytesToCopy,maxAlignedBytes=maxBytesFilled-maxBytesFilled%elementSize,totalBytesToCopyRemaining=maxBytesToCopy,ready=!1;maxAlignedBytes>currentAlignedBytes&&(totalBytesToCopyRemaining=maxAlignedBytes-pullIntoDescriptor.bytesFilled,ready=!0);for(var queue=controller._queue;totalBytesToCopyRemaining>0;){var headOfQueue=queue[0],bytesToCopy=Math.min(totalBytesToCopyRemaining,headOfQueue.byteLength),destStart=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled;new Uint8Array(pullIntoDescriptor.buffer).set(new Uint8Array(headOfQueue.buffer,headOfQueue.byteOffset,bytesToCopy),destStart),headOfQueue.byteLength===bytesToCopy?queue.shift():(headOfQueue.byteOffset+=bytesToCopy,headOfQueue.byteLength-=bytesToCopy),controller._totalQueuedBytes-=bytesToCopy,pullIntoDescriptor.bytesFilled+=bytesToCopy,totalBytesToCopyRemaining-=bytesToCopy}return ready||(assert$5(0===controller._totalQueuedBytes,"queue must be empty"),assert$5(pullIntoDescriptor.bytesFilled>0),assert$5(pullIntoDescriptor.bytesFilled<pullIntoDescriptor.elementSize)),ready}function InitializeReadableByteStreamReaderGeneric(reader,stream){reader._state=stream._state,"readable"===stream._state?(stream._reader=reader,reader._ownerReadableByteStream=stream,reader._storedError=void 0,reader._closedPromise=new Promise(function(resolve,reject){reader._closedPromise_resolve=resolve,reader._closedPromise_reject=reject})):(reader._ownerReadableByteStream=void 0,"closed"===stream._state?(reader._storedError=void 0,reader._closedPromise=Promise.resolve(void 0),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0):(assert$5("errored"===stream._state,"state must be errored"),reader._storedError=stream._storedError,reader._closedPromise=Promise.reject(stream._storedError),reader._closedPromise_resolve=void 0,reader._closedPromise_reject=void 0))}function IsReadableByteStream(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_controller"):!1}function IsReadableByteStreamByobReader(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_readIntoRequests"):!1}function IsReadableByteStreamController(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_controlledReadableByteStream"):!1}function IsReadableByteStreamLocked(stream){return assert$5(IsReadableByteStream(stream),"IsReadableByteStreamLocked should only be used on known readable byte streams"),void 0!==stream._reader}function IsReadableByteStreamReader(x){return typeIsObject(x)?!!Object.prototype.hasOwnProperty.call(x,"_readRequests"):!1}function PullFromReadableByteStream(stream){var controller=stream._controller,reader=stream._reader;if(!(reader._readRequests.length>1)){if(assert$5(1===reader._readRequests.length),controller._totalQueuedBytes>0){var entry=controller._queue.shift();controller._totalQueuedBytes-=entry.byteLength;var view=new Uint8Array(entry.buffer,entry.byteOffset,entry.byteLength);return RespondToReadRequest(reader,view),void(0===controller._totalQueuedBytes&&controller._closeRequested&&CloseReadableByteStream(stream))}if(controller._pulling)return void(controller._pullAgain=!0);ReadableByteStreamControllerCallPull(controller),ReadableByteStreamControllerCallPullOrPullIntoRepeatedlyIfNeeded(controller)}}function PullFromReadableByteStreamInto(stream,buffer,byteOffset,byteLength,elementSize){var controller=stream._controller,pullIntoDescriptor={buffer:buffer,byteOffset:byteOffset,byteLength:byteLength,bytesFilled:0,elementSize:elementSize};if(controller._pendingPullIntos.length>0)return pullIntoDescriptor.buffer=TransferArrayBuffer$1(pullIntoDescriptor.buffer),void controller._pendingPullIntos.push(pullIntoDescriptor);if(controller._totalQueuedBytes>0){var ready=FillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor);if(ready)return RespondToReadIntoRequest(stream._reader,pullIntoDescriptor.buffer,pullIntoDescriptor.bytesFilled),void(0===controller._totalQueuedBytes&&controller._closeRequested&&CloseReadableByteStream(stream));if(controller._closeRequested)return DestroyReadableByteStreamController(controller),void ErrorReadableByteStream(stream,new TypeError("Insufficient bytes to fill elements in the given buffer"))}return pullIntoDescriptor.buffer=TransferArrayBuffer$1(pullIntoDescriptor.buffer),controller._pendingPullIntos.push(pullIntoDescriptor),controller._pulling?void(controller._pullAgain=!0):(ReadableByteStreamControllerCallPullInto(controller),void ReadableByteStreamControllerCallPullOrPullIntoRepeatedlyIfNeeded(controller))}function RespondToByobReaderInClosedState(controller,reader,buffer){var firstDescriptor=controller._pendingPullIntos[0];for(void 0!==buffer&&(firstDescriptor.buffer=buffer),firstDescriptor.buffer=TransferArrayBuffer$1(firstDescriptor.buffer),assert$5(0===firstDescriptor.bytesFilled,"bytesFilled must be 0");reader._readIntoRequests.length>0;){var descriptor=controller._pendingPullIntos.shift();RespondToReadIntoRequest(reader,descriptor.buffer)}ReleaseReadableByteStreamReaderGeneric(reader)}function RespondToByobReaderInReadableState(controller,reader,bytesWritten,buffer){var pullIntoDescriptor=controller._pendingPullIntos[0];if(pullIntoDescriptor.bytesFilled+bytesWritten>pullIntoDescriptor.byteLength)throw new RangeError("bytesWritten out of range");if(void 0!==buffer&&(pullIntoDescriptor.buffer=buffer),pullIntoDescriptor.bytesFilled+=bytesWritten,pullIntoDescriptor.bytesFilled<pullIntoDescriptor.elementSize)return void ReadableByteStreamControllerCallPullOrPullIntoLaterIfNeeded(controller);controller._pendingPullIntos.shift();var remainderSize=pullIntoDescriptor.bytesFilled%pullIntoDescriptor.elementSize;if(remainderSize>0){var end=pullIntoDescriptor.byteOffset+pullIntoDescriptor.bytesFilled,remainder=pullIntoDescriptor.buffer.slice(end-remainderSize,end);EnqueueInReadableByteStreamController(controller,remainder,0,remainder.byteLength)}RespondToReadIntoRequest(reader,TransferArrayBuffer$1(pullIntoDescriptor.buffer),pullIntoDescriptor.bytesFilled-remainderSize),RespondToReadIntoRequestsFromQueue(controller,reader)}function RespondToReadIntoRequest(reader,buffer,length){assert$5(reader._readIntoRequests.length>0,"readIntoRequest must not be empty when calling RespondToReadIntoRequest"),assert$5("errored"!==reader._state,"state must not be errored");var req=reader._readIntoRequests.shift(),ctor=req.ctor,byteOffset=req.byteOffset;if("closed"===reader._state){assert$5(void 0===length);var _view=new ctor(buffer,byteOffset,0);return void req.resolve(CreateIterResultObject(_view,!0))}assert$5(length<=req.byteLength),assert$5(length%req.elementSize===0);var view=new ctor(buffer,byteOffset,length/req.elementSize);req.resolve(CreateIterResultObject(view,!1))}function RespondToReadRequest(reader,view){var req=reader._readRequests.shift();req.resolve(CreateIterResultObject(view,!1))}function RespondToReadIntoRequestsFromQueue(controller,reader){for(assert$5(!controller._closeRequested);controller._pendingPullIntos.length>0;){if(0===controller._totalQueuedBytes)return void ReadableByteStreamControllerCallPullOrPullIntoLaterIfNeeded(controller);var pullIntoDescriptor=controller._pendingPullIntos[0],ready=FillPullIntoDescriptorFromQueue(controller,pullIntoDescriptor);ready&&(controller._pendingPullIntos.shift(),RespondToReadIntoRequest(reader,pullIntoDescriptor.buffer,pullIntoDescriptor.bytesFilled))}}Object.defineProperty(exports,"__esModule",{value:!0});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!i||_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{!_n&&_i["return"]&&_i["return"]()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr))return sliceIterator(arr,i);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol?"symbol":typeof obj},assert$1=require("assert"),assert$2=require("assert"),assert$3=require("assert"),assert=require("assert"),InternalCancel=Symbol(),InternalPull=Symbol(),ReadableStream=function(){function ReadableStream(){var underlyingSource=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],_ref=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],size=_ref.size,highWaterMark=_ref.highWaterMark;_classCallCheck(this,ReadableStream),this._state="readable",this._reader=void 0,this._storedError=void 0,this._disturbed=!1,this._readableStreamController=void 0;var byob=underlyingSource.byob;byob===!0?(void 0===highWaterMark&&(highWaterMark=0),this._readableStreamController=new ReadableStreamBYOBController(this,underlyingSource,highWaterMark)):(void 0===highWaterMark&&(highWaterMark=1),this._readableStreamController=new ReadableStreamDefaultController(this,underlyingSource,size,highWaterMark))}return _createClass(ReadableStream,[{key:"cancel",value:function(reason){return IsReadableStream(this)===!1?Promise.reject(new TypeError("ReadableStream.prototype.cancel can only be used on a ReadableStream")):IsReadableStreamLocked(this)===!0?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):ReadableStreamCancel(this,reason)}},{key:"getBYOBReader",value:function(){if(IsReadableStream(this)===!1)throw new TypeError("ReadableStream.prototype.getBYOBReader can only be used on a ReadableStream constructed with a byte source");if(IsReadableStreamBYOBController(this._readableStreamController)===!1)throw new TypeError("Cannot get a ReadableStreamBYOBReader for a stream not constructed with a byte source");return AcquireReadableStreamBYOBReader(this)}},{key:"getReader",value:function(){if(IsReadableStream(this)===!1)throw new TypeError("ReadableStream.prototype.getReader can only be used on a ReadableStream");return AcquireReadableStreamDefaultReader(this)}},{key:"pipeThrough",value:function(_ref2,options){var writable=_ref2.writable,readable=_ref2.readable;return this.pipeTo(writable,options),readable}},{key:"pipeTo",value:function(dest){function doPipe(){lastRead=reader.read(),Promise.all([lastRead,dest.ready]).then(function(_ref4){var _ref5=_slicedToArray(_ref4,1),_ref5$=_ref5[0],value=_ref5$.value,done=_ref5$.done;Boolean(done)===!0?closeDest():"writable"===dest.state&&(lastWrite=dest.write(value),doPipe())})["catch"](rethrowAssertionErrorRejection)}function cancelSource(reason){preventCancel===!1?(reader.cancel(reason),reader.releaseLock(),rejectPipeToPromise(reason)):lastRead.then(function(){reader.releaseLock(),rejectPipeToPromise(reason)})}function closeDest(){reader.releaseLock();var destState=dest.state;preventClose!==!1||"waiting"!==destState&&"writable"!==destState?void 0!==lastWrite?lastWrite.then(resolvePipeToPromise,rejectPipeToPromise):resolvePipeToPromise():(closedPurposefully=!0,dest.close().then(resolvePipeToPromise,rejectPipeToPromise))}function abortDest(reason){reader.releaseLock(),preventAbort===!1&&dest.abort(reason),rejectPipeToPromise(reason)}var _ref3=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],preventClose=_ref3.preventClose,preventAbort=_ref3.preventAbort,preventCancel=_ref3.preventCancel;preventClose=Boolean(preventClose),preventAbort=Boolean(preventAbort),preventCancel=Boolean(preventCancel);var source=this,reader=void 0,lastRead=void 0,lastWrite=void 0,closedPurposefully=!1,resolvePipeToPromise=void 0,rejectPipeToPromise=void 0;return new Promise(function(resolve,reject){resolvePipeToPromise=resolve,rejectPipeToPromise=reject,reader=source.getReader(),reader.closed["catch"](abortDest),dest.closed.then(function(){closedPurposefully||cancelSource(new TypeError("destination is closing or closed and cannot be piped to anymore"))},cancelSource),doPipe()})}},{key:"tee",value:function(){if(IsReadableStream(this)===!1)throw new TypeError("ReadableStream.prototype.tee can only be used on a ReadableStream");var branches=ReadableStreamTee(this,!1);return createArrayFromList(branches)}},{key:"locked",get:function(){if(IsReadableStream(this)===!1)throw new TypeError("ReadableStream.prototype.locked can only be used on a ReadableStream");return IsReadableStreamLocked(this)}}]),ReadableStream}(),ReadableStreamDefaultReader=function(){function ReadableStreamDefaultReader(stream){if(_classCallCheck(this,ReadableStreamDefaultReader),IsReadableStream(stream)===!1)throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");if(IsReadableStreamLocked(stream)===!0)throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,stream),this._readRequests=[]}return _createClass(ReadableStreamDefaultReader,[{key:"cancel",value:function(reason){return IsReadableStreamDefaultReader(this)===!1?Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.cancel can only be used on a ReadableStreamDefaultReader")):void 0===this._ownerReadableStream?Promise.reject(new TypeError("Cannot cancel a stream using a released reader")):ReadableStreamReaderGenericCancel(this,reason)}},{key:"read",value:function(){return IsReadableStreamDefaultReader(this)===!1?Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.read can only be used on a ReadableStreamDefaultReader")):void 0===this._ownerReadableStream?Promise.reject(new TypeError("Cannot read from a released reader")):ReadableStreamDefaultReaderRead(this)}},{key:"releaseLock",value:function(){if(IsReadableStreamDefaultReader(this)===!1)throw new TypeError("ReadableStreamDefaultReader.prototype.releaseLock can only be used on a ReadableStreamDefaultReader");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}},{key:"closed",get:function(){return IsReadableStreamDefaultReader(this)===!1?Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.closed can only be used on a ReadableStreamDefaultReader")):this._closedPromise}}]),ReadableStreamDefaultReader}(),ReadableStreamBYOBReader=function(){function ReadableStreamBYOBReader(stream){if(_classCallCheck(this,ReadableStreamBYOBReader),!IsReadableStream(stream))throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");if(IsReadableStreamLocked(stream))throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,stream),this._readIntoRequests=[]}return _createClass(ReadableStreamBYOBReader,[{key:"cancel",value:function(reason){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?Promise.reject(new TypeError("Cannot cancel a stream using a released reader")):ReadableStreamReaderGenericCancel(this,reason):Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.cancel can only be used on a ReadableStreamBYOBReader"))}},{key:"read",value:function(view){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?Promise.reject(new TypeError("Cannot read from a released reader")):ArrayBuffer.isView(view)?0===view.byteLength?Promise.reject(new TypeError("view must have non-zero byteLength")):ReadableStreamBYOBReaderRead(this,view):Promise.reject(new TypeError("view must be an array buffer view")):Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.read can only be used on a ReadableStreamBYOBReader"))}},{key:"releaseLock",value:function(){if(!IsReadableStreamBYOBReader(this))throw new TypeError("ReadableStreamBYOBReader.prototype.releaseLock can only be used on a ReadableStreamBYOBReader");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}},{key:"closed",get:function(){return IsReadableStreamBYOBReader(this)?this._closedPromise:Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.closed can only be used on a ReadableStreamBYOBReader"))}}]),ReadableStreamBYOBReader}(),ReadableStreamDefaultController=function(){function ReadableStreamDefaultController(stream,underlyingSource,size,highWaterMark){if(_classCallCheck(this,ReadableStreamDefaultController),IsReadableStream(stream)===!1)throw new TypeError("ReadableStreamDefaultController can only be constructed with a ReadableStream instance");if(void 0!==stream._readableStreamController)throw new TypeError("ReadableStreamDefaultController instances can only be created by the ReadableStream constructor");this._controlledReadableStream=stream,this._underlyingSource=underlyingSource,this._queue=[],this._started=!1,this._closeRequested=!1,this._pullAgain=!1,this._pulling=!1;var normalizedStrategy=ValidateAndNormalizeQueuingStrategy(size,highWaterMark);this._strategySize=normalizedStrategy.size,this._strategyHWM=normalizedStrategy.highWaterMark;var controller=this,startResult=InvokeOrNoop(underlyingSource,"start",[this]);Promise.resolve(startResult).then(function(){controller._started=!0,ReadableStreamDefaultControllerCallPullIfNeeded(controller)},function(r){"readable"===stream._state&&ReadableStreamDefaultControllerError(controller,r)})["catch"](rethrowAssertionErrorRejection)}return _createClass(ReadableStreamDefaultController,[{key:"close",value:function(){if(IsReadableStreamDefaultController(this)===!1)throw new TypeError("ReadableStreamDefaultController.prototype.close can only be used on a ReadableStreamDefaultController");if(this._closeRequested===!0)throw new TypeError("The stream has already been closed; do not close it again!");var state=this._controlledReadableStream._state;if("readable"!==state)throw new TypeError("The stream (in "+state+" state) is not in the readable state and cannot be closed");ReadableStreamDefaultControllerClose(this)}},{key:"enqueue",value:function(chunk){if(IsReadableStreamDefaultController(this)===!1)throw new TypeError("ReadableStreamDefaultController.prototype.enqueue can only be used on a ReadableStreamDefaultController");if(this._closeRequested===!0)throw new TypeError("stream is closed or draining");var state=this._controlledReadableStream._state;if("readable"!==state)throw new TypeError("The stream (in "+state+" state) is not in the readable state and cannot be enqueued to");return ReadableStreamDefaultControllerEnqueue(this,chunk)}},{key:"error",value:function(e){if(IsReadableStreamDefaultController(this)===!1)throw new TypeError("ReadableStreamDefaultController.prototype.error can only be used on a ReadableStreamDefaultController");var stream=this._controlledReadableStream;if("readable"!==stream._state)throw new TypeError("The stream is "+stream._state+" and so cannot be errored");ReadableStreamDefaultControllerError(this,e)}},{key:InternalCancel,value:function(reason){return this._queue=[],PromiseInvokeOrNoop(this._underlyingSource,"cancel",[reason])}},{key:InternalPull,value:function(){var stream=this._controlledReadableStream;if(this._queue.length>0){var chunk=DequeueValue(this._queue);return this._closeRequested===!0&&0===this._queue.length?ReadableStreamClose(stream):ReadableStreamDefaultControllerCallPullIfNeeded(this),Promise.resolve(CreateIterResultObject(chunk,!1))}var pendingPromise=ReadableStreamAddReadRequest(stream);return ReadableStreamDefaultControllerCallPullIfNeeded(this),pendingPromise}},{key:"desiredSize",get:function(){if(IsReadableStreamDefaultController(this)===!1)throw new TypeError("ReadableStreamDefaultController.prototype.desiredSize can only be used on a ReadableStreamDefaultController");return ReadableStreamDefaultControllerGetDesiredSize(this)}}]),ReadableStreamDefaultController}(),ReadableStreamBYOBRequest=function(){function ReadableStreamBYOBRequest(controller,descriptor){_classCallCheck(this,ReadableStreamBYOBRequest),this._associatedReadableStreamBYOBController=controller,this._view=new Uint8Array(descriptor.buffer,descriptor.byteOffset+descriptor.bytesFilled,descriptor.byteLength-descriptor.bytesFilled)}return _createClass(ReadableStreamBYOBRequest,[{key:"respond",value:function(bytesWritten){if(IsReadableStreamBYOBRequest(this)===!1)throw new TypeError("ReadableStreamBYOBController.prototype.respond can only be used on a ReadableStreamBYOBController");if(void 0===this._associatedReadableStreamBYOBController)throw new TypeError("This BYOB request has been invalidated");ReadableStreamBYOBControllerRespond(this._associatedReadableStreamBYOBController,bytesWritten)}},{key:"respondWithNewView",value:function(view){if(IsReadableStreamBYOBRequest(this)===!1)throw new TypeError("ReadableStreamBYOBController.prototype.respond can only be used on a ReadableStreamBYOBController");if(void 0===this._associatedReadableStreamBYOBController)throw new TypeError("This BYOB request has been invalidated");if(!ArrayBuffer.isView(view))throw new TypeError("You can only respond with array buffer views");ReadableStreamBYOBControllerRespondWithNewView(this._associatedReadableStreamBYOBController,view)}},{key:"_invalidate",value:function(){this._associatedReadableStreamBYOBController=void 0,this._view=void 0}},{key:"view",get:function(){return this._view}}]),ReadableStreamBYOBRequest}(),ReadableStreamBYOBController=function(){function ReadableStreamBYOBController(controlledReadableStream,underlyingByteSource,highWaterMark){if(_classCallCheck(this,ReadableStreamBYOBController),IsReadableStream(controlledReadableStream)===!1)throw new TypeError("ReadableStreamBYOBController can only be constructed with a ReadableStream instance given a byte source");if(void 0!==controlledReadableStream._readableStreamController)throw new TypeError("ReadableStreamBYOBController instances can only be created by the ReadableStream constructor given a byte source");this._controlledReadableStream=controlledReadableStream,this._underlyingByteSource=underlyingByteSource,this._pullAgain=!1,this._pulling=!1,ReadableStreamBYOBControllerClearPendingPullIntos(this),this._queue=[],this._totalQueuedBytes=0,this._closeRequested=!1,this._started=!1,this._strategyHWM=ValidateAndNormalizeHighWaterMark(highWaterMark);var autoAllocateChunkSize=underlyingByteSource.autoAllocateChunkSize;if(void 0!==autoAllocateChunkSize&&(Number.isInteger(autoAllocateChunkSize)===!1||0>autoAllocateChunkSize))throw new RangeError("autoAllocateChunkSize must be a non negative integer");this._autoAllocateChunkSize=autoAllocateChunkSize,this._pendingPullIntos=[];var controller=this,startResult=InvokeOrNoop(underlyingByteSource,"start",[this]);Promise.resolve(startResult).then(function(){controller._started=!0,assert(controller._pulling===!1),assert(controller._pullAgain===!1),ReadableStreamBYOBControllerCallPullIfNeeded(controller)},function(r){"readable"===controlledReadableStream._state&&ReadableStreamBYOBControllerError(controller,r)})["catch"](rethrowAssertionErrorRejection)}return _createClass(ReadableStreamBYOBController,[{key:"close",value:function(){if(IsReadableStreamBYOBController(this)===!1)throw new TypeError("ReadableStreamBYOBController.prototype.close can only be used on a ReadableStreamBYOBController");if(this._closeRequested===!0)throw new TypeError("The stream has already been closed; do not close it again!");var state=this._controlledReadableStream._state;if("readable"!==state)throw new TypeError("The stream (in "+state+" state) is not in the readable state and cannot be closed");ReadableStreamBYOBControllerClose(this)}},{key:"enqueue",value:function(chunk){if(IsReadableStreamBYOBController(this)===!1)throw new TypeError("ReadableStreamBYOBController.prototype.enqueue can only be used on a ReadableStreamBYOBController");if(this._closeRequested===!0)throw new TypeError("stream is closed or draining");var state=this._controlledReadableStream._state;if("readable"!==state)throw new TypeError("The stream (in "+state+" state) is not in the readable state and cannot be enqueued to");if(!ArrayBuffer.isView(chunk))throw new TypeError("You can only enqueue array buffer views when using a ReadableStreamBYOBController");ReadableStreamBYOBControllerEnqueue(this,chunk)}},{key:"error",value:function(e){if(IsReadableStreamBYOBController(this)===!1)throw new TypeError("ReadableStreamBYOBController.prototype.error can only be used on a ReadableStreamBYOBController");var stream=this._controlledReadableStream;if("readable"!==stream._state)throw new TypeError("The stream is "+stream._state+" and so cannot be errored");ReadableStreamBYOBControllerError(this,e)}},{key:InternalCancel,value:function(reason){if(this._pendingPullIntos.length>0){var firstDescriptor=this._pendingPullIntos[0];firstDescriptor.bytesFilled=0}return this._queue=[],this._totalQueuedBytes=0,PromiseInvokeOrNoop(this._underlyingByteSource,"cancel",[reason])}},{key:InternalPull,value:function(){var stream=this._controlledReadableStream;if(0===ReadableStreamGetNumReadRequests(stream)){if(this._totalQueuedBytes>0){var entry=this._queue.shift();this._totalQueuedBytes-=entry.byteLength,ReadableStreamBYOBControllerHandleQueueDrain(this);var view=new Uint8Array(entry.buffer,entry.byteOffset,entry.byteLength);return Promise.resolve(CreateIterResultObject(view,!1))}var autoAllocateChunkSize=this._autoAllocateChunkSize;if(void 0!==autoAllocateChunkSize){var buffer=new ArrayBuffer(autoAllocateChunkSize),pullIntoDescriptor={buffer:buffer,byteOffset:0,byteLength:autoAllocateChunkSize,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(pullIntoDescriptor)}}else assert(void 0===this._autoAllocateChunkSize);var promise=ReadableStreamAddReadRequest(stream);return ReadableStreamBYOBControllerCallPullIfNeeded(this),promise}},{key:"byobRequest",get:function(){
if(IsReadableStreamBYOBController(this)===!1)throw new TypeError("ReadableStreamBYOBController.prototype.byobRequest can only be used on a ReadableStreamBYOBController");if(void 0===this._byobRequest&&this._pendingPullIntos.length>0){var firstDescriptor=this._pendingPullIntos[0];this._byobRequest=new ReadableStreamBYOBRequest(this,firstDescriptor)}return this._byobRequest}},{key:"desiredSize",get:function(){if(IsReadableStreamBYOBController(this)===!1)throw new TypeError("ReadableStreamBYOBController.prototype.desiredSize can only be used on a ReadableStreamBYOBController");return ReadableStreamBYOBControllerGetDesiredSize(this)}}]),ReadableStreamBYOBController}(),CountQueuingStrategy=function(){function CountQueuingStrategy(_ref6){var highWaterMark=_ref6.highWaterMark;_classCallCheck(this,CountQueuingStrategy),createDataProperty(this,"highWaterMark",highWaterMark)}return _createClass(CountQueuingStrategy,[{key:"size",value:function(chunk){return 1}}]),CountQueuingStrategy}(),assert$4=require("assert"),WritableStream=function(){function WritableStream(){var _this=this,underlyingSink=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],_ref7=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],size=_ref7.size,_ref7$highWaterMark=_ref7.highWaterMark,highWaterMark=void 0===_ref7$highWaterMark?0:_ref7$highWaterMark;_classCallCheck(this,WritableStream),this._underlyingSink=underlyingSink,this._closedPromise=new Promise(function(resolve,reject){_this._closedPromise_resolve=resolve,_this._closedPromise_reject=reject}),this._readyPromise=Promise.resolve(void 0),this._readyPromise_resolve=null,this._queue=[],this._state="writable",this._started=!1,this._writing=!1;var normalizedStrategy=ValidateAndNormalizeQueuingStrategy(size,highWaterMark);this._strategySize=normalizedStrategy.size,this._strategyHWM=normalizedStrategy.highWaterMark,SyncWritableStreamStateWithQueue(this);var error=closure_WritableStreamErrorFunction();error._stream=this;var startResult=InvokeOrNoop(underlyingSink,"start",[error]);this._startedPromise=Promise.resolve(startResult),this._startedPromise.then(function(){_this._started=!0,_this._startedPromise=void 0}),this._startedPromise["catch"](function(r){return ErrorWritableStream(_this,r)})["catch"](rethrowAssertionErrorRejection)}return _createClass(WritableStream,[{key:"abort",value:function(reason){if(!IsWritableStream(this))return Promise.reject(new TypeError("WritableStream.prototype.abort can only be used on a WritableStream"));if("closed"===this._state)return Promise.resolve(void 0);if("errored"===this._state)return Promise.reject(this._storedError);ErrorWritableStream(this,reason);var sinkAbortPromise=PromiseInvokeOrFallbackOrNoop(this._underlyingSink,"abort",[reason],"close",[]);return sinkAbortPromise.then(function(){})}},{key:"close",value:function(){return IsWritableStream(this)?"closing"===this._state?Promise.reject(new TypeError("cannot close an already-closing stream")):"closed"===this._state?Promise.reject(new TypeError("cannot close an already-closed stream")):"errored"===this._state?Promise.reject(this._storedError):("waiting"===this._state&&this._readyPromise_resolve(void 0),this._state="closing",EnqueueValueWithSize(this._queue,"close",0),CallOrScheduleWritableStreamAdvanceQueue(this),this._closedPromise):Promise.reject(new TypeError("WritableStream.prototype.close can only be used on a WritableStream"))}},{key:"write",value:function(chunk){if(!IsWritableStream(this))return Promise.reject(new TypeError("WritableStream.prototype.write can only be used on a WritableStream"));if("closing"===this._state)return Promise.reject(new TypeError("cannot write while stream is closing"));if("closed"===this._state)return Promise.reject(new TypeError("cannot write after stream is closed"));if("errored"===this._state)return Promise.reject(this._storedError);assert$4("waiting"===this._state||"writable"===this._state);var chunkSize=1;if(void 0!==this._strategySize)try{chunkSize=this._strategySize(chunk)}catch(chunkSizeE){return ErrorWritableStream(this,chunkSizeE),Promise.reject(chunkSizeE)}var resolver=void 0,rejecter=void 0,promise=new Promise(function(resolve,reject){resolver=resolve,rejecter=reject}),writeRecord={promise:promise,chunk:chunk,_resolve:resolver,_reject:rejecter};try{EnqueueValueWithSize(this._queue,writeRecord,chunkSize)}catch(enqueueResultE){return ErrorWritableStream(this,enqueueResultE),Promise.reject(enqueueResultE)}return SyncWritableStreamStateWithQueue(this),CallOrScheduleWritableStreamAdvanceQueue(this),promise}},{key:"closed",get:function(){return IsWritableStream(this)?this._closedPromise:Promise.reject(new TypeError("WritableStream.prototype.closed can only be used on a WritableStream"))}},{key:"state",get:function(){if(!IsWritableStream(this))throw new TypeError("WritableStream.prototype.state can only be used on a WritableStream");return this._state}},{key:"ready",get:function(){return IsWritableStream(this)?this._readyPromise:Promise.reject(new TypeError("WritableStream.prototype.ready can only be used on a WritableStream"))}}]),WritableStream}(),ByteLengthQueuingStrategy=function(){function ByteLengthQueuingStrategy(_ref8){var highWaterMark=_ref8.highWaterMark;_classCallCheck(this,ByteLengthQueuingStrategy),createDataProperty(this,"highWaterMark",highWaterMark)}return _createClass(ByteLengthQueuingStrategy,[{key:"size",value:function(chunk){return chunk.byteLength}}]),ByteLengthQueuingStrategy}(),TransformStream=function TransformStream(transformer){function maybeDoTransform(){if(transforming===!1){transforming=!0;try{transformer.transform(writeChunk,enqueueInReadable,transformDone),writeChunk=void 0,chunkWrittenButNotYetTransformed=!1}catch(e){transforming=!1,errorWritable(e),errorReadable(e)}}}function transformDone(){transforming=!1,writeDone()}if(_classCallCheck(this,TransformStream),void 0===transformer.flush&&(transformer.flush=function(enqueue,close){return close()}),"function"!=typeof transformer.transform)throw new TypeError("transform must be a function");var writeChunk=void 0,writeDone=void 0,errorWritable=void 0,transforming=!1,chunkWrittenButNotYetTransformed=!1;this.writable=new WritableStream({start:function(error){errorWritable=error},write:function(chunk){writeChunk=chunk,chunkWrittenButNotYetTransformed=!0;var p=new Promise(function(resolve){return writeDone=resolve});return maybeDoTransform(),p},close:function(){try{transformer.flush(enqueueInReadable,closeReadable)}catch(e){errorWritable(e),errorReadable(e)}}},transformer.writableStrategy);var enqueueInReadable=void 0,closeReadable=void 0,errorReadable=void 0;this.readable=new ReadableStream({start:function(c){enqueueInReadable=c.enqueue.bind(c),closeReadable=c.close.bind(c),errorReadable=c.error.bind(c)},pull:function(){chunkWrittenButNotYetTransformed===!0&&maybeDoTransform()}},transformer.readableStrategy)},assert$5=require("assert"),ReadableByteStream=function(){function ReadableByteStream(){var underlyingByteSource=arguments.length<=0||void 0===arguments[0]?{}:arguments[0];_classCallCheck(this,ReadableByteStream),this._state="readable",this._reader=void 0,this._storedError=void 0,this._controller=void 0,this._controller=new ReadableByteStreamController(this,underlyingByteSource)}return _createClass(ReadableByteStream,[{key:"cancel",value:function(reason){return IsReadableByteStream(this)===!1?Promise.reject(new TypeError("ReadableByteStream.prototype.cancel can only be used on a ReadableByteStream")):IsReadableByteStreamLocked(this)===!0?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):CancelReadableByteStream(this,reason)}},{key:"getByobReader",value:function(){if(IsReadableByteStream(this)===!1)throw new TypeError("ReadableByteStream.prototype.getByobReader can only be used on a ReadableByteStream");return new ReadableByteStreamByobReader(this)}},{key:"getReader",value:function(){if(IsReadableByteStream(this)===!1)throw new TypeError("ReadableByteStream.prototype.getReader can only be used on a ReadableByteStream");return new ReadableByteStreamReader(this)}}]),ReadableByteStream}(),ReadableByteStreamController=function(){function ReadableByteStreamController(controlledReadableByteStream,underlyingByteSource){if(_classCallCheck(this,ReadableByteStreamController),IsReadableByteStream(controlledReadableByteStream)===!1)throw new TypeError("ReadableByteStreamController can only be constructed with a ReadableByteStream instance");if(void 0!==controlledReadableByteStream._controller)throw new TypeError("ReadableByteStreamController instances can only be created by the ReadableByteStream constructor");this._controlledReadableByteStream=controlledReadableByteStream,this._underlyingByteSource=underlyingByteSource,this._pullAgain=!1,this._pulling=!1,this._pendingPullIntos=[],this._queue=[],this._totalQueuedBytes=0,this._closeRequested=!1,InvokeOrNoop(underlyingByteSource,"start",[this])}return _createClass(ReadableByteStreamController,[{key:"close",value:function(){if(!IsReadableByteStreamController(this))throw new TypeError("ReadableByteStreamController.prototype.close can only be used on a ReadableByteStreamController");var stream=this._controlledReadableByteStream;if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");if("readable"!==stream._state)throw new TypeError("The stream is not in the readable state and cannot be closed");if(this._totalQueuedBytes>0)return void(this._closeRequested=!0);var reader=stream._reader;if(IsReadableByteStreamByobReader(reader)&&this._pendingPullIntos.length>0){var pullInto=this._pendingPullIntos[0];if(pullInto.bytesFilled>0){DestroyReadableByteStreamController(this);var e=new TypeError("Insufficient bytes to fill elements in the given buffer");throw ErrorReadableByteStream(stream,e),e}}CloseReadableByteStream(stream)}},{key:"enqueue",value:function(chunk){if(!IsReadableByteStreamController(this))throw new TypeError("ReadableByteStreamController.prototype.enqueue can only be used on a ReadableByteStreamController");var stream=this._controlledReadableByteStream;if(this._closeRequested)throw new TypeError("stream is closed or draining");if("readable"!==stream._state)throw new TypeError("The stream is not in the readable state and cannot be enqueued to");var reader=stream._reader,buffer=chunk.buffer,byteOffset=chunk.byteOffset,byteLength=chunk.byteLength;if(void 0===reader)EnqueueInReadableByteStreamController(this,TransferArrayBuffer$1(buffer),byteOffset,byteLength);else if(IsReadableByteStreamReader(reader))if(0===reader._readRequests.length)EnqueueInReadableByteStreamController(this,TransferArrayBuffer$1(buffer),byteOffset,byteLength);else{assert$5(0===this._queue.length);var transferredView=new Uint8Array(TransferArrayBuffer$1(buffer),byteOffset,byteLength);RespondToReadRequest(reader,transferredView),reader._readRequests.length>0&&ReadableByteStreamControllerCallPullOrPullIntoLaterIfNeeded(this)}else assert$5(IsReadableByteStreamByobReader(reader),"reader must be ReadableByteStreamByobReader"),EnqueueInReadableByteStreamController(this,TransferArrayBuffer$1(buffer),byteOffset,byteLength),RespondToReadIntoRequestsFromQueue(this,reader)}},{key:"error",value:function(e){if(!IsReadableByteStreamController(this))throw new TypeError("ReadableByteStreamController.prototype.error can only be used on a ReadableByteStreamController");var stream=this._controlledReadableByteStream;if("readable"!==stream._state)throw new TypeError("The stream is "+stream._state+" and so cannot be errored");DestroyReadableByteStreamController(this),ErrorReadableByteStream(stream,e)}},{key:"respond",value:function(bytesWritten,buffer){if(!IsReadableByteStreamController(this))throw new TypeError("ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController");var stream=this._controlledReadableByteStream;if(0===this._pendingPullIntos.length)throw new TypeError("No pending BYOB read");assert$5(IsReadableByteStreamLocked(stream),"stream must be locked");var reader=stream._reader;if(assert$5(IsReadableByteStreamByobReader(reader),"reader must be ReadableByteStreamByobReader"),"closed"===stream._state){if(0!==bytesWritten)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");RespondToByobReaderInClosedState(this,reader,buffer)}else assert$5("readable"===stream._state),RespondToByobReaderInReadableState(this,reader,bytesWritten,buffer)}}]),ReadableByteStreamController}(),ReadableByteStreamReader=function(){function ReadableByteStreamReader(stream){if(_classCallCheck(this,ReadableByteStreamReader),!IsReadableByteStream(stream))throw new TypeError("ReadableByteStreamReader can only be constructed with a ReadableByteStream instance");if(IsReadableByteStreamLocked(stream))throw new TypeError("This stream has already been locked for exclusive reading by another reader");InitializeReadableByteStreamReaderGeneric(this,stream),this._readRequests=[]}return _createClass(ReadableByteStreamReader,[{key:"cancel",value:function(reason){return IsReadableByteStreamReader(this)?"closed"===this._state?Promise.resolve(void 0):"errored"===this._state?Promise.reject(this._storedError):(assert$5(void 0!==this._ownerReadableByteStream,"This reader must be attached to a stream"),CancelReadableByteStream(this._ownerReadableByteStream,reason)):Promise.reject(new TypeError("ReadableByteStreamReader.prototype.cancel can only be used on a ReadableByteStreamReader"))}},{key:"read",value:function(){var _this2=this;if(!IsReadableByteStreamReader(this))return Promise.reject(new TypeError("ReadableByteStreamReader.prototype.read can only be used on a ReadableByteStreamReader"));if("closed"===this._state)return Promise.resolve(CreateIterResultObject(void 0,!0));if("errored"===this._state)return Promise.reject(this._storedError);assert$5(void 0!==this._ownerReadableByteStream,"This reader must be attached to a stream"),assert$5("readable"===this._ownerReadableByteStream._state,"The owner stream must be in readable state");var promise=new Promise(function(resolve,reject){_this2._readRequests.push({resolve:resolve,reject:reject})});return PullFromReadableByteStream(this._ownerReadableByteStream),promise}},{key:"releaseLock",value:function(){if(!IsReadableByteStreamReader(this))throw new TypeError("ReadableByteStreamReader.prototype.releaseLock can only be used on a ReadableByteStreamReader");if(void 0!==this._ownerReadableByteStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");assert$5("readable"===this._ownerReadableByteStream._state),ReleaseReadableByteStreamReaderGeneric(this),CloseReadableByteStreamReaderGeneric(this)}}},{key:"closed",get:function(){return IsReadableByteStreamReader(this)?this._closedPromise:Promise.reject(new TypeError("ReadableByteStreamReader.prototype.closed can only be used on a ReadableByteStreamReader"))}}]),ReadableByteStreamReader}(),ReadableByteStreamByobReader=function(){function ReadableByteStreamByobReader(stream){if(_classCallCheck(this,ReadableByteStreamByobReader),!IsReadableByteStream(stream))throw new TypeError("ReadableByteStreamByobReader can only be constructed with a ReadableByteStream instance");if(IsReadableByteStreamLocked(stream))throw new TypeError("This stream has already been locked for exclusive reading by another reader");InitializeReadableByteStreamReaderGeneric(this,stream),this._readIntoRequests=[]}return _createClass(ReadableByteStreamByobReader,[{key:"cancel",value:function(reason){return IsReadableByteStreamByobReader(this)?"closed"===this._state?Promise.resolve(void 0):"errored"===this._state?Promise.reject(this._storedError):(assert$5(void 0!==this._ownerReadableByteStream,"This stream must be attached to a stream"),CancelReadableByteStream(this._ownerReadableByteStream,reason)):Promise.reject(new TypeError("ReadableByteStreamByobReader.prototype.cancel can only be used on a ReadableByteStreamByobReader"))}},{key:"read",value:function(view){var _this3=this;if(!IsReadableByteStreamByobReader(this))return Promise.reject(new TypeError("ReadableByteStreamByobReader.prototype.read can only be used on a ReadableByteStreamByobReader"));if(void 0===view||!ArrayBuffer.isView(view))return Promise.reject(new TypeError("Valid view must be provided"));var ctor=view.constructor,elementSize=1;if(ctor===Int16Array||ctor===Uint16Array||ctor===Int32Array||ctor===Uint32Array||ctor===Float32Array||ctor===Float64Array||ctor===Int8Array||ctor===Uint8Array||ctor===Uint8ClampedArray)elementSize=ctor.BYTES_PER_ELEMENT;else if(ctor!==DataView)return Promise.reject(new TypeError("view is of an unsupported type"));if(0===view.byteLength)return Promise.reject(new TypeError("view must have non-zero byteLength"));if("errored"===this._state)return assert$5(void 0===this._ownerReadableByteStream,"This reader must be detached"),Promise.reject(this._storedError);if("closed"===this._state&&void 0===this._ownerReadableByteStream)return Promise.resolve(CreateIterResultObject(new ctor(view.buffer,view.byteOffset,0),!0));var promise=new Promise(function(resolve,reject){var req={resolve:resolve,reject:reject,byteOffset:view.byteOffset,byteLength:view.byteLength,ctor:ctor,elementSize:elementSize};_this3._readIntoRequests.push(req)});return PullFromReadableByteStreamInto(this._ownerReadableByteStream,view.buffer,view.byteOffset,view.byteLength,elementSize),promise}},{key:"releaseLock",value:function(){if(!IsReadableByteStreamByobReader(this))throw new TypeError("ReadableByteStreamByobReader.prototype.releaseLock can only be used on a ReadableByteStreamByobReader");if(void 0!==this._ownerReadableByteStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");assert$5("readable"===this._ownerReadableByteStream._state),ReleaseReadableByteStreamReaderGeneric(this),CloseReadableByteStreamReaderGeneric(this)}}},{key:"closed",get:function(){return IsReadableByteStreamByobReader(this)?this._closedPromise:Promise.reject(new TypeError("ReadableByteStreamByobReader.prototype.closed can only be used on a ReadableByteStreamByobReader"))}}]),ReadableByteStreamByobReader}(),interfaces={ReadableByteStream:ReadableByteStream,ReadableStream:ReadableStream,WritableStream:WritableStream,ByteLengthQueuingStrategy:ByteLengthQueuingStrategy,CountQueuingStrategy:CountQueuingStrategy,TransformStream:TransformStream};Object.assign(global,interfaces),exports["default"]=interfaces;