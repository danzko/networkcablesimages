{"version":3,"sources":["demand.js"],"names":["global","demand","self","this","module","isInstanceOf","Module","dependencies","arrayPrototypeSlice","call","arguments","forEach","dependency","index","resolved","resolve","path","handler","pointer","modules","Loader","pledge","Pledge","all","provide","loader","isTypeOf","STRING_STRING","factory","queue","current","Error","setTimeout","defered","log","cached","store","then","apply","reject","length","next","when","configure","aConfig","key","aCache","cache","aDebug","debug","aVersion","version","aTimeout","timeout","aLifetime","lifetime","aBase","base","aPattern","pattern","aProbes","probes","STRING_BOOLEAN","isPositiveInteger","timeoutXhr","Math","min","max","timeoutQueue","Pattern","regexBase","url","isObject","addHandler","aType","aSuffix","aHandler","suffix","modify","assign","id","object","aMessage","type","console","STRING_UNDEFINED","toString","regex","expression","modifier","RegExp","escape","aValue","replace","regexMatchSpecial","removeProtocol","regexMatchProtocol","isAbsolute","aPath","regexIsAbsolute","test","value","isFinite","floor","executor","handle","PLEDGE_RESOLVED","PLEDGE_REJECTED","aState","aParameter","state","PLEDGE_PENDING","listener","rejected","aResolved","aRejected","push","aModule","aStack","message","stack","aUrl","regexPattern","regexUrl","Queue","aParent","xhr","defer","parent","retrieve","add","regexMatchUrl","XHR","XDR","onprogress","ontimeout","onerror","onabort","onload","source","responseText","open","send","readyState","abort","aDefinition","aDependencies","regexMatchLsState","storage","JavascriptHandler","CssHandler","document","Array","prototype","slice","arrayPrototypeConcat","concat","target","getElementsByTagName","resolver","createElement","localStorage","DEMAND_PREFIX","DEMAND_SUFFIX_STATE","DEMAND_SUFFIX_VALUE","XMLHttpRequest","XDomainRequest","regexMatchHandler","regexMatchCssUrl","hasRemainingSpace","defaults","main","settings","href","match","isLoader","matches","process","get","JSON","parse","getItem","expires","Date","getTime","clear","set","spaceBefore","remainingSpace","setItem","stringify","error","removeItem","indexOf","constructor","aResolve","aReject","aPledges","countTotal","countResolved","aPledge","aIndex","race","result","traverse","depth","indention","join","item","remove","aItem","shift","probe","isPending","script","async","text","setAttribute","appendChild","style","sheet","styleSheet","media","cssText","innerHTML","exec"],"mappings":"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","file":"demand.js","sourcesContent":["/**\n * Qoopido demand\n *\n * Promise like module loader (XHR) with localStorage caching\n *\n * Copyright (c) 2015 Dirk Lueth\n *\n * Dual licensed under the MIT and GPL licenses.\n *  - http://www.opensource.org/licenses/mit-license.php\n *  - http://www.gnu.org/copyleft/gpl.html\n *\n * @author Dirk Lueth <info@qoopido.com>\n *\n * @requires XMLHttpRequest, XDomainRequest, JSON.parse, JSON.stringify, Array.forEach\n */\n\n;(function(global) {\n\t'use strict';\n\n\tvar // shortcuts\n\t\t\tdocument              = global.document,\n\t\t\tsetTimeout            = global.setTimeout,\n\t\t\tarrayPrototypeSlice   = Array.prototype.slice,\n\t\t\tarrayPrototypeConcat  = Array.prototype.concat,\n\t\t\ttarget                = document.getElementsByTagName('head')[0],\n\t\t\tresolver              = document.createElement('a'),\n\t\t\tlocalStorage          = global.localStorage,\n\t\t// constants\n\t\t\tDEMAND_PREFIX         = '[demand]',\n\t\t\tDEMAND_SUFFIX_STATE   = '[state]',\n\t\t\tDEMAND_SUFFIX_VALUE   = '[value]',\n\t\t\tSTRING_UNDEFINED      = 'undefined',\n\t\t\tSTRING_STRING         = 'string',\n\t\t\tSTRING_BOOLEAN        = 'boolean',\n\t\t\tPLEDGE_PENDING        = 'pending',\n\t\t\tPLEDGE_RESOLVED       = 'resolved',\n\t\t\tPLEDGE_REJECTED       = 'rejected',\n\t\t\tXHR                   = global.XMLHttpRequest,\n\t\t\tXDR                   = 'XDomainRequest' in global && global.XDomainRequest || XHR,\n\t\t// regular expressions\n\t\t\tregexBase             = /^/,\n\t\t\tregexIsAbsolute       = /^\\//i,\n\t\t\tregexMatchHandler     = /^([-\\w]+\\/[-\\w]+)!/,\n\t\t\tregexMatchSpecial     = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g,\n\t\t\tregexMatchCssUrl      = /url\\(\\s*(?:\"|'|)(?!data:|http:|https:|\\/)(.+?)(?:\"|'|)\\)/g,\n\t\t\tregexMatchProtocol    = /^http(s?):/,\n\t\t\tregexMatchUrl, regexMatchLsState,\n\t\t// flags\n\t\t\thasRemainingSpace     = localStorage && 'remainingSpace' in localStorage,\n\t\t// general storage & objects\n\t\t\tdefaults              = { cache: true, debug: false, version: '1.0.0', lifetime: 0, timeout: 5, base: '/' },\n\t\t\tmain                  = global.demand.main,\n\t\t\tsettings              = global.demand.settings,\n\t\t\tmodules               = {},\n\t\t\tpattern               = {},\n\t\t\tprobes                = {},\n\t\t\thandler               = {},\n\t\t\tqueue, resolve, storage,\n\t\t// handler\n\t\t\tJavascriptHandler, CssHandler,\n\t\t// configuration\n\t\t\tbase, cache, debug, timeoutXhr, timeoutQueue, version, lifetime;\n\n\t// main public methods\n\t\t/**\n\t\t * request modules\n\t\t *\n\t\t * Will take any number of string arguments and return a Pledge.all\n\t\t * that resolves when all dependencies are resolved and rejects when\n\t\t * at least one dependency is rejected. Both, the resolved and\n\t\t * rejected callbacks will get all dependencies resolved or rejected\n\t\t * as arguments.\n\t\t *\n\t\t * If the scope of the call is of type \"Module\" relative paths are\n\t\t * resolved in relation to the parent module.\n\t\t */\n\t\t\tfunction demand() {\n\t\t\t\tvar // make sure we have a context\n\t\t\t\t\tself         = this || {},\n\n\t\t\t\t\t// check whether the context is a \"Module\" or not\n\t\t\t\t\tmodule       = isInstanceOf(self, Module) ? self : null,\n\n\t\t\t\t\t// convert array like \"arguments\" to array\n\t\t\t\t\tdependencies = arrayPrototypeSlice.call(arguments);\n\n\t\t\t\t// loop over dependencies\n\t\t\t\tdependencies.forEach(\n\t\t\t\t\tfunction(dependency, index) {\n\t\t\t\t\t\tvar // resolve path\n\t\t\t\t\t\t\tresolved = resolve.path(dependency, module),\n\n\t\t\t\t\t\t\t// shortcut to handler type\n\t\t\t\t\t\t\thandler  = resolved.handler,\n\n\t\t\t\t\t\t\t// shortcut to path\n\t\t\t\t\t\t\tpath     = resolved.path,\n\n\t\t\t\t\t\t\t// shortcut to the registry of this particular handler\n\t\t\t\t\t\t\tpointer  = modules[handler] || (modules[handler] = {});\n\n\t\t\t\t\t\t// overwrite array item with either an existing Pledge or generate a new one from a Loader\n\t\t\t\t\t\tthis[index] = pointer[path] || (pointer[path] = (new Loader(dependency, module)).pledge);\n\t\t\t\t\t},\n\t\t\t\t\tdependencies);\n\n\t\t\t\t// return a Pledge.all to attach resolved and rejected callbacks to\n\t\t\t\treturn Pledge.all(dependencies);\n\t\t\t}\n\n\t\t// provide\n\t\t\t/**\n\t\t\t * provide modules\n\t\t\t *\n\t\t\t * Will either take two arguments, a \"path\" as a string first\n\t\t\t * and a \"definition\" function second or only a \"definition\"\n\t\t\t * function in case of an anonymous provide from a loaded module.\n\t\t\t *\n\t\t\t * In case of an anonymous provide it will be matched against\n\t\t\t * the queue to find the loader being resolved by this provide.\n\t\t\t * In case there is no loader in queue an error is thrown.\n\t\t\t *\n\t\t\t * When provide detects a duplicate a warning will be logged to\n\t\t\t * console in case the \"debug\" configuration option is set to true.\n\t\t\t */\n\t\t\tfunction provide() {\n\t\t\t\tvar// detect if argument[0] is a path, or a definition\n\t\t\t\t\tpath         = (isTypeOf(arguments[0], STRING_STRING) && arguments[0]) || null,\n\n\t\t\t\t\t// assign factory accordingly\n\t\t\t\t\tfactory      = !path ? arguments[0] : arguments[1],\n\n\t\t\t\t\t// variable initialization\n\t\t\t\t\tloader, dependencies;\n\n\t\t\t\t// in case of an anynomous provide check for a loader in queue\n\t\t\t\tif(!path && queue.current) {\n\t\t\t\t\tloader = queue.current;\n\t\t\t\t\tpath   = loader.handler + '!' + loader.path;\n\t\t\t\t}\n\n\t\t\t\tif(path) {\n\t\t\t\t\t// delay further execution to be able to set dependencies via \"when\" function returned\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tvar // resolve path\n\t\t\t\t\t\t\tresolved = resolve.path(path),\n\n\t\t\t\t\t\t\t// shortcut to the registry of this particular handler\n\t\t\t\t\t\t\tpointer  = modules[resolved.handler],\n\n\t\t\t\t\t\t\t// variable initialization\n\t\t\t\t\t\t\tmodule, pledge, defered;\n\n\t\t\t\t\t\tif(!loader && pointer[resolved.path]) {\n\t\t\t\t\t\t\t// duplicate non anonymous define\n\t\t\t\t\t\t\tlog('duplicate found for module ' + resolved.path);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// create a new Module\n\t\t\t\t\t\t\tmodule = new Module(path, factory, dependencies || []);\n\n\t\t\t\t\t\t\t// shortcut to the new module's pledge\n\t\t\t\t\t\t\tpledge = modules[module.handler][module.path] = module.pledge;\n\n\t\t\t\t\t\t\tif(loader) {\n\t\t\t\t\t\t\t\t// store in cache if it was loaded from server\n\t\t\t\t\t\t\t\t!loader.cached && loader.store();\n\n\t\t\t\t\t\t\t\t// shortcut to the loaders Pledge.defer\n\t\t\t\t\t\t\t\tdefered = loader.defered;\n\n\t\t\t\t\t\t\t\t// resolve/reject the loader when module is resolved/rejected\n\t\t\t\t\t\t\t\tpledge.then(\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\tdefered.resolve.apply(null, arguments);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\tdefered.reject(new Error('unable to resolve module', path, arguments));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t// continue to next queued loader if there is one\n\t\t\t\t\t\t\t\tqueue.length > 0 && queue.next();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// no loader was found\n\t\t\t\t\tthrow new Error('unspecified anonymous provide');\n\t\t\t\t}\n\n\t\t\t\t// return a when function to be able to set the provide's dependencies\n\t\t\t\treturn { when: function() { dependencies = arrayPrototypeSlice.call(arguments); } };\n\t\t\t}\n\n\t// additional static methods\n\t\t// configure\n\t\t\t/**\n\t\t\t * alter configuration\n\t\t\t *\n\t\t\t * @param {object} aConfig\n\t\t\t */\n\t\t\tfunction configure(aConfig) {\n\t\t\t\tvar // shortcuts to possible configuration options\n\t\t\t\t\taCache    = aConfig.cache,\n\t\t\t\t\taDebug    = aConfig.debug,\n\t\t\t\t\taVersion  = aConfig.version,\n\t\t\t\t\taTimeout  = aConfig.timeout,\n\t\t\t\t\taLifetime = aConfig.lifetime,\n\t\t\t\t\taBase     = aConfig.base,\n\t\t\t\t\taPattern  = aConfig.pattern,\n\t\t\t\t\taProbes   = aConfig.probes,\n\n\t\t\t\t\t// variable initialization\n\t\t\t\t\tkey;\n\t\t\t\t\n\t\t\t\t// set cache config or leave unchanged\n\t\t\t\tcache   = isTypeOf(aCache, STRING_BOOLEAN)  ? aCache   : cache;\n\t\t\t\t\n\t\t\t\t// set debug config or leave unchanged\n\t\t\t\tdebug   = isTypeOf(aDebug, STRING_BOOLEAN)  ? aDebug   : debug;\n\t\t\t\t\n\t\t\t\t// set version config or leave unchanged\n\t\t\t\tversion = isTypeOf(aVersion, STRING_STRING) ? aVersion : version;\n\n\t\t\t\t// process timeout or leave unchanged\n\t\t\t\tif(isPositiveInteger(aTimeout)) {\n\t\t\t\t\t// limit XHR timeout to 2-10 s and convert to ms\n\t\t\t\t\ttimeoutXhr   = Math.min(Math.max(aTimeout, 2), 10) * 1000;\n\t\t\t\t\t\n\t\t\t\t\t// limit queue timeout to 1000-5000 ms from a base of XHR timeout / 5\n\t\t\t\t\ttimeoutQueue = Math.min(Math.max(timeoutXhr / 5, 1000), 5000);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// process cache lifetime\n\t\t\t\tif(isPositiveInteger(aLifetime)) {\n\t\t\t\t\t// convert s to ms\n\t\t\t\t\tlifetime = aLifetime * 1000;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// process base\n\t\t\t\tif(isTypeOf(aBase, STRING_STRING)) {\n\t\t\t\t\tbase = pattern.base = new Pattern(regexBase, resolve.url(aBase));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// process pattern\n\t\t\t\tif(isObject(aPattern)) {\n\t\t\t\t\tfor(key in aPattern) {\n\t\t\t\t\t\t// 'base' is a reserved key\n\t\t\t\t\t\tkey !== 'base' && (pattern[key] = new Pattern(key, aPattern[key]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// process probes\n\t\t\t\tif(isObject(aProbes)) {\n\t\t\t\t\tfor(key in aProbes) {\n\t\t\t\t\t\tprobes[key] = aProbes[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// requires truthy return value\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t// addHandler\n\t\t\t/**\n\t\t\t * add handler for mimetype\n\t\t\t *\n\t\t\t * @param {string} aType\n\t\t\t * @param {string} aSuffix\n\t\t\t * @param {object} aHandler\n\t\t\t */\n\t\t\tfunction addHandler(aType, aSuffix, aHandler) {\n\t\t\t\t// prohibit overriding of existing handlers\n\t\t\t\tif(!handler[aType]) {\n\t\t\t\t\t// store handler\n\t\t\t\t\thandler[aType] = { suffix: aSuffix, resolve: aHandler.resolve, modify: aHandler.modify };\n\n\t\t\t\t\t// initialize registry for handler\n\t\t\t\t\tmodules[aType] = {};\n\t\t\t\t}\n\t\t\t}\n\n\t// helper\n\t\t// assign\n\t\t\t/**\n\t\t\t * Shortcut to globally provide internal functions\n\t\t\t *\n\t\t\t * @param {string} id\n\t\t\t * @param {mixed} object\n\t\t\t */\n\t\t\tfunction assign(id, object) {\n\t\t\t\tprovide(id, function() { return object; });\n\t\t\t}\n\n\t\t// log\n\t\t\t/**\n\t\t\t * log a message to the console\n\t\t\t *\n\t\t\t * @param {string} aMessage\n\t\t\t */\n\t\t\tfunction log(aMessage) {\n\t\t\t\t// determine message type\n\t\t\t\tvar type = (isInstanceOf(aMessage, Error)) ? 'error' : 'warn';\n\n\t\t\t\t// check if console is available\n\t\t\t\tif(!isTypeOf(console, STRING_UNDEFINED) && (debug || type !== 'warn')) {\n\t\t\t\t\t// errors will always be output to console, warnings only when \"debug\" is enabled\n\t\t\t\t\tconsole[type](aMessage.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t// regex\n\t\t\t/**\n\t\t\t * shortcut for generating new RegExp\n\t\t\t *\n\t\t\t * @param {string} expression\n\t\t\t * @param {string} modifier\n\t\t\t *\n\t\t\t * @returns {RegExp}\n\t\t\t */\n\t\t\tfunction regex(expression, modifier) {\n\t\t\t\treturn new RegExp(expression, modifier);\n\t\t\t}\n\n\t\t// escape\n\t\t\t/**\n\t\t\t * escape a string to be used in a RegExp\n\t\t\t *\n\t\t\t * @param {string} aValue\n\t\t\t *\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tfunction escape(aValue) {\n\t\t\t\treturn aValue.replace(regexMatchSpecial, '\\\\$&');\n\t\t\t}\n\n\t\t// removeProtocol\n\t\t\t/**\n\t\t\t * remove protocol from any given URL\n\t\t\t *\n\t\t\t * @param {string} url\n\t\t\t *\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tfunction removeProtocol(url) {\n\t\t\t\treturn url.replace(regexMatchProtocol, '');\n\t\t\t}\n\n\t\t// isAbsolute\n\t\t\t/**\n\t\t\t * check whether a given path is absolute\n\t\t\t *\n\t\t\t * @param {string} aPath\n\t\t\t *\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tfunction isAbsolute(aPath) {\n\t\t\t\treturn regexIsAbsolute.test(aPath);\n\t\t\t}\n\n\t\t// isInstanceOf\n\t\t\t/**\n\t\t\t * check whether a passed object is an instance of a certain type\n\t\t\t *\n\t\t\t * @param {mixed} object\n\t\t\t *\n\t\t\t * @param {function} module\n\t\t\t *\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tfunction isInstanceOf(object, module) {\n\t\t\t\treturn object instanceof module;\n\t\t\t}\n\t\t\t\n\t\t// isTypeOf\n\t\t\t/**\n\t\t\t * check wheter a given object is of a certain type\n\t\t\t *\n\t\t\t * @param {mixed} object\n\t\t\t *\n\t\t\t * @param {string} type\n\t\t\t *\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tfunction isTypeOf(object, type) {\n\t\t\t\treturn typeof object === type;\n\t\t\t}\n\n\t\t// isObject\n\t\t\t/**\n\t\t\t * check whether a given object is an object\n\t\t\t *\n\t\t\t * @param {mixed} object\n\t\t\t *\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tfunction isObject(object) {\n\t\t\t\treturn object && isTypeOf(object, 'object');\n\t\t\t}\n\n\t\t// isPositiveInteger\n\t\t\t/**\n\t\t\t * check whether a given value is a positive integer\n\t\t\t *\n\t\t\t * @param {mixed} value\n\t\t\t *\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tfunction isPositiveInteger(value) {\n\t\t\t\treturn isTypeOf(value, 'number') && isFinite(value) && Math.floor(value) === value && value >= 0;\n\t\t\t}\n\n\t\t// resolve\n\t\t\tresolve = {\n\t\t\t\t/**\n\t\t\t\t * resolve any given url\n\t\t\t\t *\n\t\t\t\t * @param {string} aUrl\n\t\t\t\t *\n\t\t\t\t * @returns {string}\n\t\t\t\t */\n\t\t\t\turl: function(aUrl) {\n\t\t\t\t\tresolver.href = aUrl;\n\n\t\t\t\t\treturn resolver.href;\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * resolve any given path\n\t\t\t\t *\n\t\t\t\t * if context is either \"Loader\" or \"Module\" nothing will\n\t\t\t\t * be returned but instead \"handler\" and \"path\" will be\n\t\t\t\t * set directly on context. In case of \"Loader\" an\n\t\t\t\t * additional property \"url\" will be set as well.\n\t\t\t\t *\n\t\t\t\t * @param {string} aPath\n\t\t\t\t * @param {object} aParent\n\t\t\t\t *\n\t\t\t\t * @returns {void|{handler: string, path: string}}\n\t\t\t\t */\n\t\t\t\tpath: function(aPath, aParent) {\n\t\t\t\t\tvar // shortcut\n\t\t\t\t\t\tself     = this,\n\t\t\t\t\t\t\n\t\t\t\t\t\t// pointer to specific handler set, or default handler\n\t\t\t\t\t\tpointer  = aPath.match(regexMatchHandler) || 'application/javascript',\n\t\t\t\t\t\t\n\t\t\t\t\t\t// flag if this is an instance of \"Loader\"\n\t\t\t\t\t\tisLoader = isInstanceOf(self, Loader),\n\t\t\t\t\t\t\n\t\t\t\t\t\t// variable initialization\n\t\t\t\t\t\tkey, match;\n\t\t\t\t\t\t\n\t\t\t\t\t// process a specific handler\n\t\t\t\t\tif(!isTypeOf(pointer, STRING_STRING)) {\n\t\t\t\t\t\t// remove handler prefix from path\n\t\t\t\t\t\taPath   = aPath.replace(regex('^' + escape(pointer[0])), '');\n\t\t\t\t\t\t\n\t\t\t\t\t\t// set pointer to the actual handler name\n\t\t\t\t\t\tpointer = pointer[1];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!isAbsolute(aPath)) {\n\t\t\t\t\t\t// make any relative path absolute considering a possible parent module\n\t\t\t\t\t\taPath = '/' + resolve.url(((aParent && aParent.path && resolve.url(aParent.path + '/../')) || '/') + aPath).replace(regexMatchUrl, '');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// match the resulting path to all pattern\n\t\t\t\t\tfor(key in pattern) {\n\t\t\t\t\t\tpattern[key].matches(aPath) && (match = pattern[key]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// set handler and path on context, if this is a \"Module\" or \"Loader\"\n\t\t\t\t\tif(isLoader || isInstanceOf(self, Module)) {\n\t\t\t\t\t\tself.handler = pointer;\n\t\t\t\t\t\tself.path    = aPath;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if this is a \"Loader\" set \"url\" additionally\n\t\t\t\t\t\tisLoader && (self.url = removeProtocol(resolve.url(match.process(aPath))));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// return object containing handler and path\n\t\t\t\t\t\treturn { handler: pointer, path: aPath };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t// storage\n\t\t\tstorage = {\n\t\t\t\t/**\n\t\t\t\t * retrieve cache for a given path and URL\n\t\t\t\t *\n\t\t\t\t * @param {string} aPath\n\t\t\t\t * @param {string} aUrl\n\t\t\t\t *\n\t\t\t\t * @returns {void|string}\n\t\t\t\t */\n\t\t\t\tget: function(aPath, aUrl) {\n\t\t\t\t\tvar // variable initialization\n\t\t\t\t\t\tid, state;\n\n\t\t\t\t\t// continue only if localStorage is supported and cache is enabled\n\t\t\t\t\tif(localStorage && cache) {\n\t\t\t\t\t\t// build paths localStorage prefix id\n\t\t\t\t\t\tid    = DEMAND_PREFIX + '[' + aPath + ']';\n\n\t\t\t\t\t\t// fetch state\n\t\t\t\t\t\tstate = JSON.parse(localStorage.getItem(id + DEMAND_SUFFIX_STATE));\n\n\t\t\t\t\t\tif(state && state.version === version && state.url === aUrl && (state.expires === 0 || state.expires > new Date().getTime())) {\n\t\t\t\t\t\t\t// return stored value if state is set, states version matches global version, states url matches given url and cache is not expired\n\t\t\t\t\t\t\treturn localStorage.getItem(id + DEMAND_SUFFIX_VALUE);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// clear cache otherwise\n\t\t\t\t\t\t\tstorage.clear(aPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * store cache for a given path, value and url\n\t\t\t\t *\n\t\t\t\t * @param {string} aPath\n\t\t\t\t * @param {string} aValue\n\t\t\t\t * @param {string} aUrl\n\t\t\t\t */\n\t\t\t\tset: function(aPath, aValue, aUrl) {\n\t\t\t\t\tvar // variable initialization\n\t\t\t\t\t\tid, spaceBefore;\n\n\t\t\t\t\t// continue only if localStorage is supported and cache is enabled\n\t\t\t\t\tif(localStorage && cache) {\n\t\t\t\t\t\t// build paths localStorage prefix id\n\t\t\t\t\t\tid = DEMAND_PREFIX + '[' + aPath + ']';\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// determine remainingSpace if supported, set to \"null\" otherwise\n\t\t\t\t\t\t\tspaceBefore = hasRemainingSpace ? localStorage.remainingSpace : null;\n\n\t\t\t\t\t\t\t// set path state and value items\n\t\t\t\t\t\t\tlocalStorage.setItem(id + DEMAND_SUFFIX_VALUE, aValue);\n\t\t\t\t\t\t\tlocalStorage.setItem(id + DEMAND_SUFFIX_STATE, JSON.stringify({ version: version, expires: lifetime > 0 ? new Date().getTime() + lifetime : 0, url: aUrl }));\n\n\t\t\t\t\t\t\tif(spaceBefore !== null && localStorage.remainingSpace === spaceBefore) {\n\t\t\t\t\t\t\t\t// throw error if remainingSpace is supported and is equal to what is was before\n\t\t\t\t\t\t\t\tthrow 'QuotaExceedError';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\t\t// log warning otherwise\n\t\t\t\t\t\t\tlog('unable to cache module ' + aPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * clear either a given path, all cached resources or only expired resources\n\t\t\t\t *\n\t\t\t\t * @param {string|boolean|void} aPath\n\t\t\t\t */\n\t\t\t\tclear: function(aPath) {\n\t\t\t\t\tvar // variable initialization\n\t\t\t\t\t\tid, key, match, state;\n\n\t\t\t\t\t// continue only if localStorage is supported and cache is enabled\n\t\t\t\t\tif(localStorage && cache) {\n\t\t\t\t\t\t// handle possible types of aPath\n\t\t\t\t\t\tswitch(typeof aPath) {\n\t\t\t\t\t\t\t// handle if aPath is of type \"string\"\n\t\t\t\t\t\t\t// => clear specific\n\t\t\t\t\t\t\tcase STRING_STRING:\n\t\t\t\t\t\t\t\t// build paths localStorage prefix id\n\t\t\t\t\t\t\t\tid = DEMAND_PREFIX + '[' + aPath + ']';\n\n\t\t\t\t\t\t\t\t// remove localStorage state and value items\n\t\t\t\t\t\t\t\tlocalStorage.removeItem(id + DEMAND_SUFFIX_STATE);\n\t\t\t\t\t\t\t\tlocalStorage.removeItem(id + DEMAND_SUFFIX_VALUE);\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t// handle if aPath is of type \"boolean\"\n\t\t\t\t\t\t\t// => clear expired\n\t\t\t\t\t\t\tcase STRING_BOOLEAN:\n\t\t\t\t\t\t\t\t// continue only if aPath is truthy\n\t\t\t\t\t\t\t\tif(aPath) {\n\t\t\t\t\t\t\t\t\t// loop over all localStorage keys\n\t\t\t\t\t\t\t\t\tfor(key in localStorage) {\n\t\t\t\t\t\t\t\t\t\t// match current key against regex to make sure it is demand-related\n\t\t\t\t\t\t\t\t\t\tmatch = key.match(regexMatchLsState);\n\n\t\t\t\t\t\t\t\t\t\tif(match) {\n\t\t\t\t\t\t\t\t\t\t\t// get state if key was matched\n\t\t\t\t\t\t\t\t\t\t\tstate = JSON.parse(localStorage.getItem(DEMAND_PREFIX + '[' + match[1] + ']' + DEMAND_SUFFIX_STATE));\n\n\t\t\t\t\t\t\t\t\t\t\tif(state && state.expires > 0 && state.expires <= new Date().getTime()) {\n\t\t\t\t\t\t\t\t\t\t\t\t// clear storage for match if expired\n\t\t\t\t\t\t\t\t\t\t\t\tstorage.clear(match[1]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t// handle if aPath is of type \"undefined\"\n\t\t\t\t\t\t\t// => clear all\n\t\t\t\t\t\t\tcase STRING_UNDEFINED:\n\t\t\t\t\t\t\t\t// loop over all localStorage keys\n\t\t\t\t\t\t\t\tfor(key in localStorage) {\n\t\t\t\t\t\t\t\t\t// clear storage if key is demand-related\n\t\t\t\t\t\t\t\t\tkey.indexOf(DEMAND_PREFIX) === 0 && (localStorage.removeItem(key));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t// modules\n\t\t// Pledge\n\t\t\t/**\n\t\t\t * provides promise like behaviour\n\t\t\t *\n\t\t\t * unlike native Promises and polyfills a Pledge\n\t\t\t * can be resolved and rejected with multiple values\n\t\t\t * which will all get applied\n\t\t\t *\n\t\t\t * @param {function} executor\n\t\t\t *\n\t\t\t * @constructor\n\t\t\t */\n\t\t\tfunction Pledge(executor) {\n\t\t\t\tvar // shortcut to context\n\t\t\t\t\tself     = this,\n\n\t\t\t\t\t// object storing resolve and reject listeners as separate arrays\n\t\t\t\t\tlistener = { resolved: [], rejected: [] };\n\n\t\t\t\tfunction resolve() {\n\t\t\t\t\thandle(PLEDGE_RESOLVED, arguments);\n\t\t\t\t}\n\n\t\t\t\tfunction reject() {\n\t\t\t\t\thandle(PLEDGE_REJECTED, arguments);\n\t\t\t\t}\n\n\t\t\t\tfunction handle(aState, aParameter) {\n\t\t\t\t\t// continue only if Pledge is still \"pending\"\n\t\t\t\t\tif(self.state === PLEDGE_PENDING) {\n\t\t\t\t\t\t// set properties\n\t\t\t\t\t\tself.state = aState;\n\t\t\t\t\t\tself.value = aParameter;\n\n\t\t\t\t\t\t// handle listener\n\t\t\t\t\t\tlistener[aState].forEach(function(aHandler) {\n\t\t\t\t\t\t\t// apply values to listener\n\t\t\t\t\t\t\taHandler.apply(null, self.value);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tself.then = function(aResolved, aRejected) {\n\t\t\t\t\tif(self.state === PLEDGE_PENDING) {\n\t\t\t\t\t\t// add listeners to internal storage when Pledge is \"pending\"\n\t\t\t\t\t\taResolved && listener[PLEDGE_RESOLVED].push(aResolved);\n\t\t\t\t\t\taRejected && listener[PLEDGE_REJECTED].push(aRejected);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// directly call listeners when Pledge was already \"resolved\" or \"rejected\"\n\t\t\t\t\t\tswitch(self.state) {\n\t\t\t\t\t\t\tcase PLEDGE_RESOLVED:\n\t\t\t\t\t\t\t\t// apply values to listener\n\t\t\t\t\t\t\t\taResolved.apply(null, self.value);\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase PLEDGE_REJECTED:\n\t\t\t\t\t\t\t\t// apply values to listener\n\t\t\t\t\t\t\t\taRejected.apply(null, self.value);\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// run executor\n\t\t\t\texecutor(resolve, reject);\n\t\t\t}\n\n\t\t\tPledge.prototype = {\n\t\t\t\tconstructor: Pledge,\n\t\t\t\tstate:       PLEDGE_PENDING,\n\t\t\t\tvalue:       null,\n\t\t\t\tlistener:    null,\n\t\t\t\tthen:        null\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * provides Promise.defer like behaviour\n\t\t\t *\n\t\t\t * @returns {object}\n\t\t\t */\n\t\t\tPledge.defer = function() {\n\t\t\t\tvar self = {};\n\n\t\t\t\t// create Pledge\n\t\t\t\tself.pledge = new Pledge(function(aResolve, aReject) {\n\t\t\t\t\t// link properties \"resolve\" and \"reject\" to the Pledge\n\t\t\t\t\tself.resolve = aResolve;\n\t\t\t\t\tself.reject  = aReject;\n\t\t\t\t});\n\n\t\t\t\treturn self;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * provides Promise.all like behaviour\n\t\t\t *\n\t\t\t * unlike native Promise.all Pledge.all will not reject on the\n\t\t\t * first rejected Pledge but when all Pledges ere either\n\t\t\t * resolved or rejected. Rejection callbacks will get passed\n\t\t\t * all rejected reasons, not only the first one.\n\t\t\t *\n\t\t\t * @param {array} aPledges\n\t\t\t *\n\t\t\t * @returns {Pledge}\n\t\t\t */\n\t\t\tPledge.all = function(aPledges) {\n\t\t\t\tvar // create internal defered Pledge\n\t\t\t\t\tdefered       = Pledge.defer(),\n\n\t\t\t\t\t// shortcut to pledge\n\t\t\t\t\tpledge        = defered.pledge,\n\n\t\t\t\t\t// storage for values of resolved pledges\n\t\t\t\t\tresolved      = [],\n\n\t\t\t\t\t// storage for values of rejected pledges\n\t\t\t\t\trejected      = [],\n\n\t\t\t\t\t// total count of input pledges\n\t\t\t\t\tcountTotal    = aPledges.length,\n\n\t\t\t\t\t// count of resolved pledges\n\t\t\t\t\tcountResolved = 0;\n\n\t\t\t\t// loop over passed pledges\n\t\t\t\taPledges.forEach(function(aPledge, aIndex) {\n\t\t\t\t\t// register to pledges resolved and rejected states\n\t\t\t\t\taPledge.then(\n\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t// add all resolved values to storage\n\t\t\t\t\t\t\tresolved[aIndex] = arrayPrototypeSlice.call(arguments);\n\n\t\t\t\t\t\t\t// increase counter\n\t\t\t\t\t\t\tcountResolved++;\n\n\t\t\t\t\t\t\t// resolve internal defered Pledge when all pledges were resolved\n\t\t\t\t\t\t\tcountResolved === countTotal && defered.resolve.apply(null, arrayPrototypeConcat.apply([], resolved));\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t// add all rejected values to storage\n\t\t\t\t\t\t\trejected.push(arrayPrototypeSlice.call(arguments));\n\n\t\t\t\t\t\t\t// check if all pledges got resolved/rejected and reject internal defered\n\t\t\t\t\t\t\trejected.length + countResolved === countTotal && defered.reject.apply(null, arrayPrototypeConcat.apply([], rejected));\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\treturn pledge;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * provides Promise.race like behaviour\n\t\t\t *\n\t\t\t * @param {array} aPledges\n\t\t\t *\n\t\t\t * @returns {Pledge}\n\t\t\t */\n\t\t\tPledge.race = function(aPledges) {\n\t\t\t\tvar // create internal defered Pledge\n\t\t\t\t\tdefered = Pledge.defer();\n\n\t\t\t\t// loop over passed pledges\n\t\t\t\taPledges.forEach(function(aPledge) {\n\t\t\t\t\t// map internal resolve/reject to pledges\n\t\t\t\t\taPledge.then(\n\t\t\t\t\t\tdefered.resolve,\n\t\t\t\t\t\tdefered.reject\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\treturn defered.pledge;\n\t\t\t};\n\n\t\t// Error\n\t\t\t/**\n\t\t\t * internal error class\n\t\t\t *\n\t\t\t * @param {string} aMessage\n\t\t\t * @param {string} aModule\n\t\t\t * @param {array} aStack\n\t\t\t *\n\t\t\t * @constructor\n\t\t\t */\n\t\t\tfunction Error(aMessage, aModule, aStack) {\n\t\t\t\tvar // shortcut to context\n\t\t\t\t\tself = this;\n\n\t\t\t\t// set properties\n\t\t\t\tself.message = aMessage;\n\t\t\t\tself.module  = aModule;\n\n\t\t\t\taStack && (self.stack = arrayPrototypeSlice.call(aStack));\n\t\t\t}\n\n\t\t\tError.prototype = {\n\t\t\t\tmessage: null,\n\t\t\t\tmodule:  null,\n\t\t\t\tstack:   null,\n\t\t\t\t/**\n\t\t\t\t * handles output to console\n\t\t\t\t *\n\t\t\t\t * @returns {string}\n\t\t\t\t */\n\t\t\t\ttoString: function() {\n\t\t\t\t\tvar // shortcut to context\n\t\t\t\t\t\tself   = this,\n\n\t\t\t\t\t\t// initialize result\n\t\t\t\t\t\tresult = DEMAND_PREFIX + ' ' + self.message + ' ' + self.module;\n\n\t\t\t\t\t// process potential stack\n\t\t\t\t\tif(self.stack) {\n\t\t\t\t\t\tresult = Error.traverse(self.stack, result, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * handles recursion of stack on output to console\n\t\t\t *\n\t\t\t * @param {array} stack\n\t\t\t * @param {string} value\n\t\t\t * @param {integer} depth\n\t\t\t *\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tError.traverse = function(stack, value, depth) {\n\t\t\t\tvar // prepare indention\n\t\t\t\t\tindention = new Array(depth + 1).join(' ');\n\n\t\t\t\t// loop over each stackitem\n\t\t\t\tstack.forEach(function(item) {\n\t\t\t\t\tvalue += '\\n' + indention + '> ' + item.message + ' ' + item.module;\n\n\t\t\t\t\t// handle possible nested stacks\n\t\t\t\t\tif(item.stack) {\n\t\t\t\t\t\tvalue = Error.traverse(item.stack, value, depth + 1);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn value;\n\t\t\t};\n\n\t\t// Pattern\n\t\t\t/**\n\t\t\t * abstraction for pattern matching of paths\n\t\t\t *\n\t\t\t * @param {RegExp|string} aPattern\n\t\t\t * @param {strin} aUrl\n\t\t\t *\n\t\t\t * @constructor\n\t\t\t */\n\t\t\tfunction Pattern(aPattern, aUrl) {\n\t\t\t\tvar self = this;\n\n\t\t\t\tself.url          = resolve.url(aUrl);\n\t\t\t\tself.regexPattern = (isInstanceOf(aPattern, RegExp)) ? aPattern : regex('^' + escape(aPattern));\n\t\t\t\tself.regexUrl     = regex('^' + escape(aUrl));\n\t\t\t}\n\n\t\t\tPattern.prototype = {\n\t\t\t\turl:          null,\n\t\t\t\tregexPattern: null,\n\t\t\t\tregexUrl:     null,\n\t\t\t\tmatches: function(aPath) {\n\t\t\t\t\treturn this.regexPattern.test(aPath);\n\t\t\t\t},\n\t\t\t\tremove: function(aUrl) {\n\t\t\t\t\treturn aUrl.replace(this.regexUrl, '');\n\t\t\t\t},\n\t\t\t\tprocess: function(aPath) {\n\t\t\t\t\tvar self = this;\n\n\t\t\t\t\treturn aPath.replace(self.regexPattern, self.url);\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Queue\n\t\t\t/**\n\t\t\t * Queue handling for providing anonymous loaded modules\n\t\t\t *\n\t\t\t * @constructor\n\t\t\t */\n\t\t\tfunction Queue() {\n\t\t\t\tvar self = this;\n\n\t\t\t\tself.current = null;\n\t\t\t\tself.queue   = [];\n\t\t\t}\n\n\t\t\tQueue.prototype = {\n\t\t\t\tcurrent: null,\n\t\t\t\tqueue:   null,\n\t\t\t\tlength:  0,\n\t\t\t\tadd: function(aItem) {\n\t\t\t\t\tvar self  = this,\n\t\t\t\t\t\tqueue = self.queue;\n\n\t\t\t\t\tqueue.push(aItem);\n\n\t\t\t\t\tself.length++;\n\n\t\t\t\t\tqueue.length === 1 && self.next();\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\tvar self    = this,\n\t\t\t\t\t\tcurrent = self.current,\n\t\t\t\t\t\tqueue   = self.queue,\n\t\t\t\t\t\tdefered, path, pointer;\n\n\t\t\t\t\tif(current) {\n\t\t\t\t\t\tself.current = null;\n\n\t\t\t\t\t\tqueue.shift();\n\t\t\t\t\t\tself.length--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(queue.length) {\n\t\t\t\t\t\tcurrent = self.current = self.queue[0];\n\t\t\t\t\t\tdefered = current.defered;\n\t\t\t\t\t\tpath    = current.path;\n\t\t\t\t\t\tpointer = handler[current.handler];\n\n\t\t\t\t\t\t!current.cached && pointer.modify && (current.source = pointer.modify(current.url, current.source));\n\n\t\t\t\t\t\tpointer.resolve(path, current.source);\n\n\t\t\t\t\t\tif(probes[path]) {\n\t\t\t\t\t\t\tcurrent.probe();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tdefered.reject(new Error('timeout resolving module', path));\n\t\t\t\t\t\t}, timeoutQueue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Loader\n\t\t\t/**\n\t\t\t * module loader\n\t\t\t *\n\t\t\t * @param {string} aPath\n\t\t\t * @param {object} aParent\n\t\t\t *\n\t\t\t * @constructor\n\t\t\t */\n\t\t\tfunction Loader(aPath, aParent) {\n\t\t\t\tvar self    = this,\n\t\t\t\t\tdefered = Pledge.defer(),\n\t\t\t\t\txhr, pointer;\n\n\t\t\t\tresolve.path.call(self, aPath, aParent);\n\n\t\t\t\tself.defered = defered;\n\t\t\t\tself.pledge  = defered.pledge;\n\t\t\t\tpointer      = handler[self.handler];\n\n\t\t\t\tif(!parent) {\n\t\t\t\t\tself.pledge.then(null, log);\n\t\t\t\t}\n\n\t\t\t\tif(pointer) {\n\t\t\t\t\tself.retrieve();\n\n\t\t\t\t\tif(self.cached) {\n\t\t\t\t\t\tqueue.add(self);\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr            = regexMatchUrl.test(self.url) ? new XHR() : new XDR();\n\t\t\t\t\t\txhr.onprogress = function() {};\n\t\t\t\t\t\txhr.ontimeout  = xhr.onerror = xhr.onabort = function() { defered.reject(new Error('unable to load module', self.path)); };\n\t\t\t\t\t\txhr.onload     = function() { self.source = xhr.responseText; queue.add(self);};\n\n\t\t\t\t\t\txhr.open('GET', self.url + pointer.suffix, true);\n\t\t\t\t\t\txhr.send();\n\n\t\t\t\t\t\tsetTimeout(function() { if(xhr.readyState < 4) { xhr.abort(); } }, timeoutXhr);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdefered.reject(new Error('no handler \"' + self.handler + '\" for', self.path));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLoader.prototype = {\n\t\t\t\thandler: null,\n\t\t\t\tpath:    null,\n\t\t\t\turl:     null,\n\t\t\t\tdefered: null,\n\t\t\t\tpledge:  null,\n\t\t\t\tcached:  false,\n\t\t\t\tsource:  null,\n\t\t\t\t/**\n\t\t\t\t * probe for the loading state of an external module\n\t\t\t\t */\n\t\t\t\tprobe: function() {\n\t\t\t\t\tvar self      = this,\n\t\t\t\t\t\tpath      = self.path,\n\t\t\t\t\t\tisPending = self.pledge.state === PLEDGE_PENDING,\n\t\t\t\t\t\tresult;\n\n\t\t\t\t\tif(isPending) {\n\t\t\t\t\t\tif(result = probes[path]()) {\n\t\t\t\t\t\t\tprovide(function() { return result; });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetTimeout(self.probe, 100);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * store loaders result in localStorage\n\t\t\t\t */\n\t\t\t\tstore: function() {\n\t\t\t\t\tvar self = this;\n\n\t\t\t\t\tstorage.set(self.path, self.source, self.url);\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * retrieve cache for loader\n\t\t\t\t */\n\t\t\t\tretrieve: function() {\n\t\t\t\t\tvar self   = this,\n\t\t\t\t\t\tcache  = storage.get(self.path, self.url),\n\t\t\t\t\t\tcached = self.cached = !!(cache);\n\n\t\t\t\t\tcached && (self.source = cache);\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Module\n\t\t\t/**\n\t\t\t * module constructor\n\t\t\t *\n\t\t\t * @param {string} aPath\n\t\t\t * @param {function} aDefinition\n\t\t\t * @param aDependencies\n\t\t\t *\n\t\t\t * @constructor\n\t\t\t */\n\t\t\tfunction Module(aPath, aDefinition, aDependencies) {\n\t\t\t\tvar self    = this,\n\t\t\t\t\tdefered = Pledge.defer();\n\n\t\t\t\tresolve.path.call(self, aPath);\n\n\t\t\t\t(self.pledge = defered.pledge).then(null, function() {\n\t\t\t\t\tlog(new Error('unable to resolve module', self.path, arguments));\n\t\t\t\t});\n\n\t\t\t\tif(aDependencies.length > 0) {\n\t\t\t\t\tdemand.apply(self, aDependencies)\n\t\t\t\t\t\t.then(\n\t\t\t\t\t\t\tfunction() { defered.resolve(aDefinition.apply(null, arguments)); },\n\t\t\t\t\t\t\tfunction() { defered.reject(new Error('unable to resolve dependencies for', self.path, arguments)); }\n\t\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tdefered.resolve(aDefinition());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tModule.prototype = {\n\t\t\t\thandler: null,\n\t\t\t\tpath:    null,\n\t\t\t\tpledge:  null\n\t\t\t};\n\n\t// handler\n\t\t// JavaScript\n\t\t\tJavascriptHandler = {\n\t\t\t\tresolve: function(aPath, aValue) {\n\t\t\t\t\tvar script = document.createElement('script');\n\n\t\t\t\t\tscript.type  = 'application/javascript';\n\t\t\t\t\tscript.defer = script.async = true;\n\t\t\t\t\tscript.text  = aValue;\n\n\t\t\t\t\tscript.setAttribute('demand-path', aPath);\n\n\t\t\t\t\ttarget.appendChild(script);\n\t\t\t\t}\n\t\t\t};\n\n\t\t// CSS\n\t\t\tCssHandler = {\n\t\t\t\tresolve: function(aPath, aValue) {\n\t\t\t\t\tvar style = document.createElement('style'),\n\t\t\t\t\t\tsheet = style.styleSheet;\n\n\t\t\t\t\tstyle.type  = 'text/css';\n\t\t\t\t\tstyle.media = 'only x';\n\t\t\t\t\t(sheet && (sheet.cssText = aValue)) || (style.innerHTML = aValue);\n\n\t\t\t\t\tstyle.setAttribute('demand-path', aPath);\n\n\t\t\t\t\ttarget.appendChild(style);\n\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tprovide(function() { return style; });\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tmodify: function(aUrl, aValue) {\n\t\t\t\t\tvar base = resolve.url(aUrl + '/..'),\n\t\t\t\t\t\tmatch;\n\n\t\t\t\t\twhile((match = regexMatchCssUrl.exec(aValue))) {\n\t\t\t\t\t\taValue = aValue.replace(match[0], 'url(' + resolve.url(base + match[1]) + ')');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn aValue;\n\t\t\t\t}\n\t\t\t};\n\n\t// initialization\n\t\t// url\n\t\t\tregexMatchUrl     = regex('^' + escape(resolve.url('/')));\n\t\t\tregexMatchLsState = regex('^' + escape(DEMAND_PREFIX + '\\[(.+?)\\]' + DEMAND_SUFFIX_STATE + '$'));\n\n\t\t// create queue\n\t\t\tqueue = new Queue();\n\n\t\t// execute localStorage garbage collection\n\t\t\tstorage.clear(true);\n\n\t\t// add default handler\n\t\t\taddHandler('application/javascript', '.js', JavascriptHandler);\n\t\t\taddHandler('text/css', '.css', CssHandler);\n\n\t\t// configure\n\t\t\tconfigure(defaults) && settings && configure(settings);\n\n\t\t// register in global scope\n\t\t\tdemand.configure  = configure;\n\t\t\tdemand.addHandler = addHandler;\n\t\t\tdemand.clear      = storage.clear;\n\t\t\tglobal.demand     = demand;\n\t\t\tglobal.provide    = provide;\n\n\t\t// register modules\n\t\t\tassign('/demand', demand);\n\t\t\tassign('/provide', provide);\n\t\t\tassign('/pledge', Pledge);\n\t\t\tassign('/validator/isTypeOf', isTypeOf);\n\t\t\tassign('/validator/isInstanceOf', isInstanceOf);\n\t\t\tassign('/validator/isObject', isObject);\n\t\t\tassign('/validator/isPositiveInteger', isPositiveInteger);\n\n\t// load main script\n\t\tif(main) {\n\t\t\tdemand(main);\n\t\t}\n}(this));"],"sourceRoot":"/source/"}