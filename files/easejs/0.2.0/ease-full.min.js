/**
 * Combined, minified redistributable GNU ease.js file.
 * <http://www.gnu.org/software/easejs/>
 * Copyright (C) 2010, 2011, 2012, 2013, 2014 Mike Gerwitz
 * @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&dn=gpl-3.0.txt GPL-v3-or-Later
 */
var easejs={};
(function(y){function z(c){throw Error("Assertion failed: "+(c||"(no failure message)"));}var f={},g=function(c){var a=c.replace(/^\.?\/|[^/]*?\/\.\.\/|\.js$/,""),a=f[a];if(void 0===a)throw"[ease.js] Undefined module: "+c;return a.exports};(function(c){var a={"public":!0,"protected":!0,"private":!0,"static":!0,"abstract":!0,"const":!0,virtual:!0,override:!0,proxy:!0,weak:!0};(c.exports={}).parseKeywords=function(b){var d=b,e=[],h={};if(1!==(e=(""+b).split(/\s+/)).length)for(var d=e.pop(),b=e.length,
c="";b--;){c=e[b];if(!a[c])throw Error("Unexpected keyword for '"+d+"': "+c);h[c]=!0}return{name:d,keywords:h}}})(f.prop_parser={},".");(function(c,a){function b(a,b){for(var d=b.length;d--;)if(null===b[d].match(/^[a-z_][a-z0-9_]*$/i))throw SyntaxError("Member "+a+" contains invalid parameter '"+b[d]+"'");}function d(){var a;return i?function(a,b,d){try{Object.defineProperty(a,b,{value:d,enumerable:!1,writable:!1,configurable:!1})}catch(h){e.definePropertyFallback(!0),a[b]=d}}:function(a,b,d){a[b]=
d}}var e=c.exports={},h=g(a+"/prop_parser").parseKeywords,i;a:{if("function"===typeof Object.defineProperty)try{Object.defineProperty({},"x",{});i=!0;break a}catch(j){}i=!1}e.freeze="function"===typeof Object.freeze?Object.freeze:function(){};e.definePropertyFallback=function(a){if(void 0===a)return!i;i=!a;e.defineSecureProp=d();return e};e.defineSecureProp=d();e.clone=function m(a,b){b=!!b;if(a instanceof Array){if(!b)return a.slice(0);for(var d=[],e=0,h=a.length;e<h;e++)d.push(m(a[e],b));return d}if("function"!==
typeof a&&a instanceof Object){d={};e=Object.prototype.hasOwnProperty;for(h in a)e.call(a,h)&&(d[h]=b?m(a[h]):a[h]);return d}return a};e.copyTo=function(a,b,d){var d=!!d,h;if(!(a instanceof Object)||!(b instanceof Object))throw TypeError("Must provide both source and destination objects");if(i)for(var c in b)h=Object.getOwnPropertyDescriptor(b,c),h.get||h.set?Object.defineProperty(a,c,h):a[c]=d?e.clone(b[c],!0):b[c];else for(c in b)a[c]=d?e.clone(b[c],!0):b[c];return a};e.propParse=function(a,d,c){var j=
function(){},g=d.each||void 0,f=d.property||j,B=d.method||j,j=d.getset||j,A=d.keywordParser||h,l=Object.prototype.hasOwnProperty,k={},r="",k={},x=null,u=!1,D=!1,p;for(p in a)if(l.call(a,p)){if(i)r=Object.getOwnPropertyDescriptor(a,p),u=r.get,D=r.set;x="function"===typeof u?void 0:a[p];k=A(p)||{};r=k.name||p;k=k.keywords||{};if(d.assumeAbstract||k["abstract"]&&!k.override){k["abstract"]=!0;if(!(x instanceof Array))throw TypeError("Missing parameter list for abstract method: "+r);b(r,x);x=e.createAbstractMethod.apply(this,
x)}g&&g.call(c,r,x,k);u||D?j.call(c,r,u,D,k):"function"===typeof x||k.proxy?B.call(c,r,x,e.isAbstractMethod(x),k):f.call(c,r,x,k)}};e.createAbstractMethod=function(a){var b=Array.prototype.slice.call(arguments),d=function(){throw Error("Cannot call abstract method");};e.defineSecureProp(d,"abstractFlag",!0);e.defineSecureProp(d,"definition",b);e.defineSecureProp(d,"__length",arguments.length);return d};e.isAbstractMethod=function(a){return"function"===typeof a&&!0===a.abstractFlag?!0:!1};e.arrayShrink=
function(a){for(var b=[],d=0,e=a.length;d<e;d++){var h=a[d];void 0!==h&&b.push(h)}return b};e.getOwnPropertyDescriptor=i&&Object.getOwnPropertyDescriptor||function(a,b){return!Object.prototype.hasOwnProperty.call(a,b)?void 0:{get:void 0,set:void 0,writable:!0,enumerable:!0,configurable:!0,value:a[b]}};e.getPrototypeOf=Object.getPrototypeOf||function(){};e.getPropertyDescriptor=function(a,b,d){var d=!!d,h=e.getOwnPropertyDescriptor(a,b),a=e.getPrototypeOf(a);return!h&&a&&(!d||e.getPrototypeOf(a))?
e.getPropertyDescriptor(a,b,d):h};e.defineSecureProp(e.getPropertyDescriptor,"canTraverse",Object.getPrototypeOf?!0:!1)})(f.util={},".");(function(c){var c=c.exports={},a=null,b="undefined"!==typeof console?console:void 0,d=c.Warning=function(a){if(!(this instanceof d))return new d(a);if(!(a instanceof Error))throw TypeError("Must provide exception to wrap");Error.prototype.constructor.call(this,a.message);this.message=a.message;this.name="Warning";this._error=a;this.stack=a.stack&&a.stack.replace(/^.*?\n+/,
this.name+": "+this.message+"\n")};d.prototype=Error();d.prototype.constructor=d;d.prototype.name="Warning";d.prototype.getError=function(){return this._error};c.handlers={log:function(a){var d;b&&(d=b.warn||b.log)&&d.call(b,"Warning: "+a.message)},throwError:function(a){throw a.getError();},dismiss:function(){}};c.setHandler=function(b){a=b};c.handle=function(b){a(b)};c.setConsole=function(a){b=a};a=c.handlers.log})(f.warn={},".");(function(c,a){function b(a,b,d){b=this.defs;if(!0===p[a])throw Error(a+
" is reserved");if(u.call(b,a)&&!d.weak&&!b[a].weak)throw Error("Cannot redefine method '"+a+"' in same declaration");b[a]=d}function d(a,b,d){this._cb._memberBuilder.buildProp(j(d)?this.static_members.props:this.prop_init,null,a,b,d,this.base)}function e(a,b,d,e){var h=j(e)?this.static_members.methods:this.members,c=j(e)?this.staticInstLookup:l.getMethodInstance;this._cb._memberBuilder.buildGetterSetter(h,null,a,b,d,e,c,this.class_id,this.base)}function h(a,b,d,e){var h=j(e),c=h?this.static_members.methods:
this.members,h=h?this.staticInstLookup:l.getMethodInstance;if(!0===E[a]&&(e["protected"]||e["private"]))throw TypeError(a+" must be public");this._cb._memberBuilder.buildMethod(c,null,a,b,e,h,this.class_id,this.base,this.state)&&(d?(this.abstract_methods[a]=!0,this.abstract_methods.__length++):u.call(this.abstract_methods,a)&&!1===d&&(delete this.abstract_methods[a],this.abstract_methods.__length--),e.virtual&&(this.virtual_members[a]=!0))}function i(a,b,d,e){if(a.___$$abstract$$){if(!e&&0===d.__length)throw TypeError("Class "+
(b||"(anonymous)")+" was declared as abstract, but contains no abstract members");}else if(0<d.__length)if(e)a.___$$abstract$$=!0;else throw TypeError("Class "+(b||"(anonymous)")+" contains abstract members and must therefore be declared abstract");}function j(a){return a["static"]||a["const"]?!0:!1}function v(a){var b=this,d=function(){};d.prototype=a;d=new d;a.___$$svis$$=d;d.$=function(){b._spropInternal=!0;var d=a.$.apply(a,arguments);b._spropInternal=!1;return d}}function m(a,b,d,e){var h=b.methods,
c=b.props,i=this;(b=d.___$$sinit$$)&&b(a,!0);if(!e)a.___$$sprops$$=c,k.defineSecureProp(a,"$",function(b,e){var h=!1,j=this.___$$sprops$$?this:a,m=j!==a,h=u.call(c["public"],b)&&"public";!h&&i._spropInternal&&(h=u.call(c["protected"],b)&&"protected"||!m&&u.call(c["private"],b)&&"private");if(!1===h)return(d.__cid&&d.$||l.ClassBase.$).apply(j,arguments);h=c[h][b];if(1<arguments.length){if(h[1]["const"])throw TypeError("Cannot modify constant property '"+b+"'");h[0]=e;return j}return h[0]});k.copyTo(a,
h["public"],!0);k.copyTo(a.___$$svis$$,h["protected"],!0);e||k.copyTo(a.___$$svis$$,h["private"],!0)}function f(a,b){var d=b.__cid?l.getMeta(b):void 0;a.___$$meta$$=d?k.clone(d,!0):{implemented:[]};return a.prototype.___$$meta$$=a.___$$meta$$}function o(a,b){k.defineSecureProp(a,"__iid",b)}function n(a){var b=function(){};b.prototype=a;a.___$$vis$$=new b}function q(a){var b=function(b){return c.exports.isInstanceOf(b,a)};k.defineSecureProp(a,"isInstanceOf",b);k.defineSecureProp(a,"isA",b)}function w(a,
b){var d=0<b.__length?!0:!1;k.defineSecureProp(a,"isAbstract",function(){return d})}function B(a,b){k.defineSecureProp(a,"__cid",b);k.defineSecureProp(a.prototype,"__cid",b)}function A(a,b){a.___$$final$$=!!b.___$$final$$;a.___$$abstract$$=!!b.___$$abstract$$;b.___$$final$$=b.___$$abstract$$=void 0}var l=c.exports={},k=g(a+"/util"),r=g(a+"/warn"),x=r.Warning,u=Object.prototype.hasOwnProperty,D=!1===Object.prototype.propertyIsEnumerable.call({toString:function(){}},"toString")?!0:!1,p={__initProps:!0,
constructor:!0},E={__construct:!0,toString:!0,__toString:!0};c.exports=l=function(a,b){if(!(this instanceof l))return new c.exports(a,b);this._memberBuilder=a;this._visFactory=b;this._instanceId=this._classId=0;this._spropInternal=this._extending=!1};l.ClassBase=function(){};k.defineSecureProp(l.ClassBase,"__cid",0);l.ClassBase.$=function(a,b){if(void 0!==b)throw ReferenceError("Cannot set value of undeclared static property '"+a+"'");};l.getReservedMembers=function(){return k.clone(p,!0)};l.getForcedPublicMethods=
function(){return k.clone(E,!0)};l.getMeta=function(a){return a.___$$meta$$||{}};l.isInstanceOf=function(a,b){var d,e;if(!a||!b)return!1;try{if(b instanceof a)return!0}catch(h){}if(!b.__cid||!(d=l.getMeta(b)))return!1;d=d.implemented;for(e=d.length;e--;)if(d[e]===a)return!0;return!1};l.prototype.build=function(a,b){this._extending=!0;var d=Array.prototype.slice.call(arguments),e=d.pop()||{},h=d.pop()||l.ClassBase,c=this._getBase(h),d="",j=!1,g=this._memberBuilder.initMembers(),u=this._memberBuilder.initMembers(c),
n={methods:this._memberBuilder.initMembers(),props:this._memberBuilder.initMembers()},o=k.clone(l.getMeta(h).abstractMethods)||{__length:0};virtual_members=k.clone(l.getMeta(h).virtualMembers)||{};if(!0===h.___$$final$$)throw Error("Cannot extend final class "+(h.___$$meta$$.name||"(anonymous)"));(d=e.__name)&&delete e.__name;void 0!==(j=e.___$$auto$abstract$$)&&delete e.___$$auto$abstract$$;if(D&&e.toString!==Object.prototype.toString)e.__toString=e.toString;this._classId++;try{this.buildMembers(e,
this._classId,h,g,{all:u,"abstract":o,"static":n,virtual:virtual_members},function(){return p.___$$svis$$})}catch(q){if(q instanceof x)r.handle(q);else throw q;}c.___$$parent$$=h.prototype;var p=this.createCtor(d,o,u);v(p);var E=function(a,b){m(a,n,h,b)};E(p,!1);this._attachPropInit(c,g,u,p,this._classId);p.prototype=c;p.prototype.constructor=p;p.___$$props$$=g;p.___$$methods$$=u;p.___$$sinit$$=E;A(p,e);i(p,d,o,j);k.defineSecureProp(c,"__self",p.___$$svis$$);e=f(p,h);e.abstractMethods=o;e.virtualMembers=
virtual_members;e.name=d;w(p,o);B(p,this._classId);this._extending=!1;return p};l.prototype._getBase=function(a){switch(typeof a){case "function":return new a;case "object":return a}throw TypeError("Must extend from Class, constructor or object");};l.prototype.buildMembers=function(a,c,i,j,g,m){var u={_cb:this,prop_init:j,class_id:c,base:i,staticInstLookup:m,defs:{},state:{},members:g.all,abstract_methods:g["abstract"],static_members:g["static"],virtual_members:g.virtual},v={each:b,property:d,getset:e,
method:h};if(a.___$$parser$$){var f=a.___$$parser$$;delete a.___$$parser$$;c=function(a,b){v[a]=function(){var d=Array.prototype.slice.call(arguments);d.push(b);f[a].apply(u,d)}};f.each&&c("each",v.each);f.property&&c("property",v.property);f.getset&&c("getset",v.getset);f.method&&c("method",v.method)}k.propParse(a,v,u);this._memberBuilder.end(u.state)};l.prototype.createCtor=function(a,b,d){return 0===b.__length?this.createConcreteCtor(a,d):this.createAbstractCtor(a)};l.prototype.createConcreteCtor=
function(a,b){function d(){if(!(this instanceof d))return e=arguments,new d;n(this);this.__initProps();if(!h._extending&&(o(this,++h._instanceId),"function"===typeof this.___$$tctor$$&&this.___$$tctor$$.call(this),"function"===typeof this.__construct&&this.__construct.apply(this,e||arguments),e=null,q(this),!u.call(b["public"],"toString")))this.toString=b["public"].__toString||(a?function(){return"#<"+a+">"}:function(){return"#<anonymous>"})}var e=null,h=this;d.toString=a?function(){return a}:function(){return"(Class)"};
return d};l.prototype.createAbstractCtor=function(a){var b=this,d=function(){if(!b._extending)throw Error("Abstract class "+(a||"(anonymous)")+" cannot be instantiated");};d.toString=a?function(){return a}:function(){return"(AbstractClass)"};return d};l.prototype._attachPropInit=function(a,b,d,e,h){var c=this;k.defineSecureProp(a,"__initProps",function(e){var e=!!e,i=a.___$$parent$$,i=i&&i.__initProps;"function"===typeof i&&i.call(this,!0);i=c._visFactory.createPropProxy(this,this.___$$vis$$,b["public"]);
i=this.___$$vis$$[h]=c._visFactory.setup(i,b,d);e||k.defineSecureProp(i,"__inst",this)})};l.getMethodInstance=function(a,b){var d=a.___$$vis$$;return a.__iid&&d?d[b]:null}})(f.ClassBuilder={},".");(function(c){var a=c.exports={};c.exports=a=function(b){if(!(this instanceof a))return new c.exports(b);this._factory=b};a.prototype.wrapMethod=function(a,d,e,h,c,j){return this._factory(a,d,e,h,c,j)}})(f.MethodWrapperFactory={},".");(function(c){(c.exports={}).standard={wrapOverride:function(a,b,d,e){return function(){var h=
e(this,d)||this,c=void 0,j=h.__super;h.__super=b;c=a.apply(h,arguments);h.__super=j;return c===h?this:c}},wrapNew:function(a,b,d,e){return function(){var b=e(this,d)||this,c=void 0,c=a.apply(b,arguments);return c===b?this:c}},wrapProxy:function(a,b,d,e,h,c){var j=c&&c["static"],b=function(){var b=e(this,d)||this,c=void 0,b=j?b.$(a):b[a];if(!(null!==b&&"object"===typeof b&&"function"===typeof b[h]))throw TypeError("Unable to proxy "+h+"() call to '"+a+"'; '"+a+"' is undefined or '"+h+"' is not a function.");
c=b[h].apply(b,arguments);return c===b?this:c};b.__length=NaN;return b}}})(f.MethodWrappers={},".");(function(c,a){function b(a){return function(){return this.___$$super$$.prototype[a].apply(this.___$$pmo$$,arguments)}}function d(a,b,d){if(b["private"])return(b["public"]||b["protected"])&&e(d),a["private"];if(b["protected"])return(b["public"]||b["private"])&&e(d),a["protected"];(b["private"]||b["protected"])&&e(d);return a["public"]}function e(a){throw TypeError("Only one access modifier may be used for definition of '"+
a+"'");}function h(a,b,d){for(var e=f.length,c=null;e--;)if(c=j.getPropertyDescriptor(a[f[e]],b,!0))return{get:c.get,set:c.set,member:c.value};return void 0!==d?(a=d.___$$methods$$,e=d.___$$props$$,d=((d.prototype||{}).___$$parent$$||{}).constructor,a&&h(a,b,d)||e&&h(e,b,d)||null):null}var i=c.exports={},j=g(a+"/util");g(a+"/warn");var f=["public","protected","private"];c.exports=function(a,b,d,e){if(!(this instanceof c.exports))return new c.exports(a,b,d,e);this._wrapMethod=a;this._wrapOverride=
b;this._wrapProxy=d;this._validate=e};i=c.exports.prototype;i.initMembers=function(a,b,d){return{"public":a||{},"protected":b||{},"private":d||{}}};i.buildMethod=function(a,e,c,i,j,g,f,v,l){var k=(v=(e=h(a,c,v))?e.member:null)&&v.___$$keywords$$,a=d(a,j,c);this._validate.validateMethod(c,i,j,e,k,l);if(j.proxy&&(!v||!j.weak))a[c]=this._createProxy(i,g,f,c,j);else if(v){if(j.weak&&!k["abstract"])return!1;if(j.override||k["abstract"])l=j["abstract"]?b(c):v,a[c]=this._overrideMethod(l,i,g,f);else throw Error("Method hiding not yet implemented (we should never get here; bug).");
}else a[c]=j["abstract"]?i:this._overrideMethod(null,i,g,f);a[c].___$$keywords$$=j;return!0};i.buildProp=function(a,b,e,c,i,j){j=(b=h(a,e,j))?b.member:null;this._validate.validateProperty(e,c,i,b,j?j[1]:null);d(a,i,e)[e]=[c,i]};i.buildGetterSetter=function(a,b,e,c,i,j,g,f,v){b=h(a,e,v);this._validate.validateGetterSetter(e,{},j,b,b&&b.get?b.get.___$$keywords$$:null);if(c)c=this._overrideMethod(null,c,g,f),c.___$$keywords$$=j;Object.defineProperty(d(a,j,e),e,{get:c,set:i?this._overrideMethod(null,
i,g,f):i,enumerable:!0,configurable:!1})};i._createProxy=function(a,b,d,e,c){return this._wrapProxy.wrapMethod(a,null,d,b,e,c)};i._overrideMethod=function(a,b,d,e){var c=null,c=(a?this._wrapOverride:this._wrapMethod).wrapMethod(b,a,e,d||function(){});j.defineSecureProp(c,"__length",b.__length||b.length);return c};i._getVisibilityValue=function(a){return a["protected"]?1:a["private"]?2:0};i.end=function(a){this._validate&&this._validate.end(a)}})(f.MemberBuilder={},".");(function(c){var a=c.exports=
{};c.exports=a=function(a){if(!(this instanceof c.exports))return new c.exports(a);this._warningHandler=a||function(){}};a.prototype._initState=function(a){if(a.__vready)return a;a.warn={};a.__vready=!0;return a};a.prototype.end=function(a){for(var d in a.warn){var e=a.warn[d],c;for(c in e)this._warningHandler(e[c])}a.__vready=!1};a.prototype.validateMethod=function(a,d,e,c,i,j){this._initState(j);var g=c?c.member:null;if(e["abstract"]&&e["private"])throw TypeError("Method '"+a+"' cannot be both private and abstract");
if(e["const"])throw TypeError("Cannot declare method '"+a+"' as constant; keyword is redundant");if(e.virtual&&e["static"])throw TypeError("Cannot declare static method '"+a+"' as virtual");if(c&&(c.get||c.set))throw TypeError("Cannot override getter/setter '"+a+"' with method");if(e.proxy){if("string"!==typeof d)throw TypeError("Cannot declare proxy method '"+a+"'; string value expected");if(e["abstract"])throw TypeError("Proxy method '"+a+"' cannot be abstract");}if(g){if(i["private"])throw TypeError("Private member name '"+
a+"' conflicts with supertype");if("function"!==typeof g)throw TypeError("Cannot override property '"+a+"' with method");if(e.override&&!i.virtual){if(!e["abstract"])throw TypeError("Cannot override non-virtual method '"+a+"'");if(!i["abstract"])throw TypeError("Cannot perform abstract override on non-abstract method '"+a+"'");}if(e["abstract"]&&!e.weak&&!i["abstract"])throw TypeError("Cannot override concrete method '"+a+"' with abstract method");c=void 0===g.__length?g.length:g.__length;d=void 0===
d.__length?d.length:d.__length;e.proxy&&(d=NaN);e.weak&&!i["abstract"]&&(g=c,c=d,d=g);if(d<c)throw TypeError("Declaration of method '"+a+"' must be compatible with that of its supertype");if(this._getVisibilityValue(i)<this._getVisibilityValue(e))throw TypeError("Cannot de-escalate visibility of method '"+a+"'");if(!e.override&&!i["abstract"]&&!e.weak)throw TypeError("Attempting to override method '"+a+"' without 'override' keyword");e.weak&&i.override&&delete (j.warn[a]||{}).no}else if(e.override)(j.warn[a]=
j.warn[a]||{}).no=Error("Method '"+a+"' using 'override' keyword without super method")};a.prototype.validateProperty=function(a,d,e,c,i){if(d=c?c.member:null){if(i["private"])throw TypeError("Private member name '"+a+"' conflicts with supertype");if("function"===typeof d)throw new TypeError("Cannot override method '"+a+"' with property");if(this._getVisibilityValue(i)<this._getVisibilityValue(e))throw TypeError("Cannot de-escalate visibility of property '"+a+"'");}if(c&&(c.get||c.set))throw TypeError("Cannot override getter/setter '"+
a+"' with property");if(e["abstract"])throw TypeError("Property '"+a+"' cannot be declared as abstract");if(e["static"]&&e["const"])throw TypeError("Static keyword cannot be used with const for property '"+a+"'");if(e.virtual)throw TypeError("Cannot declare property '"+a+"' as virtual");};a.prototype.validateGetterSetter=function(a,d,e,c,i){d=c?c.member:null;c=c&&(c.get||c.set)?!0:!1;if(e["abstract"])throw TypeError("Cannot declare getter/setter '"+a+"' as abstract");if(e["const"])throw TypeError("Cannot declare const getter/setter '"+
a+"'");if(e.virtual&&e["static"])throw TypeError("Cannot declare static method '"+a+"' as virtual");if(d||c){if(i&&i["private"])throw TypeError("Private member name '"+a+"' conflicts with supertype");if(!c)throw TypeError("Cannot override method or property '"+a+"' with getter/setter");if(!i||!i.virtual)throw TypeError("Cannot override non-virtual getter/setter '"+a+"'");if(!e.override)throw TypeError("Attempting to override getter/setter '"+a+"' without 'override' keyword");if(this._getVisibilityValue(i||
{})<this._getVisibilityValue(e))throw TypeError("Cannot de-escalate visibility of getter/setter '"+a+"'");}else e.override&&this._warningHandler(Error("Getter/setter '"+a+"' using 'override' keyword without super getter/setter"))};a.prototype._getVisibilityValue=function(a){return a["protected"]?1:a["private"]?2:0}})(f.MemberBuilderValidator={},".");(function(c,a){var b=c.exports={},d=g(a+"/util");c.exports=b=function(){if(!(this instanceof b))return new c.exports};b.prototype.setup=function(a,b,
d){var c=this._createPrivateLayer(a,b);this._doSetup(a,b["public"]);this._doSetup(a,b["protected"],d["protected"],!0);this._doSetup(c,b["private"],d["private"]);return c};b.prototype._createPrivateLayer=function(a,b){var d=function(){};d.prototype=a;d=new d;this.createPropProxy(a,d,b["protected"]);return d};b.prototype._doSetup=function(a,b,c,j){var g=Array.prototype.hasOwnProperty;if(void 0!==c)for(var f in c)if(g.call(c,f)){var t=a[f],o=t&&t.___$$keywords$$;if(!j||void 0===t||o["private"]||o["protected"])a[f]=
c[f]}for(var n in b)g.call(b,n)&&(a[n]=d.clone(b[n][0]))};b.prototype.createPropProxy=function(a,b,d){var c=Object.prototype.hasOwnProperty,g;for(g in d)c.call(d,g)&&function(d){b[d]=void 0;Object.defineProperty(b,d,{set:function(b){a[d]=b},get:function(){return a[d]},enumerable:!0})}.call(null,g);return b}})(f.VisibilityObjectFactory={},".");(function(c,a){var b=c.exports={};c.exports=b=function(){if(!(this instanceof b))return new c.exports};b.prototype=g(a+"/VisibilityObjectFactory")();b.prototype._createPrivateLayer=
function(a){return a};b.prototype.createPropProxy=function(a){return a}})(f.FallbackVisibilityObjectFactory={},".");(function(c,a){var b=c.exports={},d=g(a+"/util"),e=g(a+"/VisibilityObjectFactory"),h=g(a+"/FallbackVisibilityObjectFactory");b.fromEnvironment=function(){return d.definePropertyFallback()?h():e()}})(f.VisibilityObjectFactoryFactory={},".");(function(c,a){function b(a){if(1<arguments.length)throw Error("Expecting one argument for anonymous Class definition; "+arguments.length+" given.");
return f(a)}function d(a,b){if(2<arguments.length)throw Error("Expecting at most two arguments for definition of named Class '"+a+"'; "+arguments.length+" given.");if(void 0===b)return e(a);if("object"!==typeof b)throw TypeError("Unexpected value for definition of named Class '"+a+"'; object expected");b.__name=a;return f(b)}function e(a){return{extend:function(){var b=Array.prototype.slice.apply(arguments);b[b.length-1].__name=a;return f.apply(null,b)},implement:function(){return h(null,Array.prototype.slice.call(arguments),
a)},use:function(){return i(r,Array.prototype.slice.call(arguments))}}}function h(a,b,d){var e={extend:function(){var e=Array.prototype.slice.call(arguments),c=e.pop(),h=e.pop();if(0<e.length)throw Error("Expecting no more than two arguments for extend()");if(a&&h)throw Error("Cannot override parent "+a.toString()+" with "+h.toString()+" via extend()");if(d)c.__name=d;b.push(a||h||f({}));return f.call(null,x.apply(this,b),c)},use:function(){var a=Array.prototype.slice.call(arguments);return i(function(){return e.__createBase()},
a)},__createBase:function(){return e.extend({})}};return e}function i(a,b,d){var e=function(){if(!d)throw TypeError("Cannot instantiate incomplete class definition; did you forget to call `extend'?");return j(a(),b).apply(null,arguments)};e.extend=function(){var d=Array.prototype.slice.call(arguments),e=d.pop(),d=d.pop(),c=a();return f.call(null,j(c||d,b),e)};e.use=function(){return i(function(){return e.__createBase()},Array.prototype.slice.call(arguments),d)};e.__createBase=function(){return e.extend({})};
return e}function j(a,b){for(var d={___$$auto$abstract$$:!0},e=[],c=0,h=b.length;c<h;c++)b[c].__mixin(d,e,a||q.ClassBase);d=f.call(null,a,d);e=q.getMeta(d).implemented;c=0;for(h=b.length;c<h;c++)e.push(b[c]),b[c].__mixinImpl(e);return d}function f(a,b){var d=k.build.apply(k,arguments),e=d;m(e);t(e);o(e);n.freeze(d);return d}function m(a){n.defineSecureProp(a,"extend",function(a){return f(this,a)})}function t(a){n.defineSecureProp(a,"implement",function(){return h(a,Array.prototype.slice.call(arguments))})}
function o(a){n.defineSecureProp(a,"use",function(){return i(function(){return a},Array.prototype.slice.call(arguments),!0)})}c.exports={};var n=g(a+"/util"),q=g(a+"/ClassBuilder"),w=g(a+"/warn"),B=w.Warning,A=g(a+"/MethodWrapperFactory"),l=g(a+"/MethodWrappers").standard,k=q(g(a+"/MemberBuilder")(A(l.wrapNew),A(l.wrapOverride),A(l.wrapProxy),g(a+"/MemberBuilderValidator")(function(a){w.handle(B(a))})),g(a+"/VisibilityObjectFactoryFactory").fromEnvironment()),r=function(){return null};c.exports=function(a,
e){var c=null;switch(typeof a){case "object":c=b.apply(null,arguments);break;case "string":c=d.apply(null,arguments);break;default:throw TypeError("Expecting anonymous class definition or named class definition");}return c};c.exports.extend=function(a,b){return f.apply(this,arguments)};c.exports.implement=function(a){return h(null,Array.prototype.slice.call(arguments))};c.exports.use=function(a){return i(r,Array.prototype.slice.call(arguments))};c.exports.isClass=function(a){a=a||{};return a.prototype instanceof
q.ClassBase?!0:!1};c.exports.isClassInstance=function(a){a=a||{};return a instanceof q.ClassBase?!0:!1};c.exports.isInstanceOf=q.isInstanceOf;c.exports.isA=c.exports.isInstanceOf;var x=function(a,b){for(var d=Array.prototype.slice.call(arguments),e={},h=d.pop(),i=d.length,j=null,g=[],f=!1,k=0;k<i;k++)j=d[k],n.propParse(j.prototype,{method:function(a,b){e["abstract "+a]=b.definition;f=!0}}),g.push(j);if(f)e.___$$abstract$$=!0;d=c.exports.extend(h,e);q.getMeta(d).implemented=g;return d}})(f["class"]=
{},".");(function(c,a){function b(a){a=a[a.length-1];if("object"===typeof a)a.___$$abstract$$=!0}function d(a){var e=a.extend,c=a.implement,h=a.use;c&&(a.implement=function(){return d(c.apply(this,arguments))});h&&(a.use=function(){return d(h.apply(this,arguments))});a.extend=function(){b(arguments);return e.apply(this,arguments)};a.__createBase=function(){return e({___$$auto$abstract$$:!0})};return a}var e=c.exports={},h=g(a+"/class");c.exports=e=function(){b(arguments);var a=h.apply(this,arguments);
h.isClass(a)||d(a);return a};e.extend=function(){b(arguments);return h.extend.apply(this,arguments)};e.use=function(){return d(h.use.apply(this,arguments))};e.implement=function(){return d(h.implement.apply(this,arguments))}})(f.class_abstract={},".");(function(c,a){function b(){switch(arguments.length){case 1:return b.extend.apply(this,arguments);case 2:return d.apply(this,arguments);default:throw Error("Missing trait name or definition");}}function d(a,d){if(2<arguments.length)throw Error("Expecting at most two arguments for definition of named Trait "+
a+"'; "+arguments.length+" given");if("string"!==typeof a)throw Error("First argument of named class definition must be a string");d.__name=a;return b.extend(d)}function e(a,b,d,e){if("__construct"===a)throw Error("Traits may not define __construct");if(d["static"])throw Error("Cannot define member `"+a+"'; static trait members are currently unsupported");e.apply(this,arguments)}function h(a,b,d,e){if("___"!==a.substr(0,3)){if(!d["private"])throw Error("Cannot define property `"+a+"'; only private properties are permitted within Trait definitions");
e.apply(this,arguments)}}function i(a){throw Error("Cannot define property `"+a+"'; getters/setters are currently unsupported");}function j(a){var b={"protected ___$$pmo$$":null,"protected ___$$super$$":null,__construct:function(a,b){this.___$$super$$=a;this.___$$pmo$$=b},__name:"#ConcreteTrait#"},d=w.getMeta(a).abstractMethods,e;for(e in d)Object.hasOwnProperty.call(d,e)&&"__"!==e.substr(0,2)&&(b[(void 0!==a.___$$methods$$["public"][e]?"public":"protected")+" proxy "+e]="___$$pmo$$");f(a,b);return a.extend(b)}
function f(a,b){var d=w.getMeta(a).virtualMembers,e;for(e in d){var c=void 0!==a.___$$methods$$["public"][e]?"public":"protected";b[c+" virtual override "+e]=function(){return function(){var a=this.___$$pmo$$,b=a[e];return b?b.apply(a,arguments):this.__super.apply(this,arguments)}}(e);b[c+" virtual __$$"+e]=function(a){return function(){return this.___$$parent$$[a].apply(this,arguments)}}(e)}}function m(a,b,d){a=a.___$$methods$$;t(a["public"],b,"public",d);t(a["protected"],b,"protected",d);(a=a["public"].___$$parent$$)&&
a.constructor!==w.ClassBase&&m(a.constructor,b,d)}function t(a,b,d,e){for(var c in a)if(Object.hasOwnProperty.call(a,c)&&a[c].___$$keywords$$){var h=a[c].___$$keywords$$,d=h["protected"]?"protected":"public";if(h["abstract"]&&!h.override)b[d+" weak abstract "+c]=a[c].definition;else{var i=h.virtual,d=(i?"":"proxy ")+(i?"virtual ":"")+(h.override?"override ":"")+d+" "+c;if(void 0!==b[d])throw Error("Trait member conflict: `"+c+"'");b[d]=h.virtual?function(a){return function(){var b=this[e],d=b["__$$"+
a].apply(b,arguments);return d===b?this:d}}(c):e}}}function o(a,b,d,e){var c="___$to$"+a.__acls.__cid+"$"+e.__cid;d.push([c,a]);b["private "+c]=null;void 0===b.___$$tctor$$&&(b["weak virtual ___$$tctor$$"]=function(){},b["virtual override ___$$tctor$$"]=n(d,e));return c}function n(a,b){return function(){for(var d in a){var e=a[d][0],c=a[d][1],c=c.__ccls||(c.__ccls=j(c.__acls));this[e]=c(b,this.___$$vis$$).___$$vis$$}this.__super&&this.__super()}}c.exports={};var q=g(a+"/class_abstract"),w=g(a+"/ClassBuilder");
b.extend=function(a){function b(){throw Error("Cannot instantiate trait");}var d=this.__$$meta||{},c=a.__name||"(Trait)";a.___$$parser$$={each:e,property:h,getset:i};a.___$$auto$abstract$$=!0;a.__name="#AbstractTrait#";var j=q;d.ifaces&&(j=j.implement.apply(null,d.ifaces));var g=j.extend(a);b.__trait=!0;b.__acls=g;b.__ccls=null;b.toString=function(){return""+c};b.__mixin=function(a,d,e){var c=b.__acls,d=o(b,a,d,e);m(c,a,d)};b.__mixinImpl=function(a){for(var b=w.getMeta(g).implemented||[],d=b.length;d--;)a.push(b[d])};
return b};b.implement=function(){var a=arguments;return{extend:function(){return b.extend.apply({__$$meta:{ifaces:a}},arguments)}}};b.isTrait=function(a){return!!(a||{}).__trait};c.exports=b})(f.Trait={},".");(function(c,a){function b(a){a=a[a.length-1];if("object"===typeof a)a.___$$final$$=!0}function d(a){var d=a.extend;a.extend=function(){b(arguments);return d.apply(this,arguments)}}var e=c.exports={},h=g(a+"/class"),e=c.exports=function(){b(arguments);var a=h.apply(this,arguments);h.isClass(a)||
d(a);return a};e.extend=function(){b(arguments);return h.extend.apply(this,arguments)}})(f.class_final={},".");(function(c,a){var b=c.exports={},d=g(a+"/MemberBuilder");c.exports=b=function(a,b){if(!(this instanceof c.exports))return new c.exports(a,b);c.exports.prototype.constructor.call(this,a,b)};c.exports.prototype=new d;c.exports.constructor=c.exports;b.prototype.buildGetterSetter=function(){throw Error("Getters/setters are unsupported in this environment");}})(f.FallbackMemberBuilder={},".");
(function(c,a){function b(){}function d(a){if(1<arguments.length)throw Error("Expecting one argument for Interface definition; "+arguments.length+" given.");return o(a)}function e(a,b){if(2<arguments.length)throw Error("Expecting two arguments for definition of named Interface '"+a+"'; "+arguments.length+" given.");if("object"!==typeof b)throw TypeError("Unexpected value for definition of named Interface '"+a+"'; object expected");b.__name=a;return o(b)}function h(a){j.defineSecureProp(a,"extend",
function(a){return o(this,a)})}function i(a,b){a.toString=b?function(){return"[object Interface <"+b+">]"}:function(){return"[object Interface]"}}c.exports={};var j=g(a+"/util"),f=g(a+"/MethodWrapperFactory"),m=g(a+"/MethodWrappers").standard,t=g(a+"/MemberBuilder")(f(m.wrapNew),f(m.wrapOverride),f(m.wrapProxy),g(a+"/MemberBuilderValidator")());g(a+"/class");c.exports=function(a,b){var c=null;switch(typeof a){case "object":c=d.apply(null,arguments);break;case "string":c=e.apply(null,arguments);break;
default:throw TypeError("Expecting anonymous interface definition or named interface definition");}return c};c.exports.extend=function(){return o.apply(this,arguments)};c.exports.isInterface=function(a){a=a||{};return a.prototype instanceof b?!0:!1};var o=function(a){function d(b){return function(){if(!a)throw Error("Interface "+(b?b+" ":"")+" cannot be instantiated");}}return function(){a=!0;var e=Array.prototype.slice.call(arguments),c=e.pop()||{},e=new (e.pop()||b),g="",f={},v=t.initMembers(e,
e,e);(g=c.__name)&&delete c.__name;if(!(e instanceof b))throw new TypeError("Interfaces may only extend other interfaces");var m=d(g);try{j.propParse(c,{assumeAbstract:!0,property:function(){throw TypeError("Unexpected internal error");},getset:function(){throw TypeError("Unexpected internal error");},method:function(a,b,d,e){if(e["protected"]||e["private"])throw TypeError(g+" member "+a+" must be public");t.buildMethod(v,null,a,b,e,null,0,{},f)}})}catch(x){throw x.message="Failed to define interface "+
(g?g:"(anonymous)")+": "+x.message,x;}h(m);i(m,g);m.prototype=e;m.constructor=m;j.freeze(m);a=!1;return m}}(!1)})(f["interface"]={},".");(function(c){c.exports={};var a=[0,2,0,""];a.major=0;a.minor=2;a.rev=0;a.suffix="";a.toString=function(){return this.join(".").replace(/\.([^.]*)$/,"-$1").replace(/-$/,"")};c.exports=a})(f.version={},".");f.common=f["test/common"]={exports:{require:function(c){return g(c)},testCase:function(){return g("test/inc-testcase").apply(this,arguments)}}};f.assert={exports:{equal:function(c,
a,b){c!=a&&z(b)},strictEqual:function(c,a,b){c!==a&&z(b)},notStrictEqual:function(c,a,b){c===a&&z(b)},notEqual:function(c,a,b){c===a&&z(b)},deepEqual:function(c,a,b){if(c!=a)if(a instanceof Array&&c instanceof Array)for(var d=0,e=a.length;d<e;d++)f.assert.exports.deepEqual(c[d],a[d],b);else if("object"===typeof a&&"object"===typeof c)for(d in a)f.assert.exports.deepEqual(c[d],a[d],b);else z(b)},ok:function(c,a){c||z(a)},fail:function(c){z(c)},"throws":function(c,a,b){a=a||Error;try{c()}catch(d){d instanceof
a||z(b)}},doesNotThrow:function(c,a,b){a=a||Error;try{c()}catch(d){d instanceof a&&z(b)}}}};y.runTests=function(){(function(c,a){function b(){f++}function d(){r("\n");0!==n%60&&r("\n");if(w.length){var a=w,b,d,e;if("undefined"===typeof process){e="";b=a.length;for(b in a)d=a[b],e+=d[0]+" ("+(d[1].message||"no message")+")"+(d[1].stack?"<br />"+d[1].stack.replace(/\n/g,"<br />")+"<br />":"; ");throw Error(e);}for(b=0;b<a.length;b++)d=a[b],e=d[0],d=d[1],r("#"+b+" "+e+"\n"+(d.stack||d)+"\n\n")}r((w.length?
"FAILED":"OK")+" - "+t+" successful, "+w.length+" failure(s), "+(0<m?m+" incomplete, ":"")+(0<o?o+" skipped, ":"")+(t+m+o+w.length)+" total ("+f+" assertion"+(1!==f?"s":"")+")\n");w.length&&"undefined"!==typeof process&&process.exit(1)}function e(a){var a=A(a),b=function(){},a=b.prototype=new a,d;for(d in a)"function"===typeof a[d]&&(a[d]=function(){});return new b}function h(){throw z;}c.exports={};document.write("test/inc-testcase...<br />");var i=g("assert"),j={},f=0,m=0,t=0,o=0,n=0,q=!1,w=[],
z={skip:!0},A=g(a+"/common").require,l;for(l in i){var k=i[l];"function"===typeof k&&(j[l]=function(a){return function(){f++;a.apply(this,arguments)}}(k))}c.exports=function(a){var c={require:A,fail:j.fail,assertOk:j.ok,assertEqual:j.equal,assertNotEqual:j.notEqual,assertDeepEqual:j.deepEqual,assertStrictEqual:j.strictEqual,assertNotStrictEqual:j.notStrictEqual,assertThrows:j["throws"],assertDoesNotThrow:j.doesNotThrow,assertIfError:j.ifError,incAssertCount:b,getMock:e,skip:h},i=a.setUp;q||(w=[],
t=f=m=o=0);a.caseSetUp&&a.caseSetUp.call(c);delete a.caseSetUp;delete a.setUp;for(var g in a){var k=g.match(/^(?:@(.*?)\((.*?)\))?(.*)$/),l=k[1],y=k[2],k=k[3],F=1,G=[[]];if("each"===l){if(!c[y])throw Error("Unknown @each context: "+y);F=c[y].length;G=[];for(l=0;l<F;l++)G.push([c[y][l]])}else if(l)throw Error("Unknown test method: "+l);for(l=0;l<F;l++){var y=a,K=g,H=i||null,L=k+(1<F?" ("+l+")":""),I=c,M=G[l],N=f;try{H&&H.call(I),y[K].apply(I,M),N===f?(r("I"),m++):(t++,r("."))}catch(J){J===z?(r("S"),
o++):(r("F"),w.push([L,J]))}n++;n%60||r(" "+n+"\n")}}q||d()};c.exports.startSuite=function(){w=[];t=f=m=o=0;q=!0};c.exports.endSuite=function(){q=!1;d()};var r="undefined"===typeof process||"undefined"===typeof process.stdout?function(){}:function(a){process.stdout.write(a)}})(f["test/inc-testcase"]={},"test");(function(c){c=c.exports={};document.write("test/MemberBuilder/inc-common...<br />");c.testArgs=function(a,b,d,e,c,i,g){var f={value:{expected:null,given:b[3]},keywords:{expected:null,given:b[4]}},
f=g(f,f.value.given,f.keywords.given);a.assertEqual(d,b[0],"Incorrect name passed to validator");a.assertDeepEqual(e,b[1],"Incorrect value passed to validator");a.assertStrictEqual(c,b[2],"Incorrect keywords passed to validator");a.assertStrictEqual(f.value.expected,f.value.given,"Previous data should contain prev value if overriding, otherwise null");a.assertDeepEqual(f.keywords.expected,f.keywords.given,"Previous keywords should contain prev keyword if overriding, otherwise null");a.assertStrictEqual(i,
b[5],"State object was not passed to validator")}})(f["test/MemberBuilder/inc-common"]={},"test/MemberBuilder");(function(c){var a=c.exports={};document.write("test/MemberBuilderValidator/inc-common...<br />");a.testName="fooBar";a.quickFailureTest=function(a,d,e){this.incAssertCount();try{e()}catch(c){this.assertOk(-1!==c.message.search(d),"Incorrect error; expected identifier '"+d+"', but received: "+c.message);this.assertOk(-1!==c.message.search(a),"Error message should contain member name");return}this.fail(!1,
!0,"Expected failure")};a.quickKeywordTest=function(b,d,e,c,i){for(var f={},g={},i=i||{},m=a.testName,t={},o=this,n=0,q=d.length;n<q;n++)f[d[n]]=!0;if(void 0!==c){n=0;for(q=c.length;n<q;n++)g[c[n]]=!0;i.member=function(){}}d=function(){o.sut[b](m,f.proxy?"proxyDest":function(){},f,i,g,t)};e?this.quickFailureTest.call(this,m,e,d):this.assertDoesNotThrow(d);this.sut.end(t)};a.visEscalationTest=function(a){for(var d=[["protected","public"],["public","public"],["protected","protected"]],e=0,c=d.length;e<
c;e++)a(d[e])};a.privateNamingConflictTest=function(a){for(var d=[["private","private"],["private","protected"],["private"," public"]],e=d.length;e--;)a(d[e])};a.quickVisChangeTest=function(a,d,e,c,i){var f={},g={};f[a]=!0;g[d]=!0;a=function(){c("foo",f,g)};e?this.quickFailureTest.call(this,"foo",i||"de-escalate",a):this.assertDoesNotThrow(a,Error)}})(f["test/MemberBuilderValidator/inc-common"]={},"test/MemberBuilderValidator");(function(c){c.exports={};document.write("test/Class/AbstractTest...<br />");
g("common").testCase({caseSetUp:function(){this.Sut=this.require("class_abstract");this.Class=this.require("class")},"Must declare classes with abstract members as abstract":function(){try{this.Class("Foo",{"abstract foo":[]})}catch(a){this.assertOk(-1!==a.message.search("Foo"),"Abstract class declaration error should contain class name");return}this.assertFail("Should not be able to declare abstract members unless class is also declared as abstract")},"Can declare class as abstract":function(){var a=
this.Sut;this.assertDoesNotThrow(function(){a({"abstract foo":[]})},Error)},"Abstract classes must contain abstract methods":function(){try{this.Sut("Foo",{})}catch(a){this.assertOk(-1!==a.message.search("Foo"),"Abstract class declaration error should contain class name");return}this.assertFail("Abstract classes should contain at least one abstract method")},"Abstract methods can be defined concretely by sub-subtypes":function(){var a=this.Sut.extend(this.Sut("Foo",{"abstract foo":[]}),{}),b=this.Class;
this.assertDoesNotThrow(function(){b.extend(a,{foo:function(){}})},Error)},"Abstract class extend method returns new class":function(){this.assertEqual(typeof this.Sut.extend,"function","AbstractClass contains extend method");this.assertOk(this.Class.isClass(this.Sut.extend({"abstract foo":[]})),"Abstract class extend method returns class")},"Abstract class contains implement method":function(){this.assertEqual(typeof this.Sut.implement,"function","AbstractClass contains implement method")},"All classes have an isAbstract() method":function(){this.assertEqual(typeof this.Class({}).isAbstract,
"function")},"Concrete classes are not considered to be abstract":function(){this.assertOk(!this.Class({}).isAbstract())},"Abstract classes are considered to be abstract":function(){this.assertOk(this.Sut({"abstract method":[]}).isAbstract())},"Subtypes are abstract if no concrete method is provided":function(){this.assertOk(this.Sut.extend(this.Sut({"abstract foo":[],"abstract bar":[]}),{foo:function(){}}).isAbstract())},"Subtypes are not considered abstract if concrete methods are provided":function(){this.assertOk(!1===
this.Class.extend(this.Sut({"abstract foo":[],"abstract bar":[]}),{foo:function(){},bar:function(){}}).isAbstract())},"Abstract classes cannot be instantiated":function(){var a=this.Sut;this.assertThrows(function(){a({"abstract foo":[]})()},Error)},"Concrete subtypes of abstract classes can be instantiated":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a({"abstract foo":[]}).extend({foo:function(){}})()},Error)},"Can call constructors of abstract supertypes":function(){var a=!1;this.Sut({__construct:function(){a=
!0},"abstract foo":[]}).extend({foo:function(){}})();this.assertOk(a)},"Concrete methods must implement the proper number of parameters":function(){var a=this.Sut;this.assertThrows(function(){a({"abstract foo":["one","two"]}).extend({foo:function(){}})},Error)},"Abstract methods of subtypes must declare compatible parameter count":function(){var a=this.Sut;this.assertThrows(function(){a.extend(a({"abstract foo":["one"]}),{"abstract foo":[]})},TypeError)},"Abstract members may implement more parameters than supertype":function(){var a=
this.Sut;this.assertDoesNotThrow(function(){a.extend(a({"abstract foo":["one"]}),{"abstract foo":["one","two"]})},Error)},"Abstract members may implement equal parameters to supertype":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a.extend(a({"abstract foo":["one"]}),{"abstract foo":["one"]})},Error)},"Concrete methods have no parameter requirement with empty definition":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a({"abstract foo":[]}).extend({foo:function(){}})},
Error)},"Abstract methods must be declared as arrays":function(){var a=this.Class;this.assertThrows(function(){a.extend({"abstract foo":function(){}})},TypeError,"Abstract method cannot be declared as a function");this.assertThrows(function(){a.extend({"abstract foo":"scalar"})},TypeError,"Abstract method cannot be declared as a scalar")},"Does not recognize object prototype members as abstract":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a({"abstract method":[]}).extend({method:function(){},
toString:function(){}})()},Error)},"Can create named abstract subtypes":function(){this.assertOk(this.Sut("Named").extend(this.Sut({"abstract foo":[]}),{}).isAbstract())},"Calling extend() on abstract class yields concrete class":function(){var a=this.Sut({"abstract foo":[]}),b=this.Sut("NamedSubFoo").extend(a,{}),d=this.Sut.extend(a,{}),e=this.Class;this.assertThrows(function(){e.isAbstract(b.extend({}))},TypeError,"Extending named abstract classes should be concrete");this.assertThrows(function(){e.isAbstract(d.extend({}))},
TypeError,"Extending anonymous abstract classes should be concrete")},"Implementing interfaces will preserve abstract class definition":function(){var a=this.Sut,b=this.require("interface");this.assertOk(a("TestImplExtend").implement(b({foo:[]})).extend({}).isAbstract())}})})(f["test/Class/AbstractTest"]={},"test/Class");(function(c){c.exports={};document.write("test/ClassBuilder/ConstTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("ClassBuilder");this.MethodWrapperFactory=
this.require("MethodWrapperFactory");this.wrappers=this.require("MethodWrappers").standard},setUp:function(){this.builder=this.Sut(this.require("/MemberBuilder")(this.MethodWrapperFactory(this.wrappers.wrapNew),this.MethodWrapperFactory(this.wrappers.wrapOverride),this.MethodWrapperFactory(this.wrappers.wrapProxy),this.getMock("MemberBuilderValidator")),this.require("/VisibilityObjectFactoryFactory").fromEnvironment())},"const keyword declares properties as static":function(){this.assertEqual("baz",
this.builder.build({"const foo":"baz"}).$("foo"),"Const keyword should declare properties as static")},"const keyword creates immutable property":function(){try{this.builder.build({"const foo":"bar"}).$("foo","baz")}catch(a){this.assertOk(-1!==a.message.search("foo"),"Const modification error should contain name of property");return}this.fail("Constant properties should not be writable")},"Access modifiers are permitted with const keyword":function(){var a=this.builder.build({"protected const prot":"bar",
"private   const priv":"baz","public static getProt":function(){return this.$("prot")},"public static getPriv":function(){return this.$("priv")}}),b=this.builder.build(a,{"public static getProt":function(){return this.$("prot")},"public static getPriv":function(){return this.$("priv")}});this.assertEqual(a.$("prot"),void 0,"Protected constants are not available publicly");this.assertEqual(a.$("priv"),void 0,"Private constants are not available publicly");this.assertEqual(a.getProt(),"bar","Protected constants are available internally");
this.assertEqual(a.getPriv(),"baz","Private constants are available internally");this.assertEqual(b.getProt(),"bar","Protected constants are available to subtypes internally");this.assertEqual(b.getPriv(),void 0,"Private constants are NOT available to subtypes internally")}})})(f["test/ClassBuilder/ConstTest"]={},"test/ClassBuilder");(function(c){c.exports={};document.write("test/ClassBuilder/FinalTest...<br />");g("common").testCase({caseSetUp:function(){this.Class=this.require("class");this.FinalClass=
this.require("class_final")},"Final classes are valid classes":function(){this.assertOk(this.Class.isClass(this.FinalClass({})),"Final classes should generate valid classes")},"Final classes cannot be extended":function(){try{this.FinalClass("Foo",{}).extend({})}catch(a){this.assertOk(-1!==a.message.search("Foo"),"Final class error message should contain name of class");return}this.assertFail("Should not be able to extend final classes")},"Can create final subtypes":function(){var a=this.require("ClassBuilder")(this.require("MemberBuilder")(),
this.require("VisibilityObjectFactoryFactory").fromEnvironment()).build({}),b=this.FinalClass("FinalNamed").extend(a,{}),d=this.FinalClass.extend(a,{});this.assertThrows(function(){b.extend({})},Error,"Cannot extend final named subtype");this.assertThrows(function(){d.extend({})},Error,"Cannot extend final anonymous subtype")}})})(f["test/ClassBuilder/FinalTest"]={},"test/ClassBuilder");(function(c){c.exports={};document.write("test/ClassBuilder/MemberRestrictionTest...<br />");g("common").testCase({caseSetUp:function(){this.Class=
this.require("class");this.AbstractClass=this.require("class_abstract");this.Sut=this.require("ClassBuilder");this.weak=[["weak foo","foo"],["foo","weak foo"],["weak foo","weak foo"]]},"Can retrieve a list of reserved members":function(){this.assertOk(this.Sut.getReservedMembers()instanceof Object,"Can retrieve hash of reserved members")},"Cannot modify internal reserved members list":function(){this.Sut.getReservedMembers().foo="foo";this.assertNotEqual(this.Sut.getReservedMembers().foo,"foo","Cannot alter internal list of reserved members")},
"Proper members are reserved":function(){for(var a=["__initProps","constructor"],b=a.length,d=this.Sut.getReservedMembers();b--;){var e=a[b];this.assertOk(d.hasOwnProperty(e),"Member '"+e+"' should be reserved");delete d[e]}for(var c in d)this.assertFail("Untested reserved member found: "+c)},"All reserved members are actually reserved":function(){var a=this,b=this.Sut.getReservedMembers(),d=0,e;for(e in b)this.assertThrows(function(){var b={};b[e]="";a.Class(b)},Error,"Reserved members cannot be used in class definitions as properties"),
this.assertThrows(function(){var b={};b[e]=function(){};a.Class(b)},Error,"Reserved members cannot be used in class definitions as methods"),d++;this.assertNotEqual(d,0,"Reserved memebers were tested")},"Can retrieve list of forced public methods":function(){var a=this.Sut.getForcedPublicMethods(),b=0;this.assertOk(a instanceof Object,"Can retrieve hash of forced-public methods");for(var d in a)b++;this.assertNotEqual(b,0,"Forced-public method list is not empty")},"Cannot modify internal forced public methods list":function(){this.Sut.getForcedPublicMethods().foo=
"foo";this.assertNotEqual(this.Sut.getForcedPublicMethods().foo,"foo","Cannot alter internal list of forced-public methods")},"All forced public methods are forced to public":function(){var a=this,b=this.Sut.getForcedPublicMethods(),d;for(d in b)this.assertThrows(function(){var b={};b["private "+d]=function(){};a.Class(b)},Error,"Forced-public methods must be declared as public")},"Cannot define two members of the same name":function(){var a=this;this.assertThrows(function(){a.Class({"public foo":function(){},
"protected foo":function(){}})})},"@each(weak) Can define members of the same name if one is weak":function(a){var b={};b["abstract "+a[0]]=[];b["abstract "+a[1]]=[];var d=this;this.assertDoesNotThrow(function(){d.AbstractClass(b)})},"Member builder state is ended after processing":function(){var a=this.require("MemberBuilder")(),b=this.Sut(a,this.require("VisibilityObjectFactoryFactory").fromEnvironment()),d=!1;a.end=function(){d=!0};b.build({});this.assertOk(d)}})})(f["test/ClassBuilder/MemberRestrictionTest"]=
{},"test/ClassBuilder");(function(c){c.exports={};document.write("test/ClassBuilder/StaticTest...<br />");g("common").testCase({caseSetUp:function(){this.fallback=this.require("util").definePropertyFallback();this.ClassBuilder=this.require("ClassBuilder");this.MemberBuilder=this.require("MemberBuilder");this.MethodWrapperFactory=this.require("MethodWrapperFactory");this.wrappers=this.require("MethodWrappers").standard},setUp:function(){this.builder=this.ClassBuilder(this.MemberBuilder(this.MethodWrapperFactory(this.wrappers.wrapNew),
this.MethodWrapperFactory(this.wrappers.wrapOverride),this.MethodWrapperFactory(this.wrappers.wrapProxy),this.getMock("MemberBuilderValidator")),this.require("VisibilityObjectFactoryFactory").fromEnvironment())},"Self property references class definition":function(){var a=this.builder.build({"public test":function(){return this.__self}});a.bar=["baz"];this.assertOk(a().test().bar===a.bar,"__self property references class definition")},"Static property lookup returns undefined if not found":function(){this.assertEqual(this.builder.build({}).$("foo"),
void 0,"Static property getter should return undefined if not found")},"Static property accessor is not enumerable":function(){var a=Object.getOwnPropertyDescriptor,b=this.builder.build({});this.fallback||this.assertEqual(a(b,"$").enumerable,!1,"Static property accessor method should not be enumerable")},"Public static members are accessible via class definition only":function(){var a=this.builder.build({"public static foo":"foo","static bar":"bar","public static baz":function(){return"foo"},"static foobar":function(){return"bar"}});
this.assertEqual(a.$("foo"),"foo","Public static properties should be accessible via class definition");this.assertEqual(a.$("bar"),"bar","Static properties are public by default");this.assertEqual(a.baz(),"foo","Public static methods should be accessible via class definition");this.assertEqual(a.foobar(),"bar","Static methods are public by default");this.assertEqual(a.prototype.$,void 0,"Public static properties are *not* part of the prototype")},"Public static getters/setter accessible via class dfn only":function(){if(!this.fallback){var a=
{},b=[];Object.defineProperty(a,"public static foo",{get:function(){return"baz"},set:function(){b[0]=!0},enumerable:!0});Object.defineProperty(a,"static bar",{get:function(){return"baz"},set:function(){b[1]=!0},enumerable:!0});a=this.builder.build(a);this.assertEqual(a.foo,"baz","Public static getters are accessible via class definition");a.foo="moo";this.assertEqual(b[0],!0,"Public static setters are accessible via class definition");this.assertEqual(a.bar,"baz","Static getters are public by default");
a.bar="moo";this.assertEqual(b[1],!0,"Static setters are public by default");this.assertEqual(a.prototype.foo,void 0,"Public static getters/getters are unavailable on prototype (0)");this.assertEqual(a.prototype.bar,void 0,"Public static getters/getters are unavailable on prototype (1)")}},"Static methods not bound to instance":function(){var a=null,b=this.builder.build({"public static foo":function(){a=this}});b.foo();this.assertEqual(a.foo,b.foo,"Static members are bound to class definition rather than instance")},
"Public static members are inherited by subtypes":function(){var a={"public static foo":"val","public static func":function(){},"public bla":"moo"};this.fallback||Object.defineProperty(a,"public static bar",{get:function(){},set:function(){},enumerable:!0});var b=this.builder.build(a),d=this.builder.build(b,{"public static baz":"foobar"}),a=this.builder.build(d,{});this.assertEqual(d.$("foo"),b.$("foo"),"Public static properties are inherited by subtypes");this.assertEqual(a.$("foo"),b.$("foo"),"Public static properties are inherited by sub-subtypes");
this.assertDeepEqual(d.func,b.func,"Public static methods are inherited by subtypes");this.assertDeepEqual(a.func,b.func,"Public static methods are inherited by sub-subtypes");this.assertEqual(d.$("baz"),"foobar","Subtypes contain both inherited static members as well as their own");this.fallback||(b=Object.getOwnPropertyDescriptor(b,"bar"),d=Object.getOwnPropertyDescriptor(d,"bar"),a=Object.getOwnPropertyDescriptor(a,"bar"),this.assertDeepEqual(b.get,d.get,"Public static getters are inherited by subtypes"),
this.assertDeepEqual(b.get,a.get,"Public static getters are inherited by sub-subtypes"),this.assertDeepEqual(b.set,d.set,"Public static setters are inherited by subtypes"),this.assertDeepEqual(b.set,a.set,"Public static setters are inherited by sub-subtypes"))},"Public static property references are inherited by subtypes":function(){var a=[1,2,3],b=["a","b","c"],d=this.builder.build({"public static bar":a}),e=this.builder.build(d,{});this.assertOk(e.$("bar")===d.$("bar"),"Inherited static properties should share references");
d.$("bar",b);this.assertDeepEqual(d.$("bar"),b,"Can set static property values");this.assertOk(d.$("bar")===e.$("bar"),"Setting a static property value on a supertype also sets the value on subtypes");e.$("bar",a);this.assertOk(d.$("bar")===e.$("bar"))},"Setting static props to undefined will not corrupt lookup":function(){var a=this.builder.build({"public static foo":""});a.$("foo",null);this.assertStrictEqual(a.$("foo"),null,"Static properties may be set to null");a.$("foo",void 0);this.assertStrictEqual(a.$("foo"),
void 0,"Static properties may be set to undefined");a.$("foo","baz");this.assertEqual(a.$("foo"),"baz","Setting static property to undefined does not corrupt lookup process")},"Static property setters return proper context":function(){var a=this.builder.build({"public static foo":""}),b=this.builder.build(a,{});this.assertOk(a.$("foo","val")===a,"Static property setter returns self");this.assertOk(b.$("foo","val")===b,"Static property setter returns calling class, even if property is owned by a supertype")},
"Attempting to set undeclared static prop results in exception":function(){var a=this;this.assertThrows(function(){a.builder.build({}).$("foo","val")},ReferenceError,"Attempting to set an undeclaraed static property results in an exception")},"Accessing static accessor method on non-class base also works":function(){var a=this,b=function(){},d=a.builder.build(b,{});b.$=function(){a.fail("Should not call static accessor method of non-class base")};this.assertEqual(void 0,d.$("foo"));this.assertThrows(function(){d.$("foo",
"val")},ReferenceError,"Attempting to set an undeclaraed static property results in an exception on non-class base")},"Protected static members are available inside class only":function(){var a=this.builder.build({"protected static prop":"foo","protected static baz":function(){return"foo"},"public static staticBaz":function(){return this.baz()},"public instBaz":function(){return this.__self.baz()},"public static staticGetProp":function(){return this.$("prop")},"public instGetProp":function(){return this.__self.$("prop")}});
this.assertEqual(a.baz,void 0,"Protected methods should not be accessible outside the class");this.assertEqual(a.staticBaz(),"foo","Protected methods are accessible to static methods");this.assertEqual(a().instBaz(),"foo","Protected methods are accessible to instance methods");this.assertEqual(a.staticGetProp(),"foo","Protected static properties are accessible to static methods");this.assertEqual(a().instGetProp(),"foo","Protected static properties are accessible to instance methods")},"Protected static getters/setters accessible inside class only":function(){if(!this.fallback){var a=
{"public static getProp":function(){return this.foo},"public static setProp":function(a){this.foo=a}},b=[];Object.defineProperty(a,"protected static foo",{get:function(){return"baz"},set:function(){b[0]=!0},enumerable:!0});a=this.builder.build(a);this.assertEqual(a.getProp(),"baz","Protected static getters are accessible from within the class");a.setProp("bla");this.assertEqual(b[0],!0,"Protected static setters are accessible from within the class");this.assertEqual(a.foo,void 0,"Protected static getters/getters are not public")}},
"Protected static members are inherited by subtypes":function(){var a={"protected static prop":"baz","protected static foo":function(){return"baz"}};this.fallback||(Object.defineProperty(a,"protected static bar",{get:function(){},set:function(){},enumerable:!0}),a["public static getPropDesc"]=function(a){return Object.getOwnPropertyDescriptor(this,a)});var b=this.builder.build(a),d=this.builder.build(b,{"public static bar":function(){return this.foo()},"protected static foo2":function(){return"bazbaz"},
"public static bar2":function(){return this.foo2()},"public static getProp":function(){return this.$("prop")}}),a=this.builder.build(d,{});this.assertEqual(d.bar(),"baz","Subtypes inherit parents' protected static methods");this.assertEqual(d.bar2(),"bazbaz","Static methods have access to other static methods in the same class");this.assertEqual(a.bar(),"baz","Sub-subtypes inherit parents' protected static methods");this.assertEqual(d.getProp(),"baz","Subtypes inherit parents' protected static properties");
this.assertEqual(a.getProp(),"baz","Sub-subtypes inherit parents' protected static properties");this.fallback||(b=b.getPropDesc("bar"),d=d.getPropDesc("bar"),a=a.getPropDesc("bar"),this.assertDeepEqual(b.get,d.get,"Protected static getters are inherited by subtypes"),this.assertDeepEqual(b.get,a.get,"Protected static getters are inherited by sub-subtypes"),this.assertDeepEqual(b.set,d.set,"Protected static setters are inherited by subtypes"),this.assertDeepEqual(b.set,a.set,"Protected static setters are inherited by sub-subtypes"))},
"Private static members are available inside class only":function(){var a=this.builder.build({"private static prop":"foo","private static baz":function(){return"foo"},"public static staticBaz":function(){return this.baz()},"public instBaz":function(){return this.__self.baz()},"public static staticGetProp":function(){return this.$("prop")},"public instGetProp":function(){return this.__self.$("prop")}});this.assertEqual(a.baz,void 0,"Private methods should not be accessible outside the class");this.assertEqual(a.staticBaz(),
"foo","Private methods are accessible to static methods");this.assertEqual(a().instBaz(),"foo","Private methods are accessible to instance methods");this.assertEqual(a.staticGetProp(),"foo","Private static properties are accessible to static methods");this.assertEqual(a().instGetProp(),"foo","Private static properties are accessible to instance methods")},"Private static members are not inherited by subtypes":function(){var a={"private static prop":"foo","private static priv":function(){}};this.fallback||
Object.defineProperty(a,"private static foo",{get:function(){return"foo"},set:function(){},enumerable:!0});a=this.builder.build(this.builder.build(a),{"public static getPriv":function(){return this.priv},"public static getGetSet":function(){return this.foo},"public static staticGetProp":function(){return this.$("prop")},"public instGetProp":function(){return this.__self.$("prop")}});this.assertEqual(a.getPriv(),void 0,"Private static methods should not be inherited by subtypes");this.assertEqual(a.getGetSet(),
void 0,"Private static getters/setters should not be inherited by subtypes");this.assertEqual(a().instGetProp(),void 0,"Private static properties should not be inherited by subtypes (inst)");this.assertEqual(a.staticGetProp(),void 0,"Private static properties should not be inherited by subtypes (static)")},"Private static getters/setters accessible inside class only":function(){if(!this.fallback){var a={"public static getProp":function(){return this.foo},"public static setProp":function(a){this.foo=
a}},b=[];Object.defineProperty(a,"private static foo",{get:function(){return"baz"},set:function(){b[0]=!0},enumerable:!0});a=this.builder.build(a);this.assertEqual(a.getProp(),"baz","Private static getters are accessible from within the class");a.setProp("bla");this.assertEqual(b[0],!0,"Private static setters are accessible from within the class");this.assertEqual(a.foo,void 0,"Private static getters/getters are not public")}},"Static methods can be overridden by subtypes":function(){var a=this.builder.build(this.builder.build({"public static foo":function(){},
"protected static bar":function(){}}),{"public static foo":function(){return"bar"},"public static prot":function(){return this.bar()},"protected static bar":function(){return"bar"}});this.assertEqual(a.foo(),"bar","Public static methods can be overridden by subtypes");this.assertEqual(a.prot(),"bar","Protected static methods can be overridden by subtypes")},"Cannot exploit accessor method to gain access to parent private props":function(){var a=this.builder.build({"private static foo":"bar"});this.assertEqual(this.builder.build(a,
{"public static getParentPrivate":function(){return this.$.call(a,"foo")}}).getParentPrivate(),void 0,"Cannot exploit accses modifier to gain access to parent private props")},"Cannot override static members":function(){var a=this.builder.build(this.builder.build({"public static prop":"foobaz","public static foo":function(){return this.bar()},"public static bar":function(){return"foobaz"},"public static baz":function(){return this.$("prop")}}),{"public static prop":"foobar","public static bar":function(){return"foobar"},
"public static getProp":function(){return this.$("prop")}});this.assertNotEqual(a.foo(),"foobar","System does not support overriding static methods");this.assertNotEqual(a.baz(),"foobar","System does not support overriding static properties");this.assertEqual(a.bar(),"foobar","System supports static method hiding");this.assertEqual(a.getProp(),"foobar","System supports static property hiding")},"Calls to parent static methods retain private member access":function(){var a=this.builder.build(this.builder.build({"private static _priv":"foobar",
"public static getPriv":function(){return this.$("_priv")}}),{"public static getPriv2":function(){return this.getPriv()}});this.assertEqual(a.getPriv(),"foobar","Calls to parent static methods should retain access to their own private members when called externally");this.assertEqual(a.getPriv2(),"foobar","Calls to parent static methods should retain access to their own private members when called internally")}})})(f["test/ClassBuilder/StaticTest"]={},"test/ClassBuilder");(function(c){c.exports={};
document.write("test/ClassBuilder/VisibilityTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("ClassBuilder");this.MethodWrapperFactory=this.require("MethodWrapperFactory");this.wrappers=this.require("MethodWrappers").standard;this.util=this.require("util")},setUp:function(){this.builder=this.Sut(this.require("/MemberBuilder")(this.MethodWrapperFactory(this.wrappers.wrapNew),this.MethodWrapperFactory(this.wrappers.wrapOverride),this.MethodWrapperFactory(this.wrappers.wrapProxy),
this.getMock("MemberBuilderValidator")),this.require("/VisibilityObjectFactoryFactory").fromEnvironment())},"Self property references instance rather than property object":function(){var a=null,b=null,d=this.builder.build({"public __construct":function(){a=this.__inst;b=this}})();this.assertDeepEqual(a,d,"this.__inst returns reference to actual instance");!1===this.util.definePropertyFallback()&&this.assertEqual(Object.getOwnPropertyDescriptor(b,"__inst").writable,!1,"this.__inst is not writable")}})})(f["test/ClassBuilder/VisibilityTest"]=
{},"test/ClassBuilder");(function(c){c.exports={};document.write("test/Class/ConstructorTest...<br />");g("common").testCase({setUp:function(){this.Sut=this.require("class")},"Constructor should not be invoked before instantiation":function(){var a=!1;this.Sut.extend({__construct:function(){a=!0}});this.assertNotEqual(a,!0)},"Constructor should be invoked once upon instantiation":function(){var a=0;new (this.Sut.extend({__construct:function(){a++}}));this.assertEqual(a,1)},"Constructor should be invoked within context of new instance":function(){var a=
Math.random();this.assertEqual((new (this.Sut.extend({val:null,__construct:function(){this.val=a}}))).val,a)},"Constructor arguments should be passed unchanged to __construct":function(){var a=["foo",{bar:"baz"},["moo","cow"]],b=null;new (this.Sut.extend({__construct:function(){b=Array.prototype.slice.call(arguments,0)}}))(a[0],a[1],a[2]);this.assertEqual(b.length,a.length);for(var d=a.length;d--;)this.assertStrictEqual(b[d],a[d],"Ctor argument mismatch: "+d)},"Parent constructor should be invoked for subtype if not overridden":function(){var a=
!1;new (this.Sut.extend({__construct:function(){a=!0}}).extend({}));this.assertOk(a)},"Constructor does not require `new' keyword":function(){var a=this.Sut.extend({});this.assertOk(new a instanceof a);this.assertOk(a()instanceof a)},"__construct must be public":function(){var a=this.Sut;this.assertThrows(function(){a({"protected __construct":function(){}})},TypeError,"Constructor should not be able to be protected");this.assertThrows(function(){a({"private __construct":function(){}})},TypeError,
"Constructor should not be able to be private")},"`constructor' property is properly set to class object":function(){var a=this.Sut.extend({});this.assertStrictEqual(a().constructor,a)}})})(f["test/Class/ConstructorTest"]={},"test/Class");(function(c){c.exports={};document.write("test/Class/ExtendTest...<br />");g("common").testCase({caseSetUp:function(){this.test_props={one:1,two:2};this.Sut=this.require("class");this.classes=[this.Sut.extend(this.test_props),this.Sut(this.test_props)]},"@each(classes) Created class contains extend method":function(a){this.assertOk("function"===
typeof a.extend)},"@each(classes) Subtype is returned as an object":function(a){this.assertOk(a.extend()instanceof Object)},"@each(classes) Subtype inherits parent properties":function(a){var a=a.extend(),b;for(b in this.test_props)this.assertEqual(this.test_props[b],a.prototype[b],"Missing property: "+b)},"@each(classes) Subtype contains its own properties":function(a){var b={three:3,four:4},a=(new a.extend(b))(),d;for(d in b)this.assertEqual(b[d],a[d],"Missing property: "+d)},"@each(classes) Subtypes are ECMAScript instances of their supertypes":function(a){this.assertOk(a.extend()()instanceof
a)},"@each(classes) Subtypes are easejs instances of their supertypes":function(a){a=a.extend();this.assertOk((new a).isInstanceOf(a))},"@each(classes) Objects are instances of their super-supertypes":function(a){var b=new (a.extend().extend());this.assertOk(b instanceof a&&b.isInstanceOf(a))},"@each(classes) Objects are not instances of subtypes":function(a){var b=a.extend(),a=b.extend(),b=new b;this.assertOk(!(b instanceof a)&&!b.isInstanceOf(a))},"@each(classes) Objects are not instances of sibling types":function(a){var b=
a.extend(),a=b.extend(),b=new (b.extend());this.assertOk(!(b instanceof a)&&!b.isInstanceOf(a))},"Constructor prototype is copied to subclass":function(){var a=function(){};a.prototype={foo:{}};this.assertStrictEqual(this.Sut.extend(a,{}).prototype.foo,a.prototype.foo)},"Subtype of constructor should contain extended members":function(){this.assertNotEqual((new this.Sut.extend(function(){},{foo:{}}))().foo,void 0)},"Subtypes can override parent property values":function(){this.assertEqual(this.Sut.extend({p:null}).extend({p:"ok"})().p,
"ok")},"__initProps() cannot be declared (internal method)":function(){var a=this;this.assertThrows(function(){a.Sut.extend({__initProps:function(){}})},Error)},"Invoking class module requires object as argument if extending":function(){for(var a=this,b=[5,!1,void 0],d=b.length;d--;)this.assertThrows(function(){a.Sut(b[d])},TypeError)},"Can override toString() method":function(){var a="",a=this.Sut("FooToStr",{toString:function(){return"foomookittypoo"}})().toString();this.assertEqual(a,"foomookittypoo")},
"Cannot provide duplicate member definitions using unique keys":function(){var a=this;this.assertThrows(function(){a.Sut({"protected foo":"","public foo":""})},Error);this.assertThrows(function(){a.Sut({"protected foo":function(){},"public foo":function(){}})},Error)},"__construct should not be called when extending class":function(){var a=!1;this.Sut({"public __construct":function(){a=!0}}).extend({});this.assertEqual(a,!1)},"Extending from non-ctor or non-class provides useful error":function(){try{this.Sut.extend("oops",
{})}catch(a){this.assertOk(a.message.search("extend from"),"Error message for extending from non-ctor or class makes sense");return}this.assertFail("Attempting to extend from non-ctor or class should throw exception")},"Extending object will not attempt instantiation":function(){var a={foo:"bar"};this.assertEqual(a.foo,this.Sut.extend(a,{})().foo,"Should be able to use object as prototype")},"Extending validates against non-public super-supertype methods":function(){var a=!1;this.Sut.extend({"virtual protected foo":function(){a=
!0}}).extend({}).extend({"override public foo":function(){this.__super()}})().foo();this.assertOk(a)}})})(f["test/Class/ExtendTest"]={},"test/Class");(function(c){c.exports={};document.write("test/Class/GeneralTest...<br />");g("common").testCase({setUp:function(){this.Sut=this.require("class");this.Foo=this.Sut.extend({value:"foo"})},"Class module should provide an extend method":function(){this.assertOk("function"===typeof this.Sut.extend)},"Extend method creates a new function":function(){this.assertOk("function"===
typeof this.Foo)},"Classes are considered by the system to be classes":function(){this.assertOk(this.Sut.isClass(this.Foo))},"Only actual classes are considered to be classes":function(){this.assertOk(!this.Sut.isClass({}))},"Class instances are not considered to be classes":function(){this.assertOk(!this.Sut.isClass(new this.Foo))},"Class instances are considered to be instances":function(){this.assertOk(this.Sut.isClassInstance(new this.Foo))},"Classes are not considered to be class instances":function(){this.assertOk(!this.Sut.isClassInstance(this.Foo))},
"Non-class objects are not considered to be instances":function(){this.assertOk(!this.Sut.isClassInstance({}));this.assertOk(!this.Sut.isClassInstance(new function(){}))},"Generated classes should be frozen":function(){void 0!==Object.isFrozen&&this.assertOk(Object.isFrozen(this.Foo))},"Class instance is recognized as instance of class":function(){this.assertOk(this.Sut.isInstanceOf(this.Foo,new this.Foo))},"Checking instance of undefined will not throw an error":function(){this.assertOk(!1===this.Sut.isInstanceOf(this.Foo,
void 0))},"Checking for instance of undefined will not throw an error":function(){this.assertOk(!1===this.Sut.isInstanceOf(void 0,{}))},"Class is not an instance of itself":function(){this.assertOk(!this.Sut.isInstanceOf(this.Foo,this.Foo))},"Class is not an instance of its instance":function(){this.assertOk(!this.Sut.isInstanceOf(new this.Foo,this.Foo))},"isA is an alias for isInstanceOf":function(){this.assertEqual(this.Sut.isInstanceOf,this.Sut.isA)},"Class instance has partially applied isInstanceOf method":function(){var a=
new this.Foo;this.assertOk("function"===typeof a.isInstanceOf&&!0===a.isInstanceOf(this.Foo)&&!1===a.isInstanceOf(a))},"Class instance has partially applied isA alias method":function(){var a=new this.Foo;this.assertEqual(a.isInstanceOf,a.isA)},"Class id is available via class":function(){this.assertOk(void 0!==this.Foo.__cid)},"Class id is available via class prototype":function(){this.assertOk(void 0!==this.Foo.prototype.__cid)}})})(f["test/Class/GeneralTest"]={},"test/Class");(function(c){c.exports=
{};document.write("test/Class/GetterSetterTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("class");this.util=this.require("util")},setUp:function(){this.util.definePropertyFallback()&&this.skip();var a={},b={};Object.defineProperty(a,"foo",{get:function(){return this._foo},set:function(a){this._foo=""+a},enumerable:!0});Object.defineProperty(a,"virtual bar",{get:function(){return"durp"},set:function(){},enumerable:!0});Object.defineProperty(b,"override bar",{get:function(){return this.bar2},
set:function(a){this.bar2=a},enumerable:!0});a.bar2="";this.sub=new (this.Sut.extend(a).extend(b))},"Subtypes inherit getters/setters":function(){this.sub.foo="foo";this.assertEqual(this.sub.foo,"foo")},"Subtypes should be able to override getters/setters":function(){this.sub.bar="bar";this.assertEqual(this.sub.bar,"bar");this.assertEqual(this.sub.bar2,"bar")}})})(f["test/Class/GetterSetterTest"]={},"test/Class");(function(c){c.exports={};document.write("test/Class/ImplementTest...<br />");g("common").testCase({caseSetUp:function(){this.Class=
this.require("class");this.Interface=this.require("interface");this.AbstractClass=this.require("class_abstract");this.Type=this.Interface.extend({"abstract foo":[]});this.Type2=this.Interface.extend({foo2:[]});this.PlainFoo=this.Class.extend()},"Class exports contain implement method for no base class":function(){this.assertOk(this.Class.implement instanceof Function,"Class provides method to implement interfaces")},"Clsss object contains implement method for self as base":function(){this.assertOk(this.PlainFoo.implement instanceof
Function,"Classes contain an implement() method")},"Can implement interface from an empty base":function(){var a=this;this.assertDoesNotThrow(function(){a.Class.implement(a.Type,a.Type2)},Error,"Class can implement interfaces")},"Result of implement is not usable as a class":function(){this.assertEqual(this.Class.isClass(this.Class.implement(this.Type)),!1,"Result of implement operation on class is not usable as a Class")},"Abstract methods are copied into new class using empty base":function(){var a=
this.AbstractClass.implement(this.Type,this.Type2).extend({});this.assertOk(a.prototype.foo instanceof Function&&a.prototype.foo2 instanceof Function,"Abstract methods are copied into the new class prototype (empty base)")},"Can implement interface atop an existing class":function(){var a=this;this.assertDoesNotThrow(function(){a.PlainFoo.implement(a.Type,a.Type2)},Error,"Classes can implement interfaces")},"Implementing interface atop existing class not usable by default":function(){this.assertEqual(this.Class.isClass(this.PlainFoo.implement(this.Type)),
!1,"Result of implementing interfaces on an existing base is not usable as a Class")},"Abstract method copied into new class using existing base":function(){var a=this.AbstractClass.implement(this.Type,this.Type2).extend(this.PlainFoo,{});this.assertOk(a.prototype.foo instanceof Function&&a.prototype.foo2 instanceof Function,"Abstract methods are copied into the new class prototype (concrete base)")},"Classes implementing interfaces are considered abstract by default":function(){this.assertEqual(this.AbstractClass.implement(this.Type).extend({}).isAbstract(),
!0,"Classes that implements interface(s) are considered abstract if the implemented methods have no concrete implementations")},"Instances of classes are instances of their implemented interfaces":function(){var a=this.AbstractClass.implement(this.Type,this.Type2).extend({}).extend({foo:function(){},foo2:function(){}}),b=a();this.assertOk(b.isInstanceOf(this.Type)&&b.isInstanceOf(this.Type2),"Instances of classes implementing interfaces are considered to be instances of the implemented interfaces");
this.assertEqual(a.isAbstract(),!1,"Concrete implementations are not considered to be abstract")},"Cannot specify parent after implementing atop existing class":function(){var a=this.AbstractClass.implement(this.Type,this.Type2).extend(this.PlainFoo,{});this.assertThrows(function(){this.PlainFoo.implement(this.Type,this.Type2).extend(a,{})},Error,"Cannot specify new parent for extend() when implementing from existing class")},"Can specify parent if implementing atop empty class":function(){var a=
this;this.assertDoesNotThrow(function(){a.AbstractClass.implement(a.Type).extend(a.PlainFoo,{})},Error,"Can specify parent for extend() when implementing atop an empty base")},"Throws exception if extend contains too many arguments":function(){var a=this;this.assertThrows(function(){a.Class.implement(a.Type).extend(a.PlainFoo,{},"extra")},Error,"extend() after implementing accepts no more than two args")}})})(f["test/Class/ImplementTest"]={},"test/Class");(function(c){c.exports={};document.write("test/Class/InstanceSafetyTest...<br />");
g("common").testCase({caseSetUp:function(){this.Sut=this.require("class")},"Multiple instances of same class do not share array references":function(){var a=this.Sut.extend({arr:[]}),b=new a,a=new a;b.arr.push("one");a.arr.push("two");this.assertEqual(b.arr[0],"one");this.assertEqual(a.arr[0],"two");this.assertEqual(b.arr.length,1);this.assertEqual(a.arr.length,1)},"Multiple instances of same class do not share object references":function(){var a=this.Sut.extend({obj:{}}),b=new a,a=new a;b.obj.a=
!0;a.obj.b=!0;this.assertEqual(b.obj.a,!0);this.assertEqual(b.obj.b,void 0);this.assertEqual(a.obj.a,void 0);this.assertEqual(a.obj.b,!0)},"Instances of subtypes do not share property references":function(){var a=this.Sut.extend({arr:[],obj:{}}).extend({}),b=new a,a=new a;this.assertNotEqual(b.arr!==a.arr);this.assertNotEqual(b.obj!==a.obj)}})})(f["test/Class/InstanceSafetyTest"]={},"test/Class");(function(c){c.exports={};document.write("test/Class/NameTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=
this.require("class");this.AbstractClass=this.require("class_abstract")},"Class defined with name is returned as a valid class":function(){this.assertOk(this.Sut.isClass(this.Sut("Foo",{})))},"Named class definition requires that field definition be an object":function(){try{this.Sut("Foo","Bar"),this.assertFail("Second argument to named class must be the definition")}catch(a){this.assertNotEqual(a.message.match("Foo"),null,"Error string contains class name")}},"Named class definition is strict on argument count":function(){var a=
["Foo",{},"extra"];try{this.Sut.apply(null,a),this.assertFail("Should accept only two arguments when creating named class")}catch(b){var d=b.message;this.assertNotEqual(d.match("Foo"),null,"Named class error should provide name of class");this.assertNotEqual(d.match(a.length+" given"),null,"Named class error should provide number of given arguments")}},"Converting anonymous class to string yields class string":function(){this.assertEqual(this.Sut({}).toString(),"(Class)")},"Converting abstract anonymous class to string yields class string":function(){this.assertEqual(this.AbstractClass({"abstract foo":[]}).toString(),
"(AbstractClass)")},"Converting named class to string yields string containing name":function(){this.assertEqual(this.Sut("Foo",{}).toString(),"Foo");this.assertEqual(this.AbstractClass("Foo",{"abstract foo":[]}).toString(),"Foo")},"Converting class instance to string yields instance string":function(){var a=this.Sut({})(),b=this.Sut("Foo",{})();this.assertEqual(a.toString(),"#<anonymous>");this.assertEqual(b.toString(),"#<Foo>")},"Can create named class using staging method":function(){var a=this.Sut("Foo").extend({});
this.assertEqual(this.Sut.isClass(a),!0,"Named class generated via staging method is considered to be a valid class");this.assertEqual(a.toString(),"Foo","Name is set on named clas via staging method")},"Can implement interfaces using staging method":function(){var a=this.require("interface"),a=this.Sut("Foo").implement(a({})).extend({});this.assertEqual(this.Sut.isClass(a),!0,"Named class generated via staging method, implementing an interface, is considered to be a valid class");this.assertEqual(a.toString(),
"Foo","Name is set on named class via staging method when implementing")},"Can extend existing classes using staging method":function(){var a=this.Sut("Foo").extend({}),b=this.Sut("Foo").extend(a,{});this.assertEqual(this.Sut.isClass(b),!0);this.assertOk(this.Sut.isInstanceOf(a,b()));this.assertEqual(b.toString(),"Foo")},"Class name is given when attempting to instantiate abstract class":function(){try{this.Sut("Foo",{"abstract foo":[]})(),this.assertFail("Was expecting instantiation error; there's a bug somewhere")}catch(a){this.assertNotEqual(a.message.match("Foo"),
null,"Abstract class instantiation error should contain class name")}try{this.Sut({"abstract foo":[]})(),this.assertFail("Was expecting instantiation error; there's a bug somewhere")}catch(b){this.assertNotEqual(b.message.match("(anonymous)"),null,"Abstract class instantiation error should recognize that class is anonymous if no name was given")}}})})(f["test/Class/NameTest"]={},"test/Class");(function(c){c.exports={};document.write("test/Class/ParentTest...<br />");g("common").testCase({setUp:function(){this.Sut=
this.require("class")},"Subtype does not invoke overridden parent method by default":function(){var a=!1;this.Sut({"virtual foo":function(){a=!0}}).extend({"override foo":function(){}})().foo();this.assertOk(!a)},"Subtype can invoke parent method with arguments":function(){var a=null;this.Sut({"virtual foo":function(b,d){a=[b,d]}}).extend({"override foo":function(a,d){this.__super(a,d)}})().foo("foobar","baz");this.assertNotEqual(a,null);this.assertEqual(a[0],"foobar");this.assertEqual(a[1],"baz")}})})(f["test/Class/ParentTest"]=
{},"test/Class");(function(c){c.exports={};document.write("test/Class/VisibilityTest...<br />");var a=function(){return"foo"},b=function(){return"bar"},d=function(){return"baz"};g("common").testCase({caseSetUp:function(){this.Class=this.require("class");this.Interface=this.require("interface");this.util=this.require("util");this.Foo=this.Class.extend({"public pub":"foo","protected peeps":"bar","private parts":"baz","public pubf":a,"protected protf":b,"private privf":d,"virtual public getProp":function(a){return this[a]},
"public nonOverrideGetProp":function(a){return this[a]},"public setValue":function(a,b){this[a]=b},"public getSelf":function(){return this},"virtual public getSelfOverride":function(){},"public getPrivProp":function(){return this.parts},"public invokePriv":function(){return this._priv()},"private _priv":function(){return"baz"}});this.SubFoo=this.Foo.extend({"private _pfoo":"baz","override public getSelfOverride":function(){return this},"override public getProp":function(a){return this[a]},"private myOwnPrivateFoo":function(){}})},
setUp:function(){this.foo=this.Foo();this.sub_foo=this.SubFoo()},"Public members are accessible externally":function(){this.assertEqual(this.foo.pub,"foo","Public properties are accessible via public interface");this.assertEqual(this.foo.pubf(),"foo","Public methods are accessible via public interface")},"Public members are accessible internally":function(){this.assertEqual(this.foo.getProp("pub"),"foo","Public properties are accessible internally");this.assertEqual(this.foo.getProp("pubf")(),"foo",
"Public methods are accessible internally")},"Public properties are writable internally":function(){this.foo.setValue("pub","moomookittypoo");this.assertEqual(this.foo.getProp("pub"),"moomookittypoo","Setting the value of a public property internally should be observable /internally/");this.assertEqual(this.foo.pub,"moomookittypoo","Setting the value of a public property internally should be observable /externally/")},"Protected and private members are not accessible externally":function(){this.util.definePropertyFallback()||
(this.assertEqual(this.foo.peeps,void 0,"Protected properties are inaccessible via public interface"),this.assertEqual(this.foo.parts,void 0,"Private properties are inaccessible via public interface"),this.assertEqual(this.foo.protf,void 0,"Protected methods are inaccessible via public interface"),this.assertEqual(this.foo.privf,void 0,"Private methods are inaccessible via public interface"))},"Protected members are accessible internally":function(){this.assertEqual(this.foo.getProp("peeps"),"bar",
"Protected properties are available internally");this.assertEqual(this.foo.getProp("protf")(),"bar","Protected methods are available internally")},"Private members are accessible internally":function(){this.assertEqual(this.foo.getProp("parts"),"baz","Private properties are available internally");this.assertEqual(this.foo.getProp("privf")(),"baz","Private methods are available internally")},"Protected members are inherited from parent":function(){this.assertEqual(this.sub_foo.getProp("peeps"),"bar",
"Protected properties are available to subtypes");this.assertEqual(this.sub_foo.getProp("protf")(),"bar","Protected methods are available to subtypes")},"Private members of supertypes are inaccessible to subtypes":function(){this.util.definePropertyFallback()||(this.assertEqual(this.sub_foo.getProp("parts"),void 0,"Private properties of supertypes should be unavailable to subtypes"),this.assertEqual(this.sub_foo.getProp("privf"),void 0,"Private methods of supertypes should be unavailable to subtypes"))},
"Protected members are not shared between class instances":function(){this.foo.setValue("prot","foobar");this.assertNotEqual(this.sub_foo.getProp("prot"),"foobar","Class instances do not share protected values (subtype)");this.SubFoo().setValue("prot","foobar");this.assertNotEqual(this.sub_foo.getProp("prot"),"foobar","Class instances do not share protected values (same type)")},"Returning self from method should return instance not prop obj":function(){this.assertDeepEqual(this.foo.getSelf(),this.foo,
"Returning 'this' from a method should return instance of self");this.assertDeepEqual(this.sub_foo.getSelf(),this.sub_foo,"Returning 'this' from a super method should return the subtype");this.assertDeepEqual(this.sub_foo.getSelfOverride(),this.sub_foo,"Returning 'this' from a overridden method should return subtype")},"Parent methods can access private members of parent":function(){this.assertEqual(this.sub_foo.getPrivProp(),"baz","Parent methods should have access to the private properties of the parent");
this.assertEqual(this.sub_foo.invokePriv(),"baz","Parent methods should have access to the private methods of the parent");var a=this.SubFoo.extend({})();this.assertEqual(a.getPrivProp(),"baz","Parent methods should have access to the private properties of the parent (2)");this.assertEqual(a.invokePriv(),"baz","Parent methods should have access to the private methods of the parent (2)")},"Parents should not have access to private members of subtypes":function(){this.util.definePropertyFallback()||
(this.assertEqual(this.sub_foo.nonOverrideGetProp("_pfoo"),void 0,"Parent should not have access to private properties of subtype whena parent method is invoked"),this.assertEqual(this.sub_foo.nonOverrideGetProp("_myOwnPrivateFoo"),void 0,"Parent should not have access to private methods of subtype when a parent method is invoked"))},"Can escalate member visibility":function(){var a=this;this.assertDoesNotThrow(function(){a.Class({"protected foo":"bar","virtual protected baz":function(){}}).extend({"public foo":"bar",
"override public baz":function(){}})},Error,"Can escalate visibility of subtype members");this.assertDoesNotThrow(function(){a.Class({"protected foo":"bar","virtual protected baz":function(){}}).extend({"protected foo":"bar","override protected baz":function(){}})},Error,"Can retain level of visibility for subtype members")},"Cannot de-escalate member visibility":function(){var a=this;this.assertThrows(function(){a.Class({"public foo":"bar"}).extend({"protected foo":"bar"})},Error,"Cannot de-escalate visibility of sub-props to protected");
this.assertThrows(function(){a.Class({"virtual public baz":function(){}}).extend({"protected baz":function(){}})},Error,"Cannot de-escalate visibility of sub-methods to protected");this.assertThrows(function(){a.Class({"public foo":"bar"}).extend({"private foo":"bar"})},Error,"Cannot de-escalate visibility of subtype props to private");this.assertThrows(function(){a.Class({"virtual public baz":function(){}}).extend({"private baz":function(){}})},Error,"Cannot de-escalate visibility of sub-methods to private");
this.assertThrows(function(){a.Class({"protected foo":"bar"}).extend({"private foo":"bar"})},Error,"Cannot de-escalate visibility of sub-props to private2");this.assertThrows(function(){a.Class({"virtual protected baz":function(){}}).extend({"private baz":function(){}})},Error,"Cannot de-escalate visibility of sub-methods to private2")},"Calling super method works properly with protected methods":function(){this.assertEqual(this.Class({"virtual protected foo":function(){return"foobar"}}).extend({"override public foo":function(){return this.__super()}})().foo(),
"foobar","__super() calls work with protected overrides")},"Visibility de-escalation rulse apply to interfaces":function(){var a=this;this.assertThrows(function(){Class.implement(a.Interface({"abstract public foo":[]})).extend({"protected foo":function(){}})},Error,"Cannot de-escalate visibility for interface members")},"Can override protected method functionality with public":function(){this.assertEqual(this.Class({"virtual protected foo":function(){return!1}}).extend({"override public foo":function(){return!0}})().foo(),
!0,"Can properly override protected methods with public")},"Protected method overrides are observable by supertype":function(){var a=this,b=!1;this.Class({"public doFoo":function(){return this.foo()},"virtual protected foo":function(){a.fail(!0,!1,"Method not overridden")}}).extend({"public override foo":function(){b=!0}})().doFoo();this.assertOk(b)},"Protected values are available to subtypes when set by parent":function(){this.assertEqual(this.Class({"protected val":0,"public __construct":function(){this.val=
5}}).extend({"public getVal":function(){return this.val}})().getVal(),5,"Subtypes should have acess to protected properties values set by super methods")},"Can properly override protected with protected":function(){this.assertEqual(this.Class({"virtual protected foo":function(){}}).extend({"override protected foo":function(){return"foobar"},"public doFoo":function(){return this.foo()}})().doFoo(),"foobar","Protected methods can properly be overriden by another protected method")}})})(f["test/Class/VisibilityTest"]=
{},"test/Class");(function(c){c.exports={};document.write("test/FallbackMemberBuilderTest...<br />");g("./common").testCase({setUp:function(){var a=this.require("MethodWrapperFactory")(function(a){return a});this.sut=this.require("FallbackMemberBuilder")(a,a)},"Inherits from MemberBuilder":function(){this.assertOk(this.sut instanceof this.require("MemberBuilder"),"FallbackMemberBuilder should inherit from MemberBuilder")},"buildGetterSetter() method throws an exception":function(){try{this.sut.buildGetterSetter(),
this.fail("Exception should have been called (getter/setter)")}catch(a){this.assertOk(a.message.match(/unsupported/),"Incorrect exception thrown (getter/setter)")}}})})(f["test/FallbackMemberBuilderTest"]={},"test");(function(c){c.exports={};document.write("test/FallbackVisibilityObjectFactoryTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("FallbackVisibilityObjectFactory");this.VisibilityObjectFactory=this.require("VisibilityObjectFactory");this.props=this.methods=
{"public":{},"protected":{},"private":{}}},"Can instantiate with and without `new` keyword":function(){this.assertOk(new this.Sut instanceof this.Sut,"Should be able to instantiate FallbackVisibilityObjectFactory with 'new' keyword");this.assertOk(this.Sut()instanceof this.Sut,"Should be able to instantiate FallbackVisibilityObjectFactory without 'new' keyword")},"Inherits from visibility object factory":function(){this.assertOk(this.Sut()instanceof this.VisibilityObjectFactory,"Fallback should inherit from VisibilityObjectFactory")},
"Setup method should not add private layer":function(){var a={},b=this.Sut().setup(a,this.props,this.methods);this.assertStrictEqual(a,b,"Private visibility layer is not added atop destination")},"Creating property proxy should simply return self":function(){var a={};this.assertStrictEqual(this.Sut().createPropProxy(a,{},this.props),a,"Creating property proxy should simply return original object")}})})(f["test/FallbackVisibilityObjectFactoryTest"]={},"test");(function(c){c.exports={};document.write("test/Interface/ExtendTest...<br />");
var c=g("common"),a=c.require("interface"),b=!c.require("util").definePropertyFallback();c.testCase({caseSetUp:function(){this.baseTypes=[a.extend({method:[]}),a({method:[]})];this.invalidExtend=["moo",5,!1,void 0];this.badAm=["protected","private"]},"Properties are not permitted within interfaces":function(){this.assertThrows(function(){a.extend({prop:"not permitted"})},TypeError,"Properties are not permitted within Interface definitions")},"Getters are setters are not permitted within intefaces":function(){if(b){var d=
{};Object.defineProperty(d,"foo",{get:function(){},set:function(){},enumerable:!0});this.assertThrows(function(){a.extend(d)},TypeError,"Getters/setters not permitted within Interfaces")}},"Concrete methods are not permitted":function(){this.assertThrows(function(){a.extend({method:function(){}})},TypeError,"Concrete methods are not permitted within Interface definitions")},"Method declarations (using arrays) are permitted":function(){this.assertDoesNotThrow(function(){a.extend({method:[]})},TypeError,
"Abstract method declarations are allowed within Interface definitions")},"@each(baseTypes) Interface contains defined abstract methods":function(a){this.assertOk("function"===typeof a.prototype.method,"Interface should contain defined abstract methods")},"@each(baseTypes) Result is considered to be an interface":function(b){this.assertEqual(a.isInterface(b),!0)},"@each(baseTypes) Can extend interface using Interface.extend()":function(b){this.assertOk(a.extend(b,{}).prototype instanceof b,"Generic interface extend method should be able to extend from other interfaces")},
"@each(baseTypes) Interface subtypes inherit abstract methods":function(b){this.assertOk(a.extend(b,{}).prototype.method===b.prototype.method,"Interface subtypes inherit abstract methods")},"@each(baseTypes) Interfaces can extend the API with abstract methods":function(b){this.assertOk("function"===typeof a.extend(b,{second:[]}).prototype.second,"Should be able to extend interfaces with additional abstract methods")},"@each(baseTypes) Interfaces contain an extend() method":function(a){this.assertOk("function"===
typeof a.extend,"Interface should contain extend() method")},"@each(baseTypes) extend() method on interface itself can extend":function(a){this.assertOk(a.extend({}).prototype instanceof a,"Interface extend method can extend interfaces")},"@each(baseTypes) Interface's extend() method can add to the API":function(a){this.assertOk("function"===typeof a.extend({second:[]}).prototype.second,"Interfaces should be able to be extended with additional abstract methods using shorthand extend method")},"@each(invalidExtend) Invoking module to extend requires object":function(b){this.assertThrows(function(){a(b)},
TypeError,"Invoking interface module should require object as argument if extending from base interface")},"Only one argment for interface definitions is permitted":function(){var b=[{},"one","two","three"];try{a.apply(null,b),this.fail("Only one argument for interface definitions should be permitted")}catch(e){this.assertOk(-1<e.message.search(b.length+" given"),"Interface invocation should give argument count on error")}},"@each(badAm) Interface members must be public":function(b){this.assertThrows(function(){var e=
{};e[b+" foo"]=[];a(e)},Error,"Interface members should not be able to be "+b)},"Interfaces can only extend interfaces":function(){this.assertThrows(function(){a.extend(function(){},{})},TypeError,"Should not be able to extend from non-interface")}})})(f["test/Interface/ExtendTest"]={},"test/Interface");(function(c){c.exports={};document.write("test/Interface/GeneralTest...<br />");g("common").testCase({setUp:function(){this.FooType=this.require("interface").extend()},"Interface extend method creates a new interface object":function(){this.assertOk("function"===
typeof this.FooType,"Interface extend method creates a new interface object")},"Interfaces cannot be instantiated":function(){this.assertThrows(function(){new this.FooType},Error,"Should not be able to instantiate interfaces")},"Generated interface should be frozen":function(){Object.isFrozen&&this.assertEqual(Object.isFrozen(this.FooType),!0,"Generated interface object should be frozen")}})})(f["test/Interface/GeneralTest"]={},"test/Interface");(function(c){c.exports={};document.write("test/Interface/NameTest...<br />");
g("common").testCase({caseSetUp:function(){this.Sut=this.require("interface");this.util=this.require("util")},"Interface accepts name":function(){var a=this;this.assertDoesNotThrow(function(){var b=a.Sut("Foo",{});a.assertOk(a.Sut.isInterface(b))},Error)},"Named interface definition requires that definition be an object":function(){try{this.Sut("Foo","Bar"),this.assertFail("Second argument to named interface must be the definition")}catch(a){this.assertNotEqual(a.message.match("Foo"),null,"Interface definition argument count error string contains interface name")}},
"Named interface definition is strict on argument count":function(){var a=["Foo",{},"extra"];try{this.Sut.apply(null,a),assert.fail("Should accept only two arguments when creating named interface")}catch(b){var d=b.message;this.assertNotEqual(d.match("Foo"),null,"Named interface error should provide interface name");this.assertNotEqual(d.match(a.length+" given"),null,"Named interface error should provide number of given arguments")}},"Converting anonymous interface to string yields generic string":function(){this.assertEqual(this.Sut({}).toString(),
"[object Interface]")},"Converting named interface to string yields string containing name":function(){this.assertEqual(this.Sut("Foo",{}).toString(),"[object Interface <Foo>]")},"Declaration errors provide interface name if avaiable":function(){var a=this.Sut,b=[function(){a("Foo",{prop:"str"})},function(){a("Foo",{method:function(){}})}];this.util.definePropertyFallback()||(b.push(function(){var b={};Object.defineProperty(b,"getter",{get:function(){},enumerable:!0});a("Foo",b)}),b.push(function(){var b=
{};Object.defineProperty(b,"setter",{set:function(){},enumerable:!0});a("Foo",b)}));for(var d=b.length;d--;){try{b[d]()}catch(e){this.assertNotEqual(e.message.match("Foo"),null,"Error contains interface name when available ("+d+")");break}this.assertFail("Expected error. Something's wrong: "+d)}},"Interface name is included in instantiation error":function(){try{this.Sut("Foo")(),this.assertFail("Exception expected. There's a bug somewhere.")}catch(a){this.assertNotEqual(a.message.match("Foo"),null,
"Interface name is included in instantiation error message")}}})})(f["test/Interface/NameTest"]={},"test/Interface");(function(c,a){c.exports={};document.write("test/MemberBuilder/GetterSetterTest...<br />");var b=g("common"),d=g(a+"/inc-common"),e=!b.require("util").definePropertyFallback();g("common").testCase({caseSetUp:function(){var a=this;this.testArgs=function(b,e,c,f,g){d.testArgs(a,b,e,c,f,g,function(b,d,c){var i=a.members["public"][e];return!i?b:{value:{expected:i,given:d.member},keywords:{expected:null,
given:c}}})}},setUp:function(){var a=this.require("MethodWrapperFactory")(function(a){return a});this.sut=this.require("MemberBuilder")(a,a,a,this.mockValidate=this.getMock("MemberBuilderValidator"));this.members=this.sut.initMembers()},"Passes proper data to validator when not overriding":function(){e||this.skip();var a=this,b=!1,d={};this.mockValidate.validateGetterSetter=function(){b=!0;a.testArgs(arguments,"foo",{},d)};this.sut.buildGetterSetter(this.members,{},"foo",function(){},function(){},
d,{});this.assertEqual(!0,b,"validateGetterSetter() was not called")},"Passes proper data to validator when overriding":function(){e||this.skip();var a=this,b=!1,d={};this.members["public"].foo={};this.mockValidate.validateGetterSetter=function(){b=!0;a.testArgs(arguments,"foo",{},d)};this.sut.buildGetterSetter(this.members,{},"foo",function(){},function(){},d,{});this.assertEqual(!0,b,"validateGetterSetter() was not called")}})})(f["test/MemberBuilder/GetterSetterTest"]={},"test/MemberBuilder");
(function(c,a){c.exports={};document.write("test/MemberBuilder/MethodTest...<br />");var b=g(a+"/inc-common");g("common").testCase({caseSetUp:function(){var a=this;this.testArgs=function(e,c,i,f,g){b.testArgs(a,e,c,i,f,g,function(b,e,i){var f=a.members["public"][c];return!f?b:{value:{expected:f,given:e.member},keywords:{expected:f.___$$keywords$$,given:i}}})};this.weakab=[]},setUp:function(){var a=this,b=this.require("MethodWrapperFactory")(function(a){return a}),c=this.require("MethodWrapperFactory")(function(){a.proxyFactoryCall=
arguments;return a.proxyReturnValue});this.proxyFactoryCall=null;this.proxyReturnValue=function(){};this.sut=this.require("MemberBuilder")(b,b,c,this.mockValidate=this.getMock("MemberBuilderValidator"));this.members=this.sut.initMembers()},"Passes proper data to validator when not overriding":function(){var a=this,b=!1,c=function(){},i={},f={};this.mockValidate.validateMethod=function(){b=!0;a.testArgs(arguments,"foo",c,f,i)};this.assertOk(this.sut.buildMethod(this.members,{},"foo",c,f,function(){},
1,{},i));this.assertEqual(!0,b,"validateMethod() was not called")},"Passes proper data to validator when overriding":function(){var a=this,b=!1,c=function(){},i={override:!0};(this.members["public"].foo=function(){}).___$$keywords$$={"public":!0};this.mockValidate.validateMethod=function(){b=!0;a.testArgs(arguments,"foo",c,i)};this.assertOk(this.sut.buildMethod(this.members,{},"foo",c,i,function(){},1,{}));this.assertEqual(!0,b,"validateMethod() was not called")},"Creates proxy when `proxy' keyword is given":function(){var a=
{proxy:!0},b=function(){};this.assertOk(this.sut.buildMethod(this.members,{},"foo","bar",a,b,1,{}));this.assertNotEqual(null,this.proxyFactoryCall,"Proxy factory should be used when `proxy' keyword is provided");this.assertDeepEqual(["bar",null,1,b,"foo",a],this.proxyFactoryCall,"Proxy factory should be called with proper arguments");this.assertStrictEqual(this.proxyReturnValue,this.members["public"].foo,"Generated proxy method should be properly assigned to members")},"Weak abstract methods are not processed if concrete is available":function(){var a=
!1,b=[],c={weak:!0,"abstract":!0},i=function(){};this.assertOk(this.sut.buildMethod(this.members,{},"foo",b,c,i,1,{}));this.assertOk(this.sut.buildMethod(this.members,{},"foo",function(){a=!0},{},i,1,{}));this.members["public"].foo();this.assertOk(a,"Concrete method did not take precedence");this.assertOk(!1===this.sut.buildMethod(this.members,{},"foo",b,c,i,1,{}));this.members["public"].foo();this.assertOk(a,"Concrete method unkept")},"Weak virtual methods are not processed if override is available":function(){var a=
this,b=!1,c=function(){a.fail(!0,!1,"Method not overridden.")},i={weak:!0,virtual:!0},f=function(){};this.assertOk(this.sut.buildMethod(this.members,{},"foo",c,i,f,1,{}));this.assertOk(this.sut.buildMethod(this.members,{},"foo",function(){b=!0},{override:!0},f,1,{}));this.members["public"].foo();this.assertOk(b,"Override did not take precedence");this.assertOk(!1===this.sut.buildMethod(this.members,{},"foo",c,i,f,1,{}));this.members["public"].foo();this.assertOk(b,"Override unkept")}})})(f["test/MemberBuilder/MethodTest"]=
{},"test/MemberBuilder");(function(c,a){c.exports={};document.write("test/MemberBuilder/PropTest...<br />");var b=g(a+"/inc-common");g("common").testCase({caseSetUp:function(){var a=this;this.testArgs=function(e,c,i,f,g){b.testArgs(a,e,c,i,f,g,function(b,e,i){var f=a.members["public"][c];return!f?b:{value:{expected:f[0],given:e.member[0]},keywords:{expected:f[1],given:i}}})}},setUp:function(){var a=this.require("MethodWrapperFactory")(function(a){return a});this.sut=this.require("MemberBuilder")(a,
a,a,this.mockValidate=this.getMock("MemberBuilderValidator"));this.members=this.sut.initMembers()},"Passes proper data to validator when not overriding":function(){var a=this,b=!1,c={};this.mockValidate.validateProperty=function(){b=!0;a.testArgs(arguments,"foo","bar",c)};this.sut.buildProp(this.members,{},"foo","bar",c,{});this.assertEqual(!0,b,"validateProperty() was not called")},"Passes proper data to validator when overriding":function(){var a=this,b=!1,c={};this.members["public"].foo=["prev",
{"public":!0}];this.mockValidate.validateProperty=function(){b=!0;a.testArgs(arguments,"foo","bar2",c)};this.sut.buildProp(this.members,{},"foo","bar2",c,{});this.assertEqual(!0,b,"validateProperty() was not called")}})})(f["test/MemberBuilder/PropTest"]={},"test/MemberBuilder");(function(c,a){c.exports={};document.write("test/MemberBuilderValidator/GetterSetterTest...<br />");var b=g(a+"/inc-common");g("common").testCase({caseSetUp:function(){var a=this;this.quickFailureTest=function(){b.quickFailureTest.apply(a,
arguments)};this.quickKeywordTest=function(a,d,c){b.quickKeywordTest.call(this,"validateGetterSetter",a,d,c,c&&{get:function(){},set:function(){}})};this.quickVisChangeTest=function(e,c,f,g){b.quickVisChangeTest.call(a,e,c,f,function(b,e,c){e.virtual=!0;c.override=!0;a.sut.validateGetterSetter(b,{},c,{get:function(){},set:function(){}},e)},g)}},setUp:function(){var a=this;this.warningHandler=function(){};this.sut=this.require("MemberBuilderValidator")(function(b){a.warningHandler(b)})},"Cannot override method with getter or setter":function(){var a=
this;this.quickFailureTest("foo","method",function(){a.sut.validateGetterSetter("foo",{},{},{member:function(){}})})},"Cannot override property with getter or setter":function(){var a=this;this.quickFailureTest("foo","method",function(){a.sut.validateGetterSetter("foo",{},{},{member:"foo"})})},"Getters/setters do not support visibility de-escalation":function(){this.quickVisChangeTest("public","protected",!0);this.quickVisChangeTest("protected","private",!0)},"Getters/setters support visibility escalation and equality":function(){var a=
this;b.visEscalationTest(function(b){a.quickVisChangeTest(b[0],b[1],!1)})},"Cannot redeclare private getters/setters in subtypes":function(){var a=this;b.privateNamingConflictTest(function(b){a.quickVisChangeTest(b[0],b[1],!0,"conflict")})},"Cannot declare abstract getters/setters":function(){this.quickKeywordTest(["abstract"],"abstract")},"Cannot declare const getters/setters":function(){this.quickKeywordTest(["const"],"const")},"Can override virtual getter/setter with override keyword":function(){this.quickKeywordTest(["override"],
null,["virtual"])},"Must provide override keyword when overriding getter/setter":function(){this.quickKeywordTest([],"override",["virtual"])},"Cannot override non-virtual getter/setter":function(){this.quickKeywordTest(["override"],"non-virtual",[])},"Can declare getter/setter as static":function(){this.quickKeywordTest(["static"])},"Cannot declare getter/setter as both static and virtual":function(){this.quickKeywordTest(["static","virtual"],"static")},"Throws warning when using override with no super getter/setter":function(){var a=
null;this.warningHandler=function(b){a=b};this.quickKeywordTest(["override"]);this.assertNotEqual(null,a,"No warning was provided");this.assertOk(a instanceof Error,"Provided warning is not of type Error");this.assertOk(-1<a.message.search(b.testName),"Override warning should contain getter/setter name")}})})(f["test/MemberBuilderValidator/GetterSetterTest"]={},"test/MemberBuilderValidator");(function(c,a){c.exports={};document.write("test/MemberBuilderValidator/MethodTest...<br />");var b=g(a+"/inc-common");
g("common").testCase({caseSetUp:function(){var a=this;this.util=this.require("util");this.quickKeywordMethodTest=function(a,d,c){b.quickKeywordTest.call(this,"validateMethod",a,d,c)};this.quickFailureTest=function(){b.quickFailureTest.apply(a,arguments)};this.quickVisChangeTest=function(e,c,f,g){b.quickVisChangeTest.call(a,e,c,f,function(b,e,c){e.virtual=!0;c.override=!0;var h={};a.sut.validateMethod(b,function(){},c,{member:function(){}},e,h);a.sut.end(h)},g)}},setUp:function(){var a=this;this.warningHandler=
function(){};this.sut=this.require("MemberBuilderValidator")(function(b){a.warningHandler(b)})},"Method cannot be both private and abstract":function(){this.quickKeywordMethodTest(["private","abstract"],"private and abstract")},"Methods cannot be declared const":function(){this.quickKeywordMethodTest(["const"],"const")},"Method cannot be both virtual and static":function(){this.quickKeywordMethodTest(["virtual","static"],"static")},"Cannot override getter/setter with method":function(){var a=this;
this.quickFailureTest("foo","getter/setter",function(){a.sut.validateMethod("foo",function(){},{},{get:function(){}},{},{})});this.quickFailureTest("foo","getter/setter",function(){a.sut.validateMethod("foo",function(){},{},{set:function(){}},{},{})})},"Cannot override property with method":function(){var a=this;this.quickFailureTest("foo","property",function(){a.sut.validateMethod("foo",function(){},{},{member:"immaprop"},{},{})})},"Cannot override non-virtual methods":function(){this.quickKeywordMethodTest(["override"],
"non-virtual",[])},"Can override virtual method with concrete method":function(){this.quickKeywordMethodTest(["override"],null,["virtual"])},"Can declare override as virtual":function(){this.quickKeywordMethodTest(["virtual","override"])},"Cannot override concrete method with abstract method":function(){this.quickKeywordMethodTest(["abstract"],"concrete",[])},"Concrete method may appear with weak abstract method":function(){this.quickKeywordMethodTest(["weak","abstract"],null,[])},"Override parameter list must match or exceed parent length":function(){var a=
this;this.quickFailureTest("foo","compatible",function(){a.sut.validateMethod("foo",function(){},{override:!0},{member:function(a,b,d){return[a,b,d]}},{virtual:!0},{})});this.quickFailureTest("foo","compatible",function(){var b=function(){};b.__length=3;a.sut.validateMethod("foo",function(){},{override:!0},{member:b},{virtual:!0},{})});this.assertDoesNotThrow(function(){var b=function(){};b.__length=3;a.sut.validateMethod("foo",b,{override:!0},{member:function(){}},{virtual:!0},{})},Error)},"Weak abstract overrides must meet compatibility requirements":function(){var a=
this,b=a.util.createAbstractMethod(["one"]);this.quickFailureTest("foo","compatible",function(){a.sut.validateMethod("foo",function(){},{},{member:b},{weak:!0,"abstract":!0},{})});this.quickFailureTest("foo","compatible",function(){a.sut.validateMethod("foo",b,{weak:!0,"abstract":!0},{member:function(){}},{},{})})},"Methods do not support visibiliy de-escalation":function(){this.quickVisChangeTest("public","protected",!0);this.quickVisChangeTest("protected","private",!0)},"Methods support visibility escalation or equality":function(){var a=
this;b.visEscalationTest(function(b){a.quickVisChangeTest(b[0],b[1],!1)})},'Must provide "override" keyword when overriding methods':function(){this.quickKeywordMethodTest([],"override",[])},"Can provide abstract method impl. without override keyword":function(){this.quickKeywordMethodTest([],null,["abstract"])},"Throws warning when using override with no super method":function(){var a=null;this.warningHandler=function(b){a=b};this.quickKeywordMethodTest(["override"]);this.assertNotEqual(null,a,"No warning was provided");
this.assertOk(a instanceof Error,"Provided warning is not of type Error");this.assertOk(-1<a.message.search(b.testName),"Override warning should contain method name")},"Does not throw warning when overriding a later weak method":function(){var a=this;this.warningHandler=function(){a.fail(!0,!1,"Warning was issued.")};this.assertDoesNotThrow(function(){var b={};a.sut.validateMethod("foo",function(){},{override:!0},void 0,void 0,b);a.sut.validateMethod("foo",function(){},{weak:!0,"abstract":!0},{member:function(){}},
{override:!0},b);a.sut.end(b)})},"Cannot redeclare private members in subtypes":function(){var a=this;b.privateNamingConflictTest(function(b){a.quickVisChangeTest(b[0],b[1],!0,"conflict")})},"`proxy' keyword must provide string value":function(){var a=this;this.quickFailureTest("foo","string value expected",function(){a.sut.validateMethod("foo",function(){},{proxy:!0},{},{},{})})},"`proxy' keyword can provide string value":function(){var a=this;this.assertDoesNotThrow(function(){a.sut.validateMethod("foo",
"dest",{proxy:!0},{},{},{})},TypeError)},"Method proxy cannot be abstract":function(){this.quickKeywordMethodTest(["proxy","abstract"],"cannot be abstract")}})})(f["test/MemberBuilderValidator/MethodTest"]={},"test/MemberBuilderValidator");(function(c,a){c.exports={};document.write("test/MemberBuilderValidator/PropertyTest...<br />");var b=g(a+"/inc-common");g("common").testCase({caseSetUp:function(){var a=this;this.quickFailureTest=function(){b.quickFailureTest.apply(a,arguments)};this.quickKeywordPropTest=
function(a,d,c){b.quickKeywordTest.call(this,"validateProperty",a,d,c)};this.quickVisChangeTest=function(c,h,f,g){b.quickVisChangeTest.call(a,c,h,f,function(b,c,e){a.sut.validateProperty(b,"bar",e,{member:"foo"},c)},g)}},setUp:function(){this.sut=this.require("MemberBuilderValidator")()},"Cannot override method with property":function(){var a=this;this.quickFailureTest("foo","property",function(){a.sut.validateProperty("foo","bar",{},{member:function(){}},{})})},"Cannot declare abstract property":function(){this.quickKeywordPropTest(["abstract"],
"abstract")},"Cannot declare virtual property":function(){this.quickKeywordPropTest(["virtual"],"virtual")},"Cannot declare static const property":function(){this.quickKeywordPropTest(["static","const"],"Static")},"Cannot override getter/setter with property":function(){var a=this;this.quickFailureTest("foo","getter/setter",function(){a.sut.validateProperty("foo","bar",{},{get:function(){}},{})});this.quickFailureTest("foo","getter/setter",function(){a.sut.validateProperty("foo","bar",{},{set:function(){}},
{})})},"Properties do not support visibility de-escalation":function(){this.quickVisChangeTest("public","protected",!0);this.quickVisChangeTest("protected","private",!0)},"Properties do support visibility escalation and equality":function(){var a=this;b.visEscalationTest(function(b){a.quickVisChangeTest(b[0],b[1],!1)})},"Cannot redeclare private properties in subtypes":function(){var a=this;b.privateNamingConflictTest(function(b){a.quickVisChangeTest(b[0],b[1],!0,"conflict")})}})})(f["test/MemberBuilderValidator/PropertyTest"]=
{},"test/MemberBuilderValidator");(function(c){c.exports={};document.write("test/MemberBuilder/VisibilityTest...<br />");var a=!g("common").require("util").definePropertyFallback();g("common").testCase({caseSetUp:function(){var b=this;this.buildStubMethod=function(a,c,h){var f={};f[h]=!0;b.sut.buildMethod(b.members,{},a,function(){return c},f,function(){},1,{})};this.buildStubProp=function(a,c,h){var f={};f[h]=!0;b.sut.buildProp(b.members,{},a,c,f,{})};this.buildStubGetterSetter=function(a,c,h,f){var g=
{};g[f]=!0;b.sut.buildGetterSetter(b.members,{},a,c,h,g,{})};this.assertOnlyIn=function(a,c){var h=!1;b.incAssertCount();for(var f in b.members)"undefined"!==typeof b.members[f][c]&&(h=!0,f!==a&&b.fail(c+" should only be accessible in: "+a));h||b.fail("Did not find '"+c+"' in level: "+a)};this.basicVisPropTest=function(a){var c=a+"propname",h=a+"val";b.buildStubProp(c,h,a);b.assertEqual(b.members[a][c][0],h);b.assertOnlyIn(a,c,b.members)};this.basicVisMethodTest=function(a){var c=a+"methodname",h=
a+"val";b.buildStubMethod(c,h,a);b.assertEqual(b.members[a][c](),h);b.assertOnlyIn(a,c,b.members)};this.basicVisGetterSetterTest=function(d){if(a){var c=d+"getsetname",h=function(){return!0},f=function(){};b.buildStubGetterSetter(c,h,f,d,"get");var g=Object.getOwnPropertyDescriptor(b.members[d],c);b.assertEqual(g.get,h);b.assertEqual(g.set,f);b.assertOnlyIn(d,c,b.members)}};this.multiVisFailureTest=function(a){for(var c=[{"public":!0,"protected":!0},{"public":!0,"private":!0},{"protected":!0,"private":!0}],
h=0,f=c.length;h<f;h++){b.incAssertCount();try{a("foo",c[h])}catch(g){b.assertOk(-1<g.message.search("access modifier"),"Unexpected error for multiple access modifiers");b.assertOk(-1<g.message.search("foo"),"Multiple access modifier error message should contain name of member; received: "+g.message);break}b.fail("Should fail with multiple access modifiers: "+h)}}},setUp:function(){var a=this.require("MethodWrapperFactory")(function(a){return a});this.sut=this.require("MemberBuilder")(a,a,a,this.getMock("MemberBuilderValidator"));
this.members=this.sut.initMembers()},"Can create empty member object":function(){for(var a=this.sut.initMembers(),d=["public","protected","private"],c=0,h=d.length;c<h;c++)this.assertOk("undefined"!==typeof a[d[c]],"Clean member object is missing visibility level: "+d[c])},"Can initialize member object with existing objects":function(){var a={foo:"bar"},d={bar:"baz"},c={baz:"foo"},h=this.sut.initMembers(a,d,c),a={"public":a,"protected":d,"private":c},f;for(f in a)this.assertStrictEqual(a[f],h[f],
"Visibility level '"+f+"' cannot be initialized")},"Members are only accessible via their respective interfaces":function(){var a=["public","protected","private"],d;for(d in a)this.basicVisPropTest(a[d]),this.basicVisMethodTest(a[d]),this.basicVisGetterSetterTest(a[d])},"Members will be declared public if access modifier is omitted":function(){var b=function(){},d=function(){},c=function(){};this.sut.buildProp(this.members,{},"prop","foo",{},{});this.sut.buildMethod(this.members,{},"method",b,{},
function(){},1,{});a&&this.sut.buildGetterSetter(this.members,{},"getset",d,c,{},{});this.assertStrictEqual(this.members["public"].prop[0],"foo","Properties should be public by default");this.assertStrictEqual(this.members["public"].method,b,"Methods should be public by default");a&&(b=Object.getOwnPropertyDescriptor(this.members["public"],"getset"),this.assertStrictEqual(b.get,d,"Getters should be public by default"),this.assertStrictEqual(b.set,c,"Setters should be public by default"))},"Only one access modifier may be used per property":function(){var a=
this;this.multiVisFailureTest(function(d,c){a.sut.buildProp(a.members,{},d,"baz",c,{})})},"Only one access modifier may be used per method":function(){var a=this;this.multiVisFailureTest(function(d,c){a.sut.buildMethod(a.members,{},d,function(){},c,{})})},"Only one access modifier may be used per getter/setter":function(){if(a){var b=this;this.multiVisFailureTest(function(a,c){b.sut.buildGetterSetter(b.members,{},a,function(){},function(){},c,{})})}}})})(f["test/MemberBuilder/VisibilityTest"]={},
"test/MemberBuilder");(function(c){c.exports={};document.write("test/MethodWrapperFactoryTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("MethodWrapperFactory")},"Can instantiate with and without new keyword":function(){this.assertOk(new this.Sut instanceof this.Sut,"Should be able to instantiate MethodWrapperFactory with 'new' keyword");this.assertOk(this.Sut()instanceof this.Sut,"Should be able to instantiate MethodWrapperFactory without 'new' keyword")},"Provided factory function is properly called":function(){var a=
this,b=!1,d=function(){},c=function(){},f=function(){},g={"static":!0,"public":!0},j=this.Sut(function(j,m,t,o,n,q){b=!0;a.assertEqual(j,d,"Factory method should be provided with method to wrap");a.assertEqual(m,c,"Factory method should be provided with super method");a.assertEqual(t,55,"Factory method should be provided with cid");a.assertEqual(o,f,"Factory method should be provided with proper inst function");a.assertEqual(n,"someMethod","Factory method should be provided with proper method name");
a.assertEqual(q,g,"Factory method should be provided with proper keywords");return"foobar"}).wrapMethod(d,c,55,f,"someMethod",g);this.assertEqual(b,!0,"Given factory method should be called");this.assertEqual(j,"foobar","Should return value from factory function")}})})(f["test/MethodWrapperFactoryTest"]={},"test");(function(c){c.exports={};document.write("test/MethodWrappersTest...<br />");g("common").testCase({caseSetUp:function(){this.proxyErrorAssertCommon=function(a,b,d){this.assertOk(-1<a.message.search("Unable to proxy"),
"Unexpected error received: "+a.message);this.assertOk(-1<a.message.search(b)&&-1<a.message.search(d),"Error should contain property and method names")}},setUp:function(){this._sut=this.require("MethodWrappers")},"Method invocation binds `this` to passed instance":function(){var a=function(){},b=function(){return a},d=this._sut.standard.wrapNew(function(){return this.foo},null,0,b),b=this._sut.standard.wrapOverride(function(){return this.foo2},d,0,b);a.foo="fooboo";a.foo2="fooboo2";this.assertEqual(d(),
"fooboo","Calling method will bind 'this' to passed instance");this.assertEqual(b(),"fooboo2","Calling method override will bind 'this' to passed instance")},"Overriden method should contain reference to super method":function(){var a=this,b=!1,d=function(){};this._sut.standard.wrapOverride(function(){a.assertNotEqual(this.__super,void 0,"__super is defined for overridden method");this.__super();a.assertEqual(b,!0,"Invoking __super calls super method")},this._sut.standard.wrapNew(function(){b=!0},
null,0,d),0,d)()},"Super method works properly when context differs":function(){var a=!1,b={},d=function(){return b};this._sut.standard.wrapOverride(function(){this.__super()},this._sut.standard.wrapNew(function(){a=!0},null,0,d),0,d)();this.assertEqual(a,!0,"__super() method is called even when context differs");this.assertEqual(b.__super,void 0,"__super() method is unset after being called")},"Proxy will properly forward calls to destination object":function(){var a=[1,{},"three"],b=[],d={},c={dest:{someMethod:function(){b=
Array.prototype.slice.call(arguments);return d}}},f=this._sut.standard.wrapProxy("dest",null,0,function(){return c},"someMethod");this.assertStrictEqual(d,f.apply(c,a),"Proxy call should return the value from the destination");this.assertDeepEqual(a,b,"All arguments should be properly forwarded to the destination")},"Proxy retval is replaced with context if dest returns self":function(){var a={bar:function(){return a}},b={foo:a},d=this._sut.standard.wrapProxy("foo",null,0,function(){return b},"bar").call(b);
this.assertStrictEqual(b,d,"Proxy should return instance in place of destination, if returned")},"Proxy throws error if call will faill due to non-object":function(){try{this._sut.standard.wrapProxy("noexist",null,0,function(){return{}},"foo")()}catch(a){this.proxyErrorAssertCommon(a,"noexist","foo");return}this.assertFail("Error should be thrown if proxy would fail due to a non-object")},"Proxy throws error if call will fail due to non-function":function(){try{this._sut.standard.wrapProxy("dest",
null,0,function(){return{dest:{foo:"notafunc"}}},"foo")()}catch(a){this.proxyErrorAssertCommon(a,"dest","foo");return}this.assertFail("Error should be thrown if proxy would fail due to a non-function")},"Can proxy to static members":function(){val=["value"];s={foo:{method:function(){return val}}};this.assertStrictEqual(val,this._sut.standard.wrapProxy("foo",null,0,function(){return{$:function(a){return s[a]}}},"method",{"static":!0})(),"Should properly proxy to static membesr via static accessor method")},
"Proxy methods are able to satisfy abstract method param requirements":function(){this.assertOk(!(0<this._sut.standard.wrapProxy({},null,0,function(){},"",{}).__length))}})})(f["test/MethodWrappersTest"]={},"test");(function(c){c.exports={};document.write("test/PropParserKeywordsTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("prop_parser")},setUp:function(){this.ptest=this.Sut.parseKeywords("virtual static abstract foo")},"Retrieves field name void of keywords":function(){this.assertEqual(this.ptest.name,
"foo")},"Retrieves all keywords":function(){var a=this.ptest.keywords;this.assertOk(a.virtual);this.assertOk(a["static"]);this.assertOk(a["abstract"])},"Does not include keywords not explicitly provided":function(){var a=this.ptest.keywords;delete a.virtual;delete a["static"];delete a["abstract"];for(var b in a)this.assertFail("Someone has been drinking: "+b);this.assertOk(!0)},"Accepts all valid keywords":function(){var a=this.Sut.parseKeywords;this.assertDoesNotThrow(function(){a("public protected private virtual abstract override static const proxy weak var")},
Error)},"Does not accept unknown keywords":function(){var a=this.Sut.parseKeywords;try{a("foobunny moobunny")}catch(b){this.assertOk(-1!==b.message.search("foobunny"),"Error message contains unrecognized keyword");this.assertOk(-1!==b.message.search("moobunny"),"Error message contains name");return}this.assertFail("Should not permit unknown keywords")}})})(f["test/PropParserKeywordsTest"]={},"test");(function(c){c.exports={};document.write("test/Trait/AbstractTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=
this.require("Trait");this.Class=this.require("class");this.AbstractClass=this.require("class_abstract")},"Abstract traits create abstract classes when used":function(){var a=this.Sut({"abstract foo":[]}),b=this;this.assertDoesNotThrow(function(){b.AbstractClass.use(a).extend({})},Error)},"Concrete classes may use abstract traits by definining members":function(){var a=this.Sut({"abstract traitfoo":["foo"]}),b=null,d=!1,c=this;this.assertDoesNotThrow(function(){b=c.Class.use(a).extend({traitfoo:function(){d=
!0}})});b().traitfoo();this.assertOk(d)},"Concrete classes must be compatible with abstract traits":function(){var a=this.Sut({"abstract traitfoo":["foo"]}),b=this;this.assertThrows(function(){C=b.Class.use(a).extend({traitfoo:function(){}})})},"Traits can invoke concrete class implementation of abstract method":function(){this.assertEqual(this.Class.use(this.Sut({"public getFoo":function(){return this.echo("foobar")},"abstract protected echo":["value"]})).extend({"protected echo":function(a){return a}})().getFoo(),
"foobar")},"Traits can invoke concrete trait implementation of abstract method":function(){var a=this.Sut({"public getFoo":function(){return this.echo("traitbar")},"abstract public echo":["value"]}),b=this.Sut({"public echo":function(a){return a}});this.assertEqual(this.Class.use(a,b).extend({})().getFoo(),"traitbar");this.assertEqual(this.Class.use(b,a).extend({})().getFoo(),"traitbar","Crap; order matters?!")},"Abstract method inherited from trait can be implemented by subtype":function(){var a=
!1;this.AbstractClass.use(this.Sut({"public doFoo":function(){this.foo()},"abstract protected foo":[]})).extend({}).extend({"protected foo":function(){a=!0}})().doFoo();this.assertOk(a)},"Chained mixins properly carry abstract flag":function(){var a=this,b=this.Sut({foo:function(){}}),d=this.Sut({baz:function(){}}),c=this.Sut({"abstract baz":[]});this.assertDoesNotThrow(function(){a.assertOk(a.AbstractClass.use(c).extend({}).isAbstract());a.assertOk(a.AbstractClass.use(b).extend({"abstract baz":[]}).isAbstract());
a.assertOk(a.AbstractClass.use(b).use(c).extend({}).isAbstract());a.assertOk(a.AbstractClass.use(c).use(b).extend({}).isAbstract())});this.assertThrows(function(){a.AbstractClass.use(d).extend({})});this.assertThrows(function(){a.AbstractClass.use(c).extend({baz:function(){}})});this.assertThrows(function(){a.AbstractClass.use(c).use(d).extend({})})},"Explicitly-declared class will not be automatically abstract":function(){var a=this,b=this.Sut({foo:function(){}}),d=this.Sut({"abstract foo":[]});
this.assertThrows(function(){a.assertOk(!a.AbstractClass.use(b).extend({}).isAbstract())});this.assertDoesNotThrow(function(){a.assertOk(a.AbstractClass.use(b).extend({"abstract bar":[]}).isAbstract());a.assertOk(a.AbstractClass.use(d).extend({}).isAbstract())});this.assertThrows(function(){a.Class.use(b).extend({"abstract bar":[]})});this.assertThrows(function(){a.Class.use(d).extend()})}})})(f["test/Trait/AbstractTest"]={},"test/Trait");(function(c){c.exports={};document.write("test/Trait/ClassVirtualTest...<br />");
g("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class");this.AbstractClass=this.require("class_abstract");this.Interface=this.require("interface")},"Traits may implement an interface":function(){var a=this;this.assertDoesNotThrow(function(){a.Sut.implement(a.Interface({})).extend({})})},"Traits implementing interfaces define abstract methods":function(){var a=this.Sut.implement(this.Interface({foo:[],bar:[]})).extend({}),b=this.Class,d=this.AbstractClass;
this.assertThrows(function(){b.use(a).extend({})});this.assertDoesNotThrow(function(){d.use(a).extend({})});this.assertDoesNotThrow(function(){d.use(a).extend({foo:function(){}})});this.assertDoesNotThrow(function(){b.use(a).extend({foo:function(){},bar:function(){}})})},"Traits may provide concrete methods for interfaces":function(){var a=!1,b=this.Sut.implement(this.Interface({foo:[]})).extend({foo:function(){a=!0}}),d=this.Class;this.assertDoesNotThrow(function(){d.use(b).extend({})().foo()});
this.assertOk(a)},"Instance of class mixing in trait implementing I is of type I":function(){var a=this.Interface({}),b=this.Sut.implement(a).extend({});this.assertOk(this.Class.isA(a,this.Class.use(b).extend({})()))},"Trait can implement multiple interfaces":function(){var a=this.Interface({}),b=this.Interface({}),d=this.Class.use(this.Sut.implement(a,b).extend({})).extend({})();this.assertOk(this.Class.isA(a,d));this.assertOk(this.Class.isA(b,d))},"Mixin can override virtual concrete method defined by interface":function(){var a=
!1,b=this.Interface({foo:[]}),d=this.Sut.implement(b).extend({"abstract override foo":function(){a=!0}}),c=this;this.Class.implement(b).extend({"virtual foo":function(){c.fail(!1,!0,"Concrete class method was not overridden by mixin")}}).use(d)().foo();this.assertOk(a)}})})(f["test/Trait/ClassVirtualTest"]={},"test/Trait");(function(c){c.exports={};document.write("test/Trait/DefinitionTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class");
this.Interface=this.require("interface");this.AbstractClass=this.require("class_abstract");this.hasGetSet=!this.require("util").definePropertyFallback();this.ctor=[this.Sut.extend,this.Sut];this.fconflict=[["foo","same name; no keywords",{foo:function(){}},{foo:function(){}}],["foo","same keywords; same visibility",{"public foo":function(){}},{"public foo":function(){}}],["foo","varying keywords; same visibility",{"virtual public foo":function(){}},{"public virtual foo":function(){}}],["foo","different visibility",
{"public foo":function(){}},{"protected foo":function(){}}]];this.base=[this.Class]},"@each(ctor) Can extend Trait to create anonymous trait":function(a){this.assertOk(this.Sut.isTrait(a({})))},"@each(ctor) Cannot instantiate trait without error":function(a){this.assertThrows(function(){a({})()},Error)},"@each(ctor) Base class definition is applied when using traits":function(a){a=this.Class.use(a({})).extend({foo:"bar"});this.assertOk(this.Class.isClass(a));this.assertEqual(a().foo,"bar")},"@each(ctor) Supertype definition is applied when using traits":function(a){expected2=
"baz";Foo=this.Class({foo:"bar"});SubFoo=this.Class.use(a({})).extend(Foo,{bar:expected2});a=SubFoo();this.assertOk(this.Class.isA(Foo,a));this.assertEqual(a.foo,"bar","Supertype failure");this.assertEqual(a.bar,expected2,"Subtype failure")},"@each(ctor) Trait definition is mixed into base class definition":function(a){var b=!1,d=this.Class.use(a({foo:function(){b=!0}})).extend({})();this.assertDoesNotThrow(function(){d.foo()},Error,"Should have access to mixed in fields");this.assertOk(b,"Mixed in field copy error")},
"@each(ctor) Trait definition is mixed into subtype definition":function(a){var b=!1,a=a({foo:function(){b=!0}}),d=this.Class({});this.Class.use(a).extend(d,{})().foo();this.assertOk(b)},"Traits cannot define __construct":function(){try{this.Sut({__construct:function(){}})}catch(a){this.assertOk(a.message.match(/\b__construct\b/));return}this.fail("Traits should not be able to define __construct")},"@each(fconflict) Cannot mix in multiple concrete methods of same name":function(a){var b=a[0],d=a[1],
c=this.Sut(a[2]),a=this.Sut(a[3]);try{this.Class.use(c,a).extend({})}catch(f){this.assertOk(f.message.match("\\b"+b+"\\b"),"Error message missing field name: "+f.message);return}this.fail(!1,!0,"Mixin must fail on conflict: "+d)},"A class is considered to be a type of each used trait":function(){var a=this.Sut({}),b=this.Sut({}),d=this.Sut({}),c=this.Class.use(a,b).extend({})();this.assertOk(this.Class.isA(a,c));this.assertOk(this.Class.isA(b,c));this.assertOk(!1===this.Class.isA(d,c))},"Can mix traits into named class":function(){var a=
!1,b=this.Sut({foo:function(){a=!0}});this.Class("Named").use(b).extend({})().foo();this.assertOk(a)},"Explicit class definitions must be terminated by an extend call":function(){var a=this,b=this.Sut({foo:function(){}}),d=this.Sut({bar:function(){}});this.assertThrows(function(){a.Class.use(b)()},TypeError);this.assertThrows(function(){a.Class.use(b).use(d)()},TypeError);this.assertThrows(function(){a.AbstractClass.use(b)()},TypeError);this.assertDoesNotThrow(function(){a.Class.use(b).extend({})();
a.Class.use(b).use(d).extend({})()})},"Can mix traits into class after implementing interface":function(){var a=this,b=!1,d=this.Sut({foo:function(){b=!0}}),c=this.Interface({bar:[]}),f=null;this.assertDoesNotThrow(function(){f=a.AbstractClass.implement(c).use(d).extend({});a.assertOk(f.isAbstract())});this.assertThrows(function(){a.Class.implement(c).use(d).extend({})});f.extend({bar:function(){}})().foo();this.assertOk(b)},"Trait method that returns self will return containing class":function(){var a=
this;this.Class.use(this.Sut({foo:function(){return this}})).extend({go:function(){a.assertStrictEqual(this,this.foo())}})().go()},"Trait static members are prohibited":function(){var a=this.Sut;this.assertThrows(function(){a({"static private foo":"prop"})});this.assertThrows(function(){a({"static foo":function(){}})})},"Trait getters and setters are prohibited":function(){if(this.hasGetSet){var a=this.Sut;this.assertThrows(function(){var b={};Object.defineProperty(b,"foo",{get:function(){},set:function(){},
enumerable:!0});a(b)})}}})})(f["test/Trait/DefinitionTest"]={},"test/Trait");(function(c){c.exports={};document.write("test/Trait/ImmediateTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class")},"Invoking partial class after mixin instantiates":function(){var a=!1,b=this.Sut({"public foo":function(){a=!0}});this.Class.extend({}).use(b)().foo();this.assertOk(a)},"Can invoke partial mixin atop of non-empty base":function(){var a=!1,
b=!1,d=this.Class({"public foo":function(){a=!0}}),c=this.Sut({"public bar":function(){b=!0}}),d=d.use(c)();d.foo();d.bar();this.assertOk(a);this.assertOk(b)},"Partial arguments are passed to class constructor":function(){var a=null,b={foo:"bar"},d=this.Class({__construct:function(){a=arguments}}),c=this.Sut({});d.use(c)(b);this.assertStrictEqual(a[0],b)}})})(f["test/Trait/ImmediateTest"]={},"test/Trait");(function(c){c.exports={};document.write("test/Trait/LinearizationTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=
this.require("Trait");this.Class=this.require("class");this.Interface=this.require("interface")},"Class super call refers to mixin that is part of a class definition":function(){var a=this,b=!1;this.Class.use(this.Sut({"virtual public foo":function(){b=!0}})).extend({"override public foo":function(){try{this.__super()}catch(b){a.fail(!1,!0,"Super invocation failure: "+b.message)}}})().foo();this.assertOk(b)},"Mixin overriding class method has class method as super method":function(){var a=this,b=
{},d=this.Interface({foo:[]}),c=this.Sut.implement(d).extend({"abstract override foo":function(){return this.__super(b)}}),f=Math.random();this.assertStrictEqual(this.Class.implement(d).extend({"private _priv":f,"virtual foo":function(b){a.assertEqual(f,this._priv);return b}}).use(c)().foo(),b)},"Mixin overriding another mixin method M has super method M":function(){var a,b,d,c=this.Interface({foo:[]}),f=this.Sut.implement(c).extend({"virtual abstract override foo":function(){a=!0;this.__super()}}),
g=this.Sut.implement(c).extend({"abstract override foo":function(){b=!0;this.__super()}});this.Class.implement(c).extend({"virtual foo":function(){d=!0}}).use(f).use(g)().foo();this.assertOk(a);this.assertOk(b);this.assertOk(d)},"Mixin can be mixed in atop of itself":function(){var a=0,b=!1,d=this.Interface({foo:[]}),c=this.Sut.implement(d).extend({"virtual abstract override foo":function(){a++;this.__super()}});this.Class.implement(d).extend({"virtual foo":function(){b=!0}}).use(c).use(c).use(c)().foo();
this.assertEqual(a,3);this.assertOk(b)}})})(f["test/Trait/LinearizationTest"]={},"test/Trait");(function(c){c.exports={};document.write("test/Trait/MixedExtendTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class")},"Subtype instantiates traits of supertype":function(){var a=!1;this.Class.use(this.Sut({foo:function(){a=!0}})).extend({}).extend({__construct:function(){}})().foo();this.assertOk(a)},"Subtype has same polymorphic qualities of parent mixins":function(){var a=
this.Sut({}),b=this.Class.use(a).extend({}).extend({})();this.assertOk(this.Class.isA(a,b))},"Subtype can mix in additional traits":function(){var a=!1,b=!1,d=this.Sut({"public ta":function(){a=!0}}),c=this.Sut({"public tb":function(){b=!0}}),f=null,g=this;this.assertDoesNotThrow(function(){var a=g.Class.use(d).extend({});f=g.Class.use(c).extend(a,{})});this.assertDoesNotThrow(function(){var a=f();a.ta();a.tb()});this.assertOk(a);this.assertOk(b)},"Subtype trait types do not overwrite supertype types":function(){var a=
this.Sut({}),b=this.Sut({}),d=this.Class.use(a).extend({}),d=this.Class.use(b).extend(d,{})();this.assertOk(this.Class.isA(a,d));this.assertOk(this.Class.isA(b,d))},"Can mix in traits directly atop of existing class":function(){var a=!1,b=!1,d=!1,c=this.Class({"public foo":function(){a=!0}}),f=this.Sut({"public bar":function(){b=!0}}),c=c.use(f).extend({"public baz":function(){d=!0}})();c.foo();c.bar();c.baz();this.assertOk(a);this.assertOk(b);this.assertOk(d)},"Can chain use calls":function(){var a=
this.Sut({foo:function(){}}),b=this.Sut({bar:function(){}}),d=null,c=this.Class;this.assertDoesNotThrow(function(){d=c.extend({}).use(a).use(b)});this.assertDoesNotThrow(function(){d().foo();d().bar()})}})})(f["test/Trait/MixedExtendTest"]={},"test/Trait");(function(c){c.exports={};document.write("test/Trait/NamedTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class")},"Anonymous trait is properly indicated when converted to string":function(){this.assertEqual(this.Sut({}).toString(),
"(Trait)")},"Named trait contains name when converted to string":function(){this.assertOk(this.Sut("FooTrait",{}).toString().match("FooTrait"))},"Named trait definition cannot contain zero or more than two arguments":function(){var a=this.Sut;this.assertThrows(function(){a()});this.assertThrows(function(){a(1,2,3)})},"First argument in named trait definition must be a string":function(){var a=this.Sut;this.assertThrows(function(){a({},{})})}})})(f["test/Trait/NamedTest"]={},"test/Trait");(function(c){c.exports=
{};document.write("test/Trait/PropertyTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait")},"Private trait properties are permitted":function(){var a=this.Sut;this.assertDoesNotThrow(function(){a({"private _foo":"bar"})})},"Public and protected trait properties are prohibited":function(){var a=this.Sut;this.assertThrows(function(){a({"public foo":"bar"})});this.assertThrows(function(){a({"protected foo":"bar"})})}})})(f["test/Trait/PropertyTest"]={},"test/Trait");
(function(c){c.exports={};document.write("test/Trait/ScopeTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class")},"Private class members are not accessible to used traits":function(){var a=this.Class.use(this.Sut({"public getPriv":function(){return this._priv},"public invokePriv":function(){this._privMethod()}})).extend({"private _priv":"foo","private _privMethod":function(){}})();this.assertEqual(a.getPriv(),void 0);this.assertThrows(function(){a.invokePriv()},
Error)},"Private trait members are not accessible to containing class":function(){var a=this.Class.use(this.Sut({"private _priv":"bar","private _privMethod":function(){}})).extend({"public getPriv":function(){return this._priv},"public invokePriv":function(){this._privMethod()}})();this.assertEqual(a.getPriv(),void 0);this.assertThrows(function(){a.invokePriv()},Error)},"Traits do not have access to each others' private members":function(){var a=this.Sut({"private _priv1":"foo","private _privMethod1":function(){}}),
b=this.Sut({"public getPriv":function(){return this._priv1},"public invokePriv":function(){this._privMethod1()}}),d=this.Class.use(a,b).extend({})();this.assertEqual(d.getPriv(),void 0);this.assertThrows(function(){d.invokePriv()},Error)},"Classes can access protected trait members":function(){var a=this.Sut({"protected foo":function(){}}),b=this;this.assertDoesNotThrow(function(){b.Class.use(a).extend({"public callFoo":function(){this.foo()}})().callFoo()})}})})(f["test/Trait/ScopeTest"]={},"test/Trait");
(function(c){c.exports={};document.write("test/Trait/VirtualTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("Trait");this.Class=this.require("class")},"Class inherits virtual trait method":function(){var a=!1,b=this.Class.use(this.Sut({"virtual foo":function(){a=!0}})).extend({});b().foo();this.assertOk(a,"Virtual method not called");var d=!1,c;this.assertDoesNotThrow(function(){c=b.extend({"override foo":function(){d=!0}})});c().foo();this.assertOk(d,"Method not overridden")},
"Class can override virtual trait method":function(){var a=this;this.assertEqual(this.Class.use(this.Sut({"virtual foo":function(){a.fail(!0,!1,"Method was not overridden.")}})).extend({"override foo":function(){return"foobar"}})().foo(),"foobar")},"Class-overridden virtual trait method is accessible by trait":function(){var a=this,b=!1;this.Class.use(this.Sut({"public doFoo":function(){this.foo()},"virtual protected foo":function(){a.fail(!0,!1,"Method not overridden.")}})).extend({"override protected foo":function(){b=
!0}})().doFoo();this.assertOk(b)},"Subtype can override virtual method of trait mixed into supertype":function(){var a=this,b=!1;this.Class.use(this.Sut({"public doFoo":function(){return this.foo()},"virtual protected foo":function(){a.fail(!0,!1,"Method not overridden.")}})).extend({}).extend({"override protected foo":function(){b=!0}})().doFoo();this.assertOk(b)},"Virtual trait method returning self returns class instance":function(){var a=this;this.Class.use(this.Sut({"virtual foo":function(){return this}})).extend({go:function(){a.assertStrictEqual(this,
this.foo())}})().go()},"Overridden virtual trait method returning self returns class instance":function(){var a=this;this.Class.use(this.Sut({"virtual foo":function(){return this}})).extend({"override foo":function(){return this.__super()},go:function(){a.assertStrictEqual(this,this.foo())}})().go()},"Data are properly returned from trait override super call":function(){var a=this,b={};this.Class.use(this.Sut({"virtual foo":function(){return b}})).extend({"override foo":function(){a.assertStrictEqual(b,
this.__super())}})().foo()},"Super trait method overrided in class executed within private context":function(){var a={},b=this.Sut({"virtual foo":function(){return this.priv()},"private priv":function(){return a}});this.assertStrictEqual(a,this.Class.use(b).extend({"override virtual foo":function(){return this.__super()}})().foo())}})})(f["test/Trait/VirtualTest"]={},"test/Trait");(function(c){c.exports={};document.write("test/Util/AbstractTest...<br />");g("common").testCase({setUp:function(){this.Sut=
this.require("util")},"abstractMethod returns a function":function(){this.assertEqual(typeof this.Sut.createAbstractMethod(),"function")},"Returned function is considered abstract by isAbstractMethod":function(){this.assertOk(this.Sut.isAbstractMethod(this.Sut.createAbstractMethod()))},"Abstract methods cannot be invoked":function(){var a=this.Sut;this.assertThrows(function(){a.createAbstractMethod()()},Error)}})})(f["test/Util/AbstractTest"]={},"test/Util");(function(c){c.exports={};document.write("test/Util/CloneTest...<br />");
g("common").testCase({caseSetUp:function(){this.Sut=this.require("util")},"Cloned array is not the same object as the original":function(){var a=[1,2,3];this.assertNotStrictEqual(this.Sut.clone(a),a)},"Cloned object is not the same object as the original":function(){var a={foo:"bar"};this.assertNotStrictEqual(this.Sut.clone(a),a)},"Cloned array data mirrors original (shallow clone)":function(){for(var a=[1,"2",{three:3},[4]],b=this.Sut.clone(a),d=0,c=a.length;d<c;d++)this.assertStrictEqual(a[d],b[d])},
"Cloned object data mirrors original (shallow clone)":function(){var a={a:1,b:[2],c:{three:3},d:"4"},b=this.Sut.clone(a),d;for(d in a)this.assertStrictEqual(a[d],b[d])},"Deeply cloned array data mirrors original":function(){var a=[[1,2],[3,4],[5,[6,7]],{a:1}],b=this.Sut.clone(a,!0);this.assertDeepEqual(a,b);for(var d=0,c=a.length;d<c;d++)this.assertNotStrictEqual(a[d],b[d])},"Deeply cloned object data mirrors original":function(){var a={a:[1],b:[2],c:{d:3}},b=this.Sut.clone(a,!0);this.assertDeepEqual(a,
b);for(var d in a)this.assertNotStrictEqual(a[d],b[d])},"Functions are returned by reference, not cloned":function(){var a=function(){};this.assertStrictEqual(a,this.Sut.clone({foo:a},!0).foo)},"Primitives are returned by clone":function(){for(var a=[null,1,!0,!1,void 0],b=a.length;b--;){var d=a[b];this.assertEqual(d,this.Sut.clone(d),"Failed to clone primitive value: "+d)}this.assertOk(isNaN(this.Sut.clone(NaN)))}})})(f["test/Util/CloneTest"]={},"test/Util");(function(c){c.exports={};document.write("test/Util/CopyTest...<br />");
g("common").testCase({caseSetUp:function(){this.Sut=this.require("util");this.hasGetSet=!this.Sut.definePropertyFallback()},"Values are copied to destination object by reference":function(){var a={a:"a",b:2,c:!0,d:!1,e:void 0,d:null,f:function(){}},b={};this.Sut.copyTo(b,a);for(var d in a)this.assertStrictEqual(a[d],b[d])},"Getters and setters are copied to destination object by reference":function(){this.hasGetSet||this.skip();var a=function(){},b=function(){},d={},c={},f=null;Object.defineProperty(d,
"foo",{get:a,set:b,enumerable:!0});this.Sut.copyTo(c,d);f=Object.getOwnPropertyDescriptor(c,"foo");this.assertStrictEqual(f.get,a,"Getter is copied by reference by default");this.assertDeepEqual(f.set,b,"Setter is copied by reference by default")},"Copy operation returns destination object":function(){var a={};this.assertStrictEqual(this.Sut.copyTo(a,{}),a)},"Throws error if source or dest are not provided":function(){var a=this.Sut.copyTo;this.assertThrows(function(){a()},TypeError,"Dest parameter is required");
this.assertThrows(function(){a("bla",{})},TypeError,"Dest parameter is required to be an object");this.assertThrows(function(){a({})},TypeError,"Src parameter is required");this.assertThrows(function(){a({},"foo")},TypeError,"Src parameter is required to be an object")},"Deep copies are supported":function(){var a={foo:[1,2,3]},b=this.Sut.copyTo({},a,!0);this.assertDeepEqual(a.val,b.val,"Copied values should be comparitively equal with deep copy");this.assertNotStrictEqual(a.foo,b.foo,"Copied values should not be the same object after deep copy")}})})(f["test/Util/CopyTest"]=
{},"test/Util");(function(c){c.exports={};document.write("test/Util/DefineSecurePropTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("util");this.expected=Object.defineProperty instanceof Function?!1:!0;this.fallback=this.Sut.definePropertyFallback();if(!this.expected&&this.fallback)try{if(this.Sut.definePropertyFallback(!1),this.Sut.defineSecureProp({},"foo",1),!0===this.Sut.definePropertyFallback())this.expected=!0}catch(a){}this.descRestrictionCheck=function(a,d){this.fallback&&
this.skip();var c={};this.Sut.defineSecureProp(c,"foo",null);this.assertEqual(Object.getOwnPropertyDescriptor(c,"foo")[a],d)};this.forceFallback=function(a){this.Sut.definePropertyFallback(!0);a.call(this);this.Sut.definePropertyFallback(this.fallback)}},"definePropertyFallback returns whether secure definition is supported":function(){this.assertEqual(this.expected,this.Sut.definePropertyFallback())},"definePropertyFallback returns util when used as a setter":function(){this.assertStrictEqual(this.Sut.definePropertyFallback(this.fallback),
this.Sut)},"Defining secure prop creates field with given value on given object":function(){var a={},b={bar:"baz"};this.Sut.defineSecureProp(a,"foo",b);this.assertStrictEqual(a.foo,b)},"Secure property is not writable":function(){this.descRestrictionCheck("writable",!1)},"Secure property is not configurable":function(){this.descRestrictionCheck("configurable",!1)},"Secure property is not enumerable":function(){this.descRestrictionCheck("enumerable",!1)},"Defining secure prop creates field and value when falling back":function(){this.forceFallback(function(){var a=
{},b={bar:"baz"};this.Sut.defineSecureProp(a,"foo",b);this.assertStrictEqual(a.foo,b)})},"Secure property is writable when falling back":function(){this.forceFallback(function(){this.descRestrictionCheck("writable",!0)})},"Secure property is configurable when falling back":function(){this.forceFallback(function(){this.descRestrictionCheck("configurable",!0)})},"Secure property is enumerable when falling back":function(){this.forceFallback(function(){this.descRestrictionCheck("enumerable",!0)})}})})(f["test/Util/DefineSecurePropTest"]=
{},"test/Util");(function(c){c.exports={};document.write("test/Util/GetPropertyDescriptorTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("util");this.hasGetSet=!this.Sut.definePropertyFallback()},"Should use Object.getOwnPropertyDescriptor if available":function(){(!this.hasGetSet||!Object.getOwnPropertyDescriptor)&&this.skip();this.assertStrictEqual(this.Sut.getOwnPropertyDescriptor,Object.getOwnPropertyDescriptor)},"Indicates whether property chain traversal is possible":function(){this.assertEqual(this.Sut.getPropertyDescriptor.canTraverse,
"function"===typeof Object.getPrototypeOf)},"Traversable property is non-writable":function(){(!this.hasGetSet||!Object.getOwnPropertyDescriptor)&&this.skip();this.assertEqual(Object.getOwnPropertyDescriptor(this.Sut.getPropertyDescriptor,"canTraverse").writable,!1)},"Acts as ES5 getOwnPropertyDescriptor when one level deep":function(){var a={foo:"bar"},b=this.Sut.getOwnPropertyDescriptor(a,"foo"),a=this.Sut.getPropertyDescriptor(a,"foo");this.assertDeepEqual(b,a)},"Traverses the prototype chain when necessary":function(){this.Sut.getPropertyDescriptor.canTraverse||
this.skip();var a={foo:"bar"},b=function(){};b.prototype=a;b=new b;a=this.Sut.getOwnPropertyDescriptor(a,"foo");this.assertDeepEqual(this.Sut.getPropertyDescriptor(b,"foo"),a)}})})(f["test/Util/GetPropertyDescriptorTest"]={},"test/Util");(function(c){c.exports={};document.write("test/Util/PropParseKeywordsTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("util")},"`abstract' keyword designates method as abstract":function(){var a=this,b=["one","two"],d=null;this.Sut.propParse({"abstract foo":b},
{method:function(c,f,g){a.assertOk(g);a.assertEqual(typeof f,"function");a.assertOk(a.Sut.isAbstractMethod(f));a.assertEqual(f.__length,b.length);d=c}});this.assertEqual(d,"foo")},"Not considered abstract when `override' also provided":function(){var a=this,b=null;this.Sut.propParse({"abstract override foo":function(){}},{method:function(d,c,f){a.assertOk(!1===f);a.assertEqual(typeof c,"function");a.assertOk(!1===a.Sut.isAbstractMethod(c));b=d}});this.assertEqual(b,"foo")},"Supports custom property keyword parser":function(){var a=
{foo:{"abstract":!0}},b=[];this.Sut.propParse({foo:[]},{keywordParser:function(b){return{name:b+"poo",keywords:a[b]}},method:function(a,c,f){f&&b.push(a)}});this.assertOk("foopoo"===b[0],"Can provide custom property keyword parser")},"Keyword parser tolerates bogus responses":function(){var a=this.Sut.propParse;this.assertDoesNotThrow(function(){var b={foo:"bar"};a(b,{keywordParser:function(){}});a(b,{keywordParser:function(){return{name:[],keywords:"slefwef"}}})},Error)},"Parser returns keywords":function(){var a=
{"public foo":"","const foo2":"","public private const foo3":"","public static virtual method":function(){},"public  const   spaces":function(){}},b={},d={foo:{"public":!0},foo2:{"const":!0},foo3:{"public":!0,"private":!0,"const":!0},method:{"public":!0,"static":!0,virtual:!0},spaces:{"public":!0,"const":!0}};this.Sut.propParse(a,{property:function(a,d,c){b[a]=c},method:function(a,d,c,e){b[a]=e}});for(var c in b)this.assertDeepEqual(b[c],d[c],"Keywords are properly recognized and made available for interpretation ("+
c+")");!1===this.Sut.definePropertyFallback()&&(a={},b={},Object.defineProperty(a,"public foo",{get:function(){},set:function(){},enumerable:!0}),this.Sut.propParse(a,{getset:function(a,d,c,e){d&&(b[a+"g"]=e);c&&(b[a+"s"]=e)}}),this.assertDeepEqual(b.foog,{"public":!0},"Getter keywords are properly recognized and available"),this.assertDeepEqual(b.foos,{"public":!0},"Setter keywords are properly recognized and available"))}})})(f["test/Util/PropParseKeywordsTest"]={},"test/Util");(function(c){c.exports=
{};document.write("test/Util/PropParseTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("util");this.hasGetSet=!this.Sut.definePropertyFallback();this.checkType=function(a,b,d){this.checkTypeEx("foo",{foo:a},b,d)};this.checkTypeEx=function(a,b,d,c){var a={},f=null;a[d]=function(a){a===a&&(f=arguments)};this.Sut.propParse(b,a);this.assertOk(null!==f,"Type failure");c&&c.apply(this,f)}},"Detects string as property":function(){this.checkType("string","property")},"Detects boolean as property":function(){this.checkType(!0,
"property");this.checkType(!1,"property")},"Detects integer as property":function(){this.checkType(1,"property")},"Detects float as property":function(){this.checkType(3.14159,"property")},"Detects array as property":function(){this.checkType([],"property")},"Detects object as property":function(){this.checkType({},"property")},"Detects normal functions as concrete methods":function(){this.checkType(function(){},"method",function(a,b,c){this.assertOk(!c)})},"Detects special functions as abstract methods":function(){this.checkType(this.Sut.createAbstractMethod(),
"method",function(a,b,c){this.assertOk(c)})},"Detects proxies as methods":function(){this.checkTypeEx("foo",{"proxy foo":"bar"},"method")},"Detects getters and setters":function(){this.hasGetSet||this.skip();var a={},b,c,e=!1;Object.defineProperty(a,"foo",{get:b=function(){e=!0},set:c=function(){},enumerable:!0});this.checkTypeEx("foo",a,"getset",function(a,f,g){this.assertStrictEqual(b,f,"Getter mismatch");this.assertStrictEqual(c,g,"Setter mismatch");this.assertEqual(e,!1,"Getter should not be called during processing")})},
"Ignores prototype fields":function(){var a=function(){};a.prototype.one=1;a=new a;a.two=2;var b=[];this.Sut.propParse(a,{each:function(a){b.push(a)}});this.assertEqual(b.length,1);this.assertEqual(b[0],"two")},"Triggers error if invalid variable names are used as param names":function(){var a=this.Sut.propParse;this.assertThrows(function(){a({"abstract foo":["invalid name"]},{})},SyntaxError);this.assertThrows(function(){a({"abstract foo":["1invalid"]},{})},SyntaxError);this.assertDoesNotThrow(function(){a({"abstract foo":["valid_name"]},
{})},SyntaxError)},"Supports dynamic context to handlers":function(){function a(){b.assertStrictEqual(this,context)}var b=this;context={};var c={prop:"prop",method:function(){}};this.hasGetSet&&Object.defineProperty(c,"getset",{get:get=function(){},set:set=function(){},enumerable:!0});this.Sut.propParse(c,{each:a,property:a,getset:a,method:a},context)}})})(f["test/Util/PropParseTest"]={},"test/Util");(function(c){c.exports={};document.write("test/VersionTest...<br />");g("common").testCase({caseSetUp:function(){this.version=
this.require("version")},"Can retrieve major version number":function(){this.assertOk("number"===typeof this.version.major,"Major version number should be available")},"Can retrieve minor version number":function(){this.assertOk("number"===typeof this.version.minor,"Minor version number should be available")},"Can retrieve revision version number":function(){this.assertOk("number"===typeof this.version.rev,"Revision version number should be available")},"Array of version numbers is available":function(){this.assertEqual(this.version.major,
this.version[0]);this.assertEqual(this.version.minor,this.version[1]);this.assertEqual(this.version.rev,this.version[2])},"Version string is available":function(){var a=this.version;this.assertEqual(a.major+"."+a.minor+"."+a.rev+(a.suffix&&"-"+a.suffix||""),this.version.toString(),"Version string should be made available")}})})(f["test/VersionTest"]={},"test");(function(c){c.exports={};document.write("test/VisibilityObjectFactoryFactoryTest...<br />");g("common").testCase({caseSetUp:function(){this.sut=
this.require("VisibilityObjectFactoryFactory");this.VisibilityObjectFactory=this.require("VisibilityObjectFactory");this.FallbackVisibilityObjectFactory=this.require("FallbackVisibilityObjectFactory");this.util=this.require("util")},"Returns standard factory if not falling back":function(){this.util.definePropertyFallback()||this.assertOk(this.sut.fromEnvironment()instanceof this.VisibilityObjectFactory,"Creates standard VisibilityObjectFactory if supported")},"Returns fallback factory if falling back":function(){var a=
this.util.definePropertyFallback();this.util.definePropertyFallback(!0);this.assertOk(this.sut.fromEnvironment()instanceof this.FallbackVisibilityObjectFactory,"Creates fallback VisibilityObjectFactory if falling back");this.util.definePropertyFallback(a)}})})(f["test/VisibilityObjectFactoryFactoryTest"]={},"test");(function(c){c.exports={};document.write("test/VisibilityObjectFactoryTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("VisibilityObjectFactory");this.props=
{"public":{pub:[["foo"],{}]},"protected":{prot:[["bar"],{}]},"private":{priv:[["baz"],{}]}};this.methods={"public":{fpub:function(){var a=function(){};a.___$$keywords$$={"public":!0};return a}()},"protected":{fprot:function(){}},"private":{fpriv:function(){}}}},setUp:function(){this.require("util").definePropertyFallback()&&this.skip();this.sut=this.Sut()},"Can instantiate with and without `new` keyword":function(){this.assertOk(new this.Sut instanceof this.Sut,"Should be able to instantiate VisibilityObjectFactory with 'new' keyword");
this.assertOk(this.Sut()instanceof this.Sut,"Should be able to instantiate VisibilityObjectFactory without 'new' keyword")},"Can create property proxy":function(){var a={},b={},c={one:!0,two:!0,three:!0};this.sut.createPropProxy(a,b,c);for(var e in c)b[e]="foo",this.assertEqual(b[e],"foo","Property can be set/retrieved on destination object"),this.assertEqual(a[e],"foo","Property can be set via proxy and retrieved on base"),a[e]="bar",this.assertEqual(b[e],"bar","Property can be set on base and retrieved on dest object")},
"Setup creates private layer":function(){var a={foo:[]},b=this.sut.setup(a,this.props,this.methods);this.assertNotEqual(b,a,"Returned object should not be the destination object");this.assertStrictEqual(b.foo,a.foo,"Destination object is part of the prototype chain of the returned obj")},"Private layer includes protected member proxy":function(){var a={};this.sut.setup(a,this.props,this.methods).prot="foo";this.assertEqual(a.prot,"foo","Protected values are proxied from private layer")},"Public properties are copied to destination object":function(){var a=
{};this.sut.setup(a,this.props,this.methods);this.assertEqual(a.pub[0],this.props["public"].pub[0],"Public properties are properly initialized");this.assertNotStrictEqual(a.pub,this.props["public"].pub,"Public properties should not be copied by reference");this.assertEqual(a.fpub,void 0,"Public method references should not be copied")},"Protected properties and methods are added to dest object":function(){var a={};this.sut.setup(a,this.props,this.methods);this.assertEqual(a.prot[0],this.props["protected"].prot[0],
"Protected properties are properly initialized");this.assertNotStrictEqual(a.prot,this.props["protected"].prot,"Protected properties should not be copied by reference");this.assertStrictEqual(a.fprot,this.methods["protected"].fprot,"Protected members should be copied by reference")},"Public methods are not overwritten by default":function(){var a={fpub:this.methods["public"].fpub};this.methods["protected"].fpub=function(){};this.sut.setup(a,this.props,this.methods);this.assertStrictEqual(a.fpub,this.methods["public"].fpub,
"Public methods should not be overwritten by protected methods")},"Public methods are not overwritten when keyword is omitted":function(){var a=function(){};a.___$$keywords$$={};var b={fpub:a};this.methods["protected"].fpub=function(){};this.sut.setup(b,this.props,this.methods);this.assertStrictEqual(b.fpub,a,"Public methods should not be overwritten by protected methods")},"Private properties and methods are added to dest object":function(){var a=this.sut.setup({},this.props,this.methods);this.assertEqual(a.priv[0],
this.props["private"].priv[0],"Private properties are properly initialized");this.assertNotStrictEqual(a.priv,this.props["private"].priv,"Private properties should not be copied by reference");this.assertStrictEqual(a.fpriv,this.methods["private"].fpriv,"Private members should be copied by reference")}})})(f["test/VisibilityObjectFactoryTest"]={},"test");(function(c){c.exports={};document.write("test/WarnHandlersTest...<br />");"undefined"===typeof console&&(console=void 0);g("common").testCase({caseSetUp:function(){this.Sut=
this.require("warn")},setUp:function(){this.stubwarn=this.Sut.Warning(Error("gninraw"))},"`log' warning handler logs messages to console":function(){var a=this,b=!1;this.Sut.setConsole({warn:function(c){a.assertEqual("Warning: "+a.stubwarn.message,c);b=!0}});this.Sut.handlers.log(this.stubwarn);this.assertOk(b,!0,"Message should be logged to console");this.Sut.setConsole(console)},"`log' warning handler handles missing console":function(){var a=this.Sut;a.setConsole(void 0);this.assertDoesNotThrow(function(){a.handlers.log(this.warnstub)},
Error);a.setConsole(console)},"`log' warning handler falls back to log if warn is missing":function(){var a="";this.Sut.setConsole({log:function(b){a=b}});this.Sut.handlers.log(this.stubwarn);this.assertEqual("Warning: "+this.stubwarn.message,a,"Should fall back to log() and log proper message");this.Sut.setConsole(console)},"`throwError' warning handler throws wrapped error":function(){try{this.Sut.handlers.throwError(this.stubwarn)}catch(a){this.assertStrictEqual(a,this.stubwarn.getError(),"Wrapped exception should be thrown");
return}this.assertFail("Wrapped exception should be thrown")},"`dismiss' warning handler does nothing":function(){var a=this.Sut;a.setConsole(void 0);this.assertDoesNotThrow(function(){a.handlers.dismiss(this.warnstub)},Error);a.setConsole(console)}})})(f["test/WarnHandlersTest"]={},"test");(function(c){c.exports={};document.write("test/WarningTest...<br />");g("common").testCase({caseSetUp:function(){this.Sut=this.require("warn").Warning},"Warning has Error prototype":function(){this.assertOk(new this.Sut(Error())instanceof
Error)},"Warning should alter Error name":function(){this.assertEqual(this.Sut(Error()).name,"Warning")},"`new' operator is not necessary to instantiate Warning":function(){this.assertOk(this.Sut(Error(""))instanceof this.Sut)},"Warning message is set from wrapped exception":function(){var a=Error("oshit"),b=a.message;this.assertEqual(this.Sut(a).message,a.message);return b},"Throws exception if no exception is wrapped":function(){var a=this.Sut;this.assertThrows(function(){a()},TypeError);this.assertThrows(function(){a("not an exception")},
TypeError)},"Can retrieve wrapped exception":function(){var a=Error("foo"),b=this.Sut(a);this.assertStrictEqual(a,b.getError())}})})(f["test/WarningTest"]={},"test");(function(c){c.exports={};document.write("test/WarnTest...<br />");"undefined"===typeof console&&(console=void 0);g("common").testCase({setUp:function(){this.Sut=this.require("warn")},"Default warning handler is `log'":function(){var a=!1;this.Sut.setConsole({warn:function(){a=!0}});this.Sut.handle(this.Sut.Warning(Error("foo")));this.assertOk(a);
this.Sut.setConsole(console)},"Can set and call arbitrary warning handler":function(){var a,b=this.Sut.Warning(Error("foo"));this.Sut.setHandler(function(b){a=b});this.Sut.handle(b);this.assertDeepEqual(a,b)}})})(f["test/WarnTest"]={},"test")};y.Class=f["class"].exports;y.AbstractClass=f.class_abstract.exports;y.FinalClass=f.class_final.exports;y.Interface=f["interface"].exports;y.version=f.version.exports})(easejs);
